\documentstyle{book}
%\input{html.sty}
%\htmladdtonavigation
%   {\begin{rawhtml}
%      <!--#include file="fitsio_header.html"-->
%    \end{rawhtml}}
\oddsidemargin=0.25in
\evensidemargin=0.00in
\textwidth=6.0in
\topmargin=0.0in
\textheight=8.75in
\parindent=0cm
\parskip=0.2cm
\begin{document}

\begin{titlepage}
\normalsize
\vspace*{4.6cm}
\begin{center}
{\Huge \bf CFITSIO User's Guide}\\
\medskip 
\medskip 
\medskip 
\medskip 
{\LARGE \bf An Interface to FITS Format Files}\\
\medskip
\medskip
{\LARGE \bf for C Programmers}\\
\medskip
\medskip
\medskip
\medskip
{\Large Beta Version 0.99\\}
\bigskip
\vskip 3.0cm
{Dr. William D. Pence\\
HEASARC\\
Code 662\\
Goddard Space Flight Center\\
Greenbelt, MD 20771\\
USA}

\vfill
\bigskip
{\Large June 1996\\}
\end{center}
\vfill
\end{titlepage}

\begin{titlepage}
\vspace*{7.6cm}
\vfill
\end{titlepage}

\pagenumbering{roman}

\tableofcontents

\chapter{Introduction }
\pagenumbering{arabic}

CFITSIO is a machine-independent library of routines for reading and
writing data files in the FITS (Flexible Image Transport System) data
format. CFITSIO is written entirely in ANSI-C and provides the same
functions as in the previously available Fortran FITSIO library. This
library was written to provide a powerful yet simple interface for
accessing FITS files which will run on most commonly used computers and
workstations. This version of CFITSIO supports all the features
described in the official NOST definition of the FITS format and can
read and write all the currently defined types of extensions, including
ASCII tables (TABLE), Binary tables (BINTABLE) and IMAGE extensions.
The CFITSIO routines insulate the programmer from having to deal with
the complicated formatting details in the FITS file, however, it is
assumed that users have a general knowledge about the structure and
usage of FITS files.

This new ANSI-C library should not be confused with the previously
available set of C macros which provide a C-callable interface to the
Fortran FITSIO routines.  These older macros are contained in the
cfitsio.h file that is distributed along with the Fortran FITSIO source
files.  These macros will continue to be supported for a limited
period, but they should be considered obsolete.  New FITS application
software should be written using the new CFITSIO interface described
here.

The CFITSIO package was developed for use by the HEASARC (High Energy
Astrophysics Science Archive Research Center) at the NASA Goddard Space
Flight Center to convert various existing and newly acquired
astronomical data sets into FITS format and to further analyze data
already in FITS format.  The latest version of the CFITSIO source code,
documentation, and example programs are all available on the World-Wide
Web at the following URL:

\begin{verbatim}
        http://heasarc.gsfc.nasa.gov/docs/software/fitsio/fitsio.html
\end{verbatim}
CFITSIO also can be obtained from the HEASARC via anonymous ftp from
{\bf legacy.gsfc.nasa.gov}    (or, 128.183.126.108) in the
{\bf software/fitsio/c} subdirectory.

Any questions, bug reports, or suggested enhancements related to the CFITSIO
package should be sent to the author:

\begin{verbatim}
        Dr. William Pence                 Telephone:  (301) 286-4599
        HEASARC                           E-mail: pence@tetra.gsfc.nasa.gov
        Code 662
        NASA/Goddard Space Flight Center
        Greenbelt, MD 20771
        USA
\end{verbatim}
This User's Guide assumes that readers already have a general
understanding of the definition and structure of FITS format files.
For further information about FITS formats, please obtain a copy of the
`FITS User's Guide' and the `NOST FITS Standard', which are available
from the NASA, Science Office of Standards and Technology at the
address given below.  Both of these documents are available
electronically from their Web site and via anonymous ftp at
nssdc.gsfc.nasa.gov in the /pub/fits directory. Any questions about
FITS formats should be directed to the NOST, at:

\begin{verbatim}
        NASA, Science Office of Standards and Technology
        Code 633.2,
        Goddard Space Flight Center
        Greenbelt MD 20771
        USA
        WWW: http://ssdoo.gsfc.nasa.gov/astro/fits/fits_home.html
        E-mail: nost@nssdca.gsfc.nasa.gov
        (301) 286-3575
\end{verbatim}
CFITSIO users may also be interested in the FTOOLS package of programs
that can be used to manipulate and analyze FITS format files.
Information about FTOOLS can be obtained on the WWW at:

\begin{verbatim}
        http://heasarc.gsfc.nasa.gov/docs/software/ftools/ftools_menu.html
\end{verbatim}
or via anonymous FTP at:

\begin{verbatim}
        legacy.gsfc.nasa.gov  /software/ftools/release
\end{verbatim}

\chapter{ Creating the CFITSIO Library }


\section{Building the Library}

The CFITSIO code is contained in 9 source files (cfileio.c, convert.c,
fitscore.c, getcol.c, getkey.c, modkey.c, putcol.c, putkey.c, and
utilproc.c) and 3 header files (fitsio.h, fitsio2.h and longname.h).
On VAX/VMS systems 2 assembly-code files (vmsieeed.mar and
vmsieeer.mar) are also needed.

The CFITSIO library is built on Unix systems by typing:

\begin{verbatim}
   > configure
   > make
\end{verbatim}
at the operating system prompt.  The `configure' command customizes
the Makefile for your particular system, then the `make' command
builds the library.  The build process splits each routine in the
source files into a separate disk file in a scratch subdirectory.
Depending on the speed of the CPU, it can anywhere from a couple
minutes to an hour to create the libcfitsio.a library file.

On VAX/VMS and ALPHA/VMS systems, the makevaxvms.com and makealphavms.com
command files may be used to build the cfitsio.olb object library
(e.g., type '@makevaxvms' at the Vax command line to build the CFITSIO
library on a Vax).

On DOS-based PC computers, the makepc.bat file gives an example
of how to build the CFITSIO library.  This file will probably
need to be editted to include the appropriate command switches
if a different C compiler or linker is used.

CFITSIO has currently been tested on the following platforms:

\begin{verbatim}
   Operating System          Compiler
   ----------------          --------
   Sun OS                     gcc
   Sun Solaris                gcc
   Silicon Graphics IRIX      gcc and cc
   DECstation  Ultrix         gcc
   Dec Alpha OSF/1            gcc
   Dec Alpha OpenVMS          cc with /float=gfloat or /float=ieee options
   DEC VAX/VMS                gcc and cc
   Linux running on IBM PC    gcc
   IBM PC w/ Windows 95       Borland C++ V4.5
   Mac IIci                   Symantec C++
\end{verbatim}
CFITSIO will probably run on most other Unix platforms without
modification.  Cray supercomputers and IBM mainframe computers are
currently not supported.


\section{Testing the Library}

The CFITSIO library should be tested by building and running
the testprog.c program that is included with the release.
On Unix systems (assuming the gcc compiler is being used), type:

\begin{verbatim}
    % gcc -o testprog testprog.c -L. -lcfitsio
    % testprog > testprog.lis
    % diff testprog.lis testprog.out
    % cmp testprog.fit testprog.std
\end{verbatim}
 On VMS systems,
(assuming cc is the name of the C compiler command), type:

\begin{verbatim}
    $ cc testprog.c
    $ link testprog, cfitsio/lib
    $ run testprog
\end{verbatim}
The testprog program should produce a FITS file called `testprog.fit'
that is identical to the testprog.std FITS file included in this
release.  The diagnostic messages (which were piped to the file
testprog.lis in the Unix example) should be identical to the listing
contained in the file testprog.out.  The 'diff' and 'cmp' commands
shown above should not report any differences in the files.


\section{Getting Started}

In order to effectively use the CFITSIO library as quickly as possible,
it is recommended that new users follow these steps:

1.  Read the following `FITS Primer' chapter for a brief
overview of the structure of FITS files.  This is especially important
for users who have not previously dealt with the FITS table and image
extensions.

2.  Write a simple program to read or write a FITS file using the Basic
Interface routines described in Chapter 6.  Remember to include the
`fitsio.h' file at the beginning of the program.

3.  Refer to the cookbook.c program that is included with this release
for examples of routines that perform various common FITS file
operations.

4. Read Chapters 4 and 5 to become familiar with the conventions and
advanced features of the CFITSIO interface.

5.  Scan through the more extensive set of routines that are provided
in the `Advanced Interface', as described in Chapter 7.  These routines
perform more specialized functions than are provided by the Basic
Interface routines.


\section{Example Program}

The following listing shows an example of how to use the CFITSIO
routines in a C program.  Refer to the cookbook.c program that
is included with the CFITSIO distribution for examples of other
FITS programs.


\begin{verbatim}
#include "fitsio.h"  /* Every program that uses the CFITSIO interface must */
                     /* include the fitsio.h header file.  This file       */
                     /* contains the prototypes for all the routines and   */
                     /* defines the error status values and other symbolic */
                     /* constants used in the interface.                   */
main()
{
    /* Create a FITS primary array containing a 2-D image */

    fitsfile *fptr;       /* pointer to the FITS file; defined in fitsio.h */
    int status, ii, jj;
    long  fpixel, nelements, array[200][300], exposure;

    /* Initialize FITS image parameters */
    char filename[] = "atestfil.fit";             /* name for new FITS file */
    int bitpix   =  16;   /* 16-bit short signed integer pixel values       */
    long naxis    =   2;  /* 2-dimensional image                            */
    long naxes[2] = { 300, 200 };   /* image is 300 pixels wide by 200 rows */

    status = 0;         /* initialize status before calling fitsio routines */

    if (fits_create_file(&fptr, filename, &status)) /* create new FITS file */
        return( status );

    /* Write the required keywords for the primary array image */
    if ( fits_create_img(fptr,  bitpix, naxis, naxes, &status) )
         return( status );

    /* Initialize the values in the image with a linear ramp function */
    for (jj = 0; jj < naxes[1]; jj++)
        for (ii = 0; ii < naxes[0]; ii++)
            array[jj][ii] = ii + jj;

    fpixel = 1;                               /* first pixel to write      */
    nelements = naxes[0] * naxes[1];          /* number of pixels to write */

    /* Write the array of long integers to the file. These will be      */
    /* converted to short integers in the FITS file (since BITPIX = 16) */
    if ( fits_write_img(fptr, TLONG, fpixel, nelements, array[0], &status) )
        return( status );

    /* Write another optional keyword to the header. */
    /* Note that the ADDRESS of the value is passed in the routine. */
    exposure = 1500.;
    if ( fits_write_key(fptr, TLONG, "EXPOSURE", &exposure,
         "Total Exposure Time", &status) )
         return( status );

    if ( fits_close_file(fptr, &status) )              /* close the file */
         return( status );

    return(0);
}
\end{verbatim}

\chapter{  A FITS Primer }

This section gives a brief overview of the structure of FITS files.
Users should refer to the documentation available from the NOST, as
described in the introduction, for more detailed information on FITS
formats.

FITS was first developed in the late 1970's as a standard data
interchange format between various astronomical observatories.  Since
then FITS has become the defacto standard data format supported by most
astronomical data analysis software packages.

A FITS file consists of one or more Header + Data Units (HDUs), where
the first HDU is called the `Primary HDU', or `Primary Array'.  The
primary array contains an N-dimensional array of pixels, such as a 1-D
spectrum, a 2-D image, or a 3-D data cube.  The primary HDU can also
consist of only a header with a null array containing no pixels.

Any number of additional HDUs may follow the primary array; these
additional HDUs are called FITS `extensions'.  There are currently 3
types of extensions defined by the FITS standard:

\begin{verbatim}
  Image Extension - a N-dimensional array of pixels, like in a primary array

  ASCII Table Extension - rows and columns of data in ASCII character format

  Binary Table Extension - rows and columns of data in binary representation
\end{verbatim}
In each case the HDU consists of an ASCII Header Unit followed by an optional
Data Unit.  For historical reasons, each Header or Data unit must be an
exact multiple of 2880 8-bit bytes long.  Any unused space is padded
with fill characters (ASCII blanks or NULs depending on the type of unit).

Each Header Unit consists of any number of 80-character keyword records
or `card images' (reminiscent of the 80-column punched cards which
were prevalent when the FITS standard was developed) which have the
general form:

\begin{verbatim}
  KEYNAME = value / comment string
\end{verbatim}
The keyword names may be up to 8 characters long and can only contain
uppercase letters, the digits 0-9, the hyphen, and the underscore
character. The keyword name is (usually) followed by an equals sign and
a space character (= ) in columns 9 - 10 of the record, followed by the
value of the keyword which may be either an integer, a floating point
number, a character string (enclosed in single quotes), or a boolian
value (the letter T or F). The last keyword in the header is always the
`END' keyword which has no value or comment fields. There are many
rules governing the exact format of a keyword record (see the NOST FITS
Standard) so it is better to rely on standard interface software like
FITSIO to correctly construct or to parse the keyword records rather
than try to deal directly with the raw FITS formats.

Each Header Unit begins with a series of required keywords which depend
on the type of HDU.  These required keywords specify the size and
format of the following Data Unit.  The header many contain other
optional keywords to describe other aspects of the data, such as the
units or scaling values.  Other COMMENT or HISTORY keywords are also
frequently added to further document the data file.

The optional Data Unit immediately follows the last 2880-byte block in
the Header Unit.  Some HDUs do not have a Data Unit and only consist of
the Header Unit.

If there is more than one HDU in the FITS file, then the Header Unit of
the next HDU immediately follows the last 2880-byte block of the
previous Data Unit (or Header Unit if there is no Data Unit).


\chapter{  Basic CFITSIO Conventions }



\section{CFITSIO definitions}

Any program that uses the CFITSIO interface must include the fitsio.h
header file with the statement

\begin{verbatim}
  #include "fitsio.h"
\end{verbatim}
This file contains the prototypes for
all the CFITSIO user interface routines as well as various symbolic
names or constants used in the interface.  It also defines a C
structure named `fitsfile' that is used by CFITSIO to store the
relevant parameters that define the format of a particular FITS file.
Application programs must define a pointer to this structure for each
FITS file that is to be opened with a declaration
at the beginning of the program similar to:

\begin{verbatim}
  fitsfile *fptr;
\end{verbatim}
This structure is initialized (i.e., memory is allocated
for the structure) when the FITS file is first opened or created
with the fits\_open\_file or fits\_create\_file routines.  This fitsfile
pointer is then passed as the first argument to every other CFITSIO
routine that operates on the FITS file.  The cookbook.c program
that is included with the CFITSIO library contains example programs
illustrating this usage.


\section{Current Header Data Unit (CHDU)}

A basic concept used throughout CFITSIO is that of the current Header
Data Unit (CHDU) within the FITS file. The CFITSIO routines which read
or write information only operate on the CHDU.  When a FITS file is first
created or opened the CHDU is automatically defined to be the first HDU
(i.e., the primary array).  CFITSIO routines are provided to move
to and open any other existing HDU within the FITS file or to append or
insert a new HDU in the FITS file which then becomes the CHDU.


\section{Routine Names}

All the CFITSIO routines have both a short name and a longer
descriptive name.  The short name is only 5 or 6 characters long and is
similar to the subroutine name in the Fortran-77 version of FITSIO.
The longer name is more descriptive and helps to document the source
code, but it naturally makes the source code somewhat greater in
length.  It is purely a matter of personal preference whether to use
the short or the long names since they are identical in terms of
function or efficiency.  The descriptions of the routines given in
chapters 6 and 7 list both the long and short names.


\section{Routine Families and Datatypes}

Many of the CFITSIO routines come in families which differ only in the
datatype of the associated parameter(s).  The datatype of these
routines is indicated by the suffix of the routine name.  The short
routine names have a 1 character suffix (e.g., 'j' in 'ffpkyj')
while the long routine names have a 3 character or longer suffix
as shown in the following table:

\begin{verbatim}
    Long   Short  Data
    Names  Names  Type
    -----  -----  ----
    _bit     x    bit
    _byt     b    unsigned byte
    _sht     i    short integer
    _lng     j    long integer
    _flt     e    real exponential floating point (float)
    _fixflt  f    real fixed-decimal format floating point (float)
    _dbl     d    double precision real floating-point (double)
    _fixdbl  g    double precision fixed-format floating point (double)
    _cmp     c    complex reals (pairs of float values)
    _dblcmp  m    double precision complex (pairs of double values)
    _log     l    logical (int)
    _str     s    character string
\end{verbatim}
When dealing with the FITS byte datatype, it is important to remember that
the raw values (before any scaling by the BSCALE and BZERO, or TSCALn
and TZEROn keyword values) in byte arrays (BITPIX = 8) or byte columns
(TFORMn = 'B') are interpreted as unsigned bytes with values ranging
from 0 to 255.  Some C compilers define a 'char' variable as signed, so
it is important to always explicitly declare a numeric char variable as
'unsigned char'.

The complex and double precision complex datatypes are not directly
supported in ANSI C, so these datatypes should be interpreted as pairs
of float or double values, respectively, where the first  value in each
pair is the real part, and the second is the imaginary part.


\section{1's Based Index Numbers}

The CFITSIO parameters that specify a position in the FITS file, such
as row number, column number or HDU number, generally start with 1 as
the first value, rather than 0.  This is the same convention that is
used in the Fortran version of FITSIO.


\section{Character Strings}

The character string values in a FITS header or in an ASCII column in a
FITS table extension are generally padded out with non-significant
space characters (ASCII 32) to fill up the header record or the column
width.  When reading a FITS string value, the  CFITSIO routines will
strip off these non-significant trailing spaces and will return a
null-terminated string value containing only the significant
characters.  Similarly, when writing string values to a FITS file the
CFITSIO routines expect to get a null-terminated string as input;
CFITSIO will pad the string with blanks if necessary before writing it
to the FITS file.  Note that leading spaces in a FITS string are
considered significant.

When calling CFITSIO routines that return a character string it is
vital that the size of the char array be large enough to hold the
entire string of characters, otherwise CFITSIO will overwrite whatever
memory locations follow the char array, possibly causing the program to
execute incorrectly.  This type of error can be very difficult to
debug, so programmers should always ensure that the char arrays are
allocated enough space to hold the longest possible string, {\bf
including} the terminating NULL character.  The fitsio.h file contains
the following defined constants which programmers are strongly
encouraged to use whenever they are allocating space for char arrays:

\begin{verbatim}
#define FLEN_KEYWORD    9  /* max length of a keyword */
#define FLEN_CARD      81  /* length of a FITS header card */
#define FLEN_VALUE     71  /* max length of a keyword value string */
#define FLEN_COMMENT   73  /* max length of a keyword comment string */
#define FLEN_ERRMSG    81  /* max length of a FITSIO error message */
#define FLEN_STATUS    31  /* max length of a FITSIO status text string */
\end{verbatim}
For example, then declaring a char array to hold the value string
of FITS keyword, use the following statment:

\begin{verbatim}
    char value[FLEN_VALUE];
\end{verbatim}


\section{Implicit Data Type Conversion}

Many of the CFITSIO data I/O routines have the ability to perform
implicit data type conversion.  This means that the data type of the
routine parameter does not need to be the same as the data type of the
value in the FITS file.  More specifically, the implicit data type
conversion will be performed for numerical data types when reading a
FITS header keyword value and when reading or writing values to or from
the primary array or a table column.  CFITSIO returns status =
NUM\_OVERFLOW (412) if the converted data value exceeds the range of
the output data type.  Data type conversion is not allowed when reading
or writing string (s), logical (l), complex (c), or double complex (m)
data types.

One feature of the CFITSIO routines is that they can operate on
a `X' (bit) column in a binary table as though it were a `B' (byte) column.
For example a `15X' datatype column can be interpreted the same
as a `3B' column (i.e., 3 unsigned 8-bit bytes).
In some instances, it can be more efficient to read and write whole
bytes at a time, rather than reading or writing each individual bit
(with the ffgcx, ffpclx and ffgcx routines).


\section{Data Scaling}

When reading numerical data values in the primary array or a
table column, the values will be scaled automatically by the BSCALE and
BZERO (or TSCALn and TZEROn) header values if they are
present in the header.  The scaled data that is returned to the reading
program will have

\begin{verbatim}
        output value = (FITS value) * BSCALE + BZERO
\end{verbatim}
(a corresponding formula using TSCALn and TZEROn is used when reading
from table columns).  In the case of integer output values the floating
point scaled value is truncated to an integer (not rounded to the
nearest integer).  The ffpscl and fftscl routines may be used to
override the scaling parameters defined in the header (e.g., to turn
off the scaling so that the program can read the raw unscaled values
from the FITS file).

When writing numerical data to the primary array or to a table
column the data values will generally be automatically inversely scaled
by the value of the BSCALE and BZERO (or TSCALn and TZEROn)
keyword values if they they exist in the header.  These keywords must
have been written to the header before any data is written for them to
have any immediate effect.  One may also use the ffpscl and fftscl
routines to define or override the scaling keywords in the header
(e.g., to turn off the scaling so that the program can write the raw
unscaled values into the FITS file). If scaling is performed, the
inverse scaled output value that is written into the FITS file will
have

\begin{verbatim}
         FITS value = ((input value) - BZERO) / BSCALE
\end{verbatim}
(a corresponding formula using TSCALn and TZEROn is used when
writing to table columns).  Rounding to the nearest integer, rather
than truncation, is performed when writing integer datatypes to the
FITS file.


\section{Error Status Values and the Error Message Stack}

Nearly all the CFITSIO routines return an error status value
in 2 ways: as the value of the last parameter in the function call,
and as the returned value of the function itself.  This provides
some flexibility in the way programmers can test if an error
occurred, as illustrated in the following 2 code fragments:

\begin{verbatim}
    if ( fits_write_record(fptr, card, &status) )
         printf(" Error occurred while writing keyword.");
\end{verbatim}
or,

\begin{verbatim}
    fits_write_record(fptr, card, &status);
    if ( status )
         printf(" Error occurred while writing keyword.");
\end{verbatim}
A listing of all the CFITSIO status code values and their symbolic
mnemonics is given at the end of this document.  Programmers are
encouraged to use the symbolic  mnemonics (defined in fitsio.h) rather
than the actual integer status values to improve the readability of
their code.

The CFITSIO library uses an `inherited status' convention for the
status parameter which means that if a routine is called with a
positive input value of the status parameter as input, then the routine
will exit immediately without changing the value of the status
parameter.  Thus, if one passes the status value returned from each
CFITSIO routine as input to the next CFITSIO routine, then whenever an
error is detected all further CFITSIO processing will cease.  This
convention can simplify the error checking in application programs
because it is not necessary to check the value of the status parameter
after every single CFITSIO routine call.  If a program contains a
sequence of several CFITSIO calls, one can just check the status value
after the last call.  Since the returned status values are generally
distinctive, it should be possible to determine which routine
originally returned the error status.

CFITSIO also maintains an internal stack of error messages
(80-character maximum length)  which in many cases provide a more
detailed explanation of the cause of the error than is provided by the
error status number alone.  It it recommended that the error message
stack be printed out whenever a program detects a CFITSIO error.  To do
this, call the ffgmsg routine repeatedly to get the successive messages
on the stack.  When the stack is empty ffgmsg will return a null value
(and a null string).  Note that this is a 'First In -- First Out'
stack, so the oldest error message is returned first by ffgmsg.

In some situations programs may encounter a non-fatal CFITSIO error and
will want to continue processing.  An example is when a program fails
to find an optional keyword in the header and CFITSIO returns status =
KEY\_NO\_EXIST (202).  The program may ignore this error and reset
status = 0, however this may still leave error messages on the stack.
To clear the entire message stack in this situation, call the ffcmsg
routine.


\section{Variable-Length Arrays in Binary Tables}

CFITSIO provides easy-to-use support for reading and writing data in
variable length fields of a binary table.  The variable length columns
have TFORMn keyword values of the form `1Pt' where `t' is the datatype
code (e.g., I, J, E, D, etc.).

The way this feature is implemented in FITS files is by writing all the
variable length data into an area called the `heap' which follows the
main fixed-length FITS binary table.  The size of the heap, in bytes,
is specified by the PCOUNT keyword in the FITS header.  When creating a
new binary table, the initial value of PCOUNT should usually be set to
zero.  CFITSIO will recompute the size of the heap as the data is
written and will automatically update the PCOUNT keyword value when the
table is closed. Thus, application programs usually do not need to
worry about the heap size, except when inserting a new binary table HDU
in front of other existing HDUs in the FITS file (with ffibin).  In
this specific case the correct final value of PCOUNT must be specified
when the HDU is initially created so that the correct amount of space
will be inserted into the FITS file.

By default the heap data area starts immediately after the last row of
the fixed-length table.  This default starting location may be
overridden by the THEAP keyword, but this is not recommended.  Thus
when writing variable length arrays the number of rows in the table
should be correctly specified (with the NAXIS2 keyword) at the time the
table is first created.  This differs from the simpler case of tables
that only contain fixed-length columns where the number of rows in the
table does not have to be explicitly defined until just before the
table is closed.  It is still possible to insert additional rows into a
binary table containing variable-length columns (with the ffirow
routine), however, the performance may be rather slow due to all the
internal shuffling of the data that must be performed.

The same routines which read and write data in an ordinary fixed length
binary table extension are also used for variable length fields,
however, the routine parameters take on a slightly different
interpretation as described below:

When writing to a variable length field the entire array of values for
a given row of the table must be written with a single call to
ffpcl\_.  The total length of the array is given by nelements +
firstelem - 1.  Additional elements cannot be appended to an existing
vector at a later time since any attempt to do so will simply overwrite
all the previously written data.  Note also that the new data will be
written to a new area of the heap and the heap space used by the
previous write cannot be reclaimed.  For this reason each row of a
variable length field should only be written once.  An exception to
this general rule occurs when setting elements of an array as
undefined.  One must first write a dummy value into the array with
ffpcl\_, and then call ffpclu to flag the desired elements as
undefined.  (Do not use the ffpcn\_ family of routines with variable
length fields). Note that The rows of a table may be written in any
order.

When writing to a variable length ASCII character field (e.g., TFORM =
'PA') only a single character string can be written written.  The
`firstelem' and `nelements' parameter values in the ffpcls routine are
ignored and the number of characters to write is simply determined by
the length of the input null-terminated character string.

The ffpdes routine is useful in situations where multiple rows of a
variable length column have the identical array of values.  One can
simply write the array once for the first row, and then use ffpdes to
write the same descriptor values into the other rows;  all the rows
will then point to the same storage location thus saving disk space.

When reading from a variable length array field one can only read as
many elements as actually exist in that row of the table; reading does
not automatically continue with the next row of the table as occurs
when reading an ordinary fixed length table field.  Attempts to read
more than this will cause an error status to be returned.  One can
determine the number of elements in each row of a variable column with
the ffgdes routine.


\section{Support for IEEE Special Values}

The ANSI/IEEE-754 floating-point number standard defines certain
special values that are used to represent such quantities as
Not-a-Number (NaN), denormalized, underflow, overflow, and infinity.
(See the Appendix in the NOST FITS standard or the NOST FITS User's
Guide for a list of these values).  The CFITSIO routines that read
floating point data in FITS files recognize these IEEE special values
and by default interpret the overflow and infinity values as being
equivalent to a NaN, and convert the underflow and denormalized values
into zeros.  In some cases programmers may want access to the raw IEEE
values, without any modification by CFITSIO.  This can be done by
calling the ffgpv\_ or ffgcv\_ routines while specifying 0.0 as the
value of the NULLVAL parameter.  This will force CFITSIO to simply pass
the IEEE values through to the application program without any
modification.  This is not fully supported on VAX/VMS machines,
however, where there is no easy way to bypass the default
interpretation of the IEEE special values.


\section{Local FITS Conventions supported by CFITSIO}

In a couple cases CFITSIO supports local FITS conventions which are not
defined in the official NOST FITS standard and which are not
necessarily recognized or supported by other FITS software packages.
Programmers should be cautious about using these features, especially
if the FITS files that are produced are expected to be processed by
other software systems which do not use the CFITSIO interface.  These
local conventions should be considered as prototypes, and they may not
necessarily be supported in future versions of CFITSIO, especially if
an alternative convention is officially adopted by the FITS community.


\subsection{Support for Long String Keyword Values.}

The length of a standard FITS string keyword is limited to 68
characters because it must fit entirely within a single FITS header
keyword record.  In some instances it is necessary to encode strings
longer than this limit, so CFITSIO supports a local convention in which
the string value is continued over multiple keywords.  This
continuation convention uses a ampersand character at the end of each
substring to indicate that it is continued on the next keyword, and the
continuation keywords all have the name CONTINUE without an equal sign
in column 9. The string value may be continued in this way over as many
additional CONTINUE keywords as is required.  The following lines
illustrate this continuation convention which is used in the value of
the STRKEY keyword:

\begin{verbatim}
LONGSTRN= 'OGIP 1.0'    / The OGIP Long String Convention may be used.
STRKEY  = 'This is a very long string keyword&'  / Optional Comment
CONTINUE  ' value that is continued over 3 keywords in the &  '
CONTINUE  'FITS header.' / This is another optional comment.
\end{verbatim}
It is recommended that the LONGSTRN keyword, as shown here, always be
included in any HDU that uses this longstring convention as a warning
to any software that must read the keywords.  A routine called ffplsw
has been provided in CFITSIO to write this keyword if it does not
already exist.

  This long string convention is supported by the following CFITSIO
routines:

\begin{verbatim}
      ffpkls - write an arbitrarily long string keyword value
      ffgkls - read  an arbitrarily long string keyword value
      ffdkey - delete a keyword
\end{verbatim}
The ffgkls routine is unique among all the CFITSIO routines in that it
internally allocates memory for the long string value;  all the other
CFITSIO routines that deal with strings require that the calling
program pre-allocate adequate space to hold the array of characters.
Consequently, programs which use the ffgkls routine must be careful to
free the allocated memory for the string when it is no longer needed.

The following 2 routines also have limited support for this
long string convention,

\begin{verbatim}
      ffmkys - modify an existing string keyword value
      ffukys - update a string keyword value
\end{verbatim}
in that they will correctly overwrite an existing long string value,
but the new string value is limited to a maximum of 68 characters in
length.

The more commonly used CFITSIO routine to write string valued
keywords (ffpkys) does NOT support this long string convention and only
supports strings up to 68 characters in length.  This has been done
deliberately to prevent programs from inadvertently writing keywords
using this non-standard convention without the explicit intent of the
programmer or user.   The ffpkls routine must be called instead to
write long strings.  This routine can also be used to write ordinary
string values less than 68 characters in length.


\subsection{Arrays of Strings in Binary Table Extensions}

The definition of the FITS binary table extension format does not
provide a simple way to specify that a character column contains an
array of fixed-length strings.  To support this feature, CFITSIO uses a
local convention for the format of the TFORMn keyword value of the form
'rAw' where 'r' is an integer specifying the total width in characters
of the column, and 'w' is an integer specifying the (fixed) length of
an individual unit string within the vector.  For example, TFORM1 =
'120A10' would indicate that the binary table column is 120 characters
wide and consists of 12 10-character length strings.  This convention
is recognized by the CFITSIO routines that read or write strings in
binary tables.   The Binary Table definition document specifies that
other optional characters may follow the datatype code in the TFORM
keyword, so this local convention is in compliance with the
FITS standard although other FITS readers may not
recognize this convention.

The Binary Table definition document that was approved by the IAU in
1994 contains an appendix describing an alternate convention for
specifying arrays of fixed or variable length strings in a binary table
character column (with the form 'rA:SSTRw/nnn)'.  This appendix was not
officially voted on by the IAU and hence is still provisional.  CFITSIO
does not currently support this proposal.


\chapter{ Programming Guidelines }

The CFITSIO Cookbook (available in the file cookbook.c in the CFITSIO
software distribution directory) contains listings of various
routines that read and write CFITSIO files.  New users of CFITSIO should
study these examples to help learn how to most efficiently use the
CFITSIO library.   The following sections briefly summarize the
main steps in reading or writing a FITS file.


\section{Reading an existing FITS file}

The following sequence of routine calls illustrate a simple example
of reading an existing FITS file.

\begin{verbatim}
 1. Open the file with fits_open_file / ffopen.
 2. Read any desired header keywords with fits_read_key / ffgky.
 3. Read the primary data, if any, with fits_read_img / ffgpv.
 4. Repeat steps 2 and 3 until all the desired information has been read.
 5. Move to another extension with fits_movabs_hdu / ffmahd.
 6. Read any extension header keywords with fits_read_key / ffgky.
 7. Read any table column of data with fits_read_col / ffgcv.
 8. Repeat steps 6 and 7 until all the information has been read.
 9. Repeat steps 5 through 8 for any other extensions.
10. Close the file with fits_close_file / ffclos.
\end{verbatim}


\section{Creating a new FITS file}

The following sequence of routine calls illustrate a simple example
of writing a new FITS file:

\begin{verbatim}
 1. Create the new file with fits_create_file / ffinit.
 2. Write the required primary keywords with fits_create_img / ffcrim.
 3. Write any additional keywords with fits_write_key / ffpky.
 4. Write the primary array data, if any, with fits_write_img / ffppr.
 5. Create another extension, if desired, with fits_create_img / ffcrim
    or fits_create_tbl / ffcrtb.
 6. Write any additional keywords with fits_write_key / ffpky.
 7. Write data to table columns with fits_write_col /ffpcl.
 8. Repeat steps 5 - 7 for any more extensions.
 9. Close the fits file with fits_close_file / ffclos.
\end{verbatim}
Note that the application program must not explicitly write the
required 'END' keyword at the end of each header;  the CFITSIO interface
will automatically append the END record whenever the header is closed.
As a standard practice, users should always read back any FITS files
that they have created to ensure that the header values and data structure
are correct and self-consistent.


\section{When the Final Size of the FITS File is Unknown}

It is not required to know the total size of a FITS data array or table
before beginning to write the data to the FITS file.  In the case of
the primary array or an image extension, one should initially create
the array with the size of the highest dimension (largest NAXISn
keyword) set to a dummy value, such as 1.  Then after all the data have
been written and the true dimensions are known, then the NAXISn value
should be updated using the ffmkyj routine before moving to another
extension or closing the FITS file.

A similar procedure may be used in the case of FITS tables, where the
number of rows in the table (the NAXIS2 value) may initially be set to
1 and then updated with the correct value before closing the table.
Alternatively, one may use the ffirow routine to insert additional rows
into a table if the original value turns out to be too small.  This
latter method must be used if any of the columns contain variable
length arrays.


\section{Optimizing Code for Maximum Processing Speed}

Care must be taken when designing software to achieve the best possible
performance when processing the FITS data files.  The following
paragraphs describe some strategies that may be used to improve the
processing speed of software that uses CFITSIO.

1.  All operating systems buffer the magnetic disk read and write
operations by using an array in memory (a cache) as an intermediate
storage area for blocks of data on disk.  When reading or writing FITS
files, it is generally better to use a large buffer to minimize the
number of physical disk I/O operations.  For critical operations, the
system administrator should tune the size of the disk buffer as well as
other system parameters that may affect disk I/O speed, to achieve
optimal performance.  Note that other factors, such as the average seek
time of the disk, the amount of file fragmentation on the disk, and the
location of the disk on the computer network, can also make a large
difference in overall disk I/O performance.

2.  The most important efficiency factor in software design is to read
or write the data in the FITS file in a single pass through the file.
As an example, if one reads a large, 3-column table by sequentially
reading the entire first column, then going back to read the 2nd
column, and finally the 3rd column, this obviously requires 3 passes
through the file.  Since many FITS programs are I/O limited, this could
effectively triple the execution time of the program as compared to a
program that reads a limited range of rows from all the columns in
parallel before advancing on to the next set of rows.  The optimum
number of rows to process at one time is not too critical, but it
should be large enough to avoid an excessive number of individual
routine calls (it is generally inefficient to read or write each row of
a table one at a time) but still small enough so that the relevant
section of the FITS file will all fit in the system memory cache.   As
long as the section of the FITS file that is to be read or written is
still contained in the cache, then the program will run more
efficiently.  If designed properly, software should be able to read or
write a FITS file by sequentially accessing successive blocks in the
file in a single pass without having to go back to read or write a
block that has already been flushed out of the memory cache.

3. Design software so that it reads the FITS header keywords in the
same order in which they occur in the file.  When reading keywords,
CFITSIO searches forward starting from the position of the last keyword
that was read.  If it reaches the end of the header without finding the
keyword, it then goes back to the start of the header and continues the
search down to the position where it started.

4. Avoid the use of scaling (by using the BSCALE and BZERO or TSCAL and
TZERO keywords) in FITS files since the scaling operations add to the
processing time needed to read or write the data.  In some cases it may
be more efficient to temporarily turn off the scaling (using ffpscl or
fftscl) and then read or write the raw unscaled values in the FITS
file.

5. Use FITS binary tables (BINTABLE) rather than FITS ASCII tables
(TABLE) whenever possible. Binary tables are more compact and can be
read or written much more efficiently, whereas each field of an ASCII
table must be individually formatted or parsed.

6. Design FITS binary tables so that every column is aligned on a
computer word boundary and so that each row is a multiple number of
computer words in length.  Accessing non-aligned words can be much
slower on some machines.  In practice, this means that double precision
columns should start at a multiple of 8 bytes within the row, single
precision floating point columns and integer columns should start at a
multiple of 4 bytes, and short integer columns should start at a
multiple of 2 bytes.  If necessary, the row length should be padded out
by adding a dummy column of the appropriate width or by adjusting the
width of an existing column so that the row length is also a multiple
number of words in length.  For example, if a binary table contains a
'1B', a '1E', and a '1D' column, then the optimum design would place
the '1D' column first in the table followed by the '1E' and then the
'1B' column.  Since the row length is then 8 + 4 + 1 = 13 bytes, one
should add another dummy column, with a 3A datatype to make the length
a multiple of the double precision word length.  Alternatively, one
could change the last column from '1B' to '4B'. This will insure that
all the data values are optimally aligned.

7. Where possible, design FITS binary tables so that the columns of
data are written as a contiguous set of bytes, rather than as single
elements in multiple rows.  For example, it is much faster to access
the data in a table that contains a single row and 2 columns with TFORM
keywords equal to  '1000E' and '1000J', than it is to access the same
amount of data in a table with 1000 rows which has columns with the
TFORM keywords equal to '1E' and '1J'.  In the former case the 1000
floating point values in the first column are all written in a
contiguous block of the file which can be read or written quickly,
whereas in the second case each floating point value in the first
column is interleaved with the integer value in the second column of
the same row so CFITSIO has to explicitly move to the position of each
element to be read or written.

8. Avoid the use of variable length vector columns in binary tables,
since any reading or writing of these data requires that CFITSIO first
look up or compute the starting address of each row of data in the
heap.

9. When copying data from one FITS table to another, it is faster to
transfer the raw bytes instead of reading then writing each column of
the table.  The CFITSIO routines ffgtbb and ffptbb will perform
low-level reads or writes of any contiguous range of bytes in a table
extension.  These routines can be used to read or write a whole row (or
multiple rows) of a table with a single routine call.   These routines
are fast because they bypass all the usual data scaling, error checking
and machine dependent data conversion that is normally done by CFITSIO,
and they allow the program to write the data to the output file in
exactly the same byte order.  For these same reasons, use of these
routines can be somewhat risky because no validation or machine
dependent conversion is performed by these routines.  In general these
routines are only recommended for optimizing critical pieces of code
and should only be used by programmers who thoroughly understand the
internal format of the FITS tables they are reading or writing.


\section{CFITSIO Size Limitations}

In general, CFITSIO places no limits on the sizes of the FITS files that
it read or writes. In particular there is no internal limit on the size of the
dimensions of the primary array or IMAGE extension. Tables extensions may have
up to the maximum of 999 columns (as allowed by the FITS standard) and
may have an arbitrarily large number of rows. There are a few other limits,
however, which may affect some extreme cases:

1.  The maximum number of files that may be simultaneously opened may
be limited by the underlying C compiler or machine operating system.
The C symbolic constant FOPEN\_MAX usually defines the total number of
files that may open at once (this includes any other text or binary
files which may be open, not just FITS files).

2.  The maximum number of extensions that can be read or written in a
single FITS file is current set to 1000 as defined by MAXHDU in the
fitsio.h file.  This value may be increased if necessary, but the
access times to the later extensions in such files may become very
long.

3.  CFITSIO can handle FITS files up to about 2.1 GB in size which is
the maximum value of a signed long integer.  Some machines that use
8-byte words for a long integer may support larger files, but this has
not been tested.


\chapter{ Basic Interface Routines }

This section defines a basic set of routines that can be
used to perform the most common types of read and write operations
on FITS files.  New users should start with these routines and
then, as needed, explore the more advance routines described in
the following chapter to perform more complex or specialized operations.

Each routine has 2 names: a long descriptive
name and a short concise name.  Both names are listed on the first
line of the following descriptions, separated by a slash (/) character.
It makes no difference which name is used in the source code.

A right arrow symbol ($>$) is used to separate the input parameters from
the output parameters in the  definition of each routine.  This symbol
is not actually part of the C calling sequence.  Note that
the status parameter is both an input and an output parameter
and must be initialized = 0 prior to calling the CFITSIO routines.

Refer to Chapter 9 for the definition of all the parameters
used by these interface routines.


\section{File I/O Routines}

CFITSIO uses a C structure (as defined in fitsio.h) to store all the
relevant parameters about the format of an opened FITS file.
Application programs must first declare a pointer to this structure
(which is named 'fitsfile') for each FITS file that is opened.  The
value of the pointer is defined by the call to open or create the FITS
file and then the pointer must be passed as the first argument to all
the other CFITSIO routines that read or write the FITS file.  The
memory that is allocated for the fitsfile structure is freed when
the FITS file is closed.


\begin{description}
\item[1 ] Open an existing FITS file with readonly or readwrite access.
    The iomode parameter has allowed symbolic constant values of
   READONLY or READWRITE.
\end{description}

\begin{verbatim}
  int fits_open_file / ffopen
      (fitsfile **fptr, char *filename, int iomode, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Open and initialize a new empty FITS file
\end{description}

\begin{verbatim}
  int fits_create_file / ffinit
      (fitsfile **fptr, char *filename, > int *status)
\end{verbatim}

\begin{description}
\item[3 ]Close a previously opened FITS file.
\end{description}

\begin{verbatim}
  int fits_close_file / ffclos
      (fitsfile *fptr, > int *status)
\end{verbatim}

\begin{description}
\item[4 ] Move to a specified (absolute) HDU in the FITS file.  When a FITS file
    is first opened or created it is automatically positioned to the first
   HDU (the primary array) in the file which has hdunum = 1.
\end{description}

\begin{verbatim}
  int fits_movabs_hdu / ffmahd
      (fitsfile *fptr, int hdunum, > int *hdutype, int *status)
\end{verbatim}

\begin{description}
\item[5 ]Create a new primary array if a new empty FITS file has just been
  created, otherwise append a new IMAGE extension following the current HDU.
\end{description}

\begin{verbatim}
  int fits_create_img / ffcrim
      ( fitsfile *fptr, int bitpix, int naxis, long *naxes, > int *status)
\end{verbatim}

\begin{description}
\item[6 ]Create (append) a new table extension following the current HDU.
   The type of table is specified by the tbltype parameter which can have
  symbolic constant values of ASCII\_TBL or BINARY\_TBL.
\end{description}

\begin{verbatim}
  int fits_create_tbl / ffcrtb
      (fitsfile *fptr, int tbltype, long naxis2, int tfields, char **ttype,
       char **tform, char **tunit, char *extname, int *status)
\end{verbatim}


\section{Keyword I/O Routines}


\begin{description}
\item[1 ]Write an 80-character keyword record into the current header.  The
   record will be padded with blanks if the input null-terminated
  card string is less than 80 characters long.
\end{description}

\begin{verbatim}
  int fits_write_record / ffprec
      (fitsfile *fptr, char *card, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Write a new keyword with the specified datatype into the current header.
    The datatype parameter can have one of the following symbolic constant
    values: TSTRING, TLOGICAL, TBYTE, TSHORT, TINT, TLONG, TFLOAT, TDOUBLE.
    Note that the address of the value, not the value itself, must be supplied
   to this routine.
\end{description}

\begin{verbatim}
  int fits_write_key / ffpky
      (fitsfile *fptr, int datatype, char *keyname, void *value,
       char *comment, > int *status)
\end{verbatim}

\begin{description}
\item[3 ] Read the nth 80-character header record from the current header.
   Note that the first keyword in the header is at keynum = 1, not 0.
\end{description}

\begin{verbatim}
  int fits_read_record / ffgrec
      (fitsfile *fptr, int keynum, > char *card, int *status)
\end{verbatim}

\begin{description}
\item[4 ] Read a keyword value and comment from the current header.
    Automatic datatype conversion will be attempted if
   `datatype' is not the same as the actual datatype of the keyword.
\end{description}

\begin{verbatim}
  int fits_read_key / ffgky
      (fitsfile *fptr, int datatype, char *keyname, > void *value,
       char *comment, int *status)
\end{verbatim}

\begin{description}
\item[5 ] Delete a specified keyword record.
\end{description}

\begin{verbatim}
  int fits_delete_key / ffdkey
      (fitsfile *fptr, char *keyname, > int *status)
\end{verbatim}


\section{Data I/O Routines}

The following routines read or write data values in the current HDU of
the FITS file. The `datatype' parameter specifies the datatype of the
array of values and can have one of the following symbolic constant
values: TBYTE, TSHORT, TINT, TLONG, TFLOAT, or TDOUBLE.  The routines
for reading or writing table columns also support the TSTRING datatype
when dealing with ASCII string columns. Automatic datatype conversion
will be attempted for numerical datatypes if the specified datatype is
different from the actual datatype of the FITS array or table column.


\begin{description}
\item[1 ] Write elements into the primary array or image extension.
\end{description}

\begin{verbatim}
  int fits_write_img / ffppr
      (fitsfile *fptr, int datatype, long firstelem, long nelements,
       void *array, int *status);
\end{verbatim}

\begin{description}
\item[2 ] Read elements from the primary array or image extension.
    Undefined array elements will be returned with a value = *nulval
    unless nulval = 0 or *nulval = 0, in which case no checks
    for undefined pixels will be performed. The anynul parameter is
    set to true (= 1) if any of the returned
    elements were undefined. Note that the {\em address} to the
   null value, not the null value itself must be supplied to this routine.
\end{description}

\begin{verbatim}
  int fits_read_img / ffgpv
      (fitsfile *fptr, int  datatype, long firstelem, long nelements,
       void *nulval, > void *array, int *anynul, int *status)
\end{verbatim}

\begin{description}
\item[3 ] Write elements into an ASCII or binary table column.  The `firstelem'
    parameter applies only to vector columns in binary tables and is
   ignored when writing to ASCII tables.
\end{description}

\begin{verbatim}
  int fits_write_col / ffpcl
      (fitsfile *fptr, int datatype, int colnum, long firstrow,
       long firstelem, long nelements, char **array, > int *status)
\end{verbatim}

\begin{description}
\item[4 ] Read elements from an ASCII or binary table column.  Undefined
    array elements will be returned with a value = *nulval unless nulval = 0
    or *nulval = 0, in which case no checking for undefined values will be
    performed. The anynul parameter is set to true (= 1) if any of the returned
    elements were undefined.  Note that the {\em address} to the
   null value, not the null value itself must be supplied to this routine.
\end{description}

\begin{verbatim}
  int fits_read_col / ffgcv
      (fitsfile *fptr, int datatype, int colnum, long firstrow, long firstelem,
       long nelements, void *nulval, void *array, int *anynul, int *status)
\end{verbatim}

\begin{description}
\item[5 ] Get the table column number and full name of the column whose name
    matches the input template string.  See the `Advanced Interface Routines'
   chapter for a full description of this routine.
\end{description}

\begin{verbatim}
  int fits_get_colname / ffgcnn
      (fitsfile *fptr, int casesen, char *templt, > char *colname,
       int *colnum, int *status)
\end{verbatim}

\chapter{   Advanced Interface Routines }

This chapter defines all the available routines in the CFITSIO user
interface.  For completeness, the basic routines
described in the previous chapter are also repeated here.
Refer to Chapter 9 for the definition of all the parameters.

The following conventions are used in this chapter:

1. Each routine has 2 names: a long descriptive
name and a short concise name.  Both names are listed on the first
line of the following descriptions, separated by a slash (/) character.

2. A right arrow symbol ($>$) is used to separate the input parameters from
the output parameters in the  definition of each routine.  This symbol
is not actually part of the C calling sequence.  Note that
the status parameter is both an input and an output parameter.

3. Families of similar routines which differ only in the datatype
of the argument(s) are defined together using a convention
of listing the last letter(s) of the routine names in square brackets.
For example, the routines for reading data from a primary array
are defined as:

\begin{verbatim}
  int ffgpv[bijed](fitsfile *fptr, long group, long firstelem, long nelements,
           DTYPE nulval, > DTYPE *array, int *anynul, int *status)
\end{verbatim}
This is a short-hand notation for indicating that there are 5
separate routines, ffgpvb, ffgpvi, ffgpvj, ffgpve, and ffgpvd,
which have different datatypes for the nulval and array arguments.

4. A datatype specification of `DTYPE' is used to indicate
that the parameter has a numerical datatype which depends on the last
letter of the routine's short name as given by the following table:

\begin{verbatim}
      Name     Data
      suffix   type
      ----     --------
        b   -  unsigned char
        l   -  int (logical value)
        i   -  short int
        j   -  long int
     e, f   -  float
     d, g   -  double
        c   -  pairs of floats (complex value)
        m   -  pairs of doubles (complex value)
\end{verbatim}
Thus, in the previous example the `nulval' and `array'  parameters have
a short int datatype in the ffgpvi routine and have a
double datatype in the ffgpvd routine.


\section{FITS File Open and Close Routines \label{FFOPEN}}

CFITSIO uses a C structure (as defined in fitsio.h) to store all the
relevant parameters about the format of an opened FITS file.
Application programs must first declare a pointer to this structure
(which is named 'fitsfile') for each FITS file that is opened.  The
value of the pointer is defined by the call to open or create the FITS
file and then the pointer must be passed as the first argument to all
the other CFITSIO routines that read or write the FITS file.  The
memory that is allocated for the fitsfile structure is freed when
the FITS file is closed.


\begin{description}
\item[1 ] Open an existing FITS file with readonly or readwrite access.
    The iomode parameter has allowed symbolic constant values of
   READONLY or READWRITE.
\end{description}

\begin{verbatim}
  int fits_open_file / ffopen
      (fitsfile **fptr, char *filename, int iomode, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Open and initialize a new empty FITS file
\end{description}

\begin{verbatim}
  int fits_create_file / ffinit
      (fitsfile **fptr, char *filename, > int *status)
\end{verbatim}

\begin{description}
\item[3 ]Flush any internal buffers of data to the output FITS file. This
   routine usually never needs to be called, but doing so will ensure
   that if the program subsequently aborts then the FITS file will
  have been closed properly.
\end{description}

\begin{verbatim}
  int fits_flush_file / ffflus
      (fitsfile *fptr, > int *status)
\end{verbatim}

\begin{description}
\item[4 ]Close a previously opened FITS file.
\end{description}

\begin{verbatim}
  int fits_close_file / ffclos
      (fitsfile *fptr, > int *status)
\end{verbatim}

\begin{description}
\item[5 ] Close and DELETE a FITS file previously opened with ffopen or ffinit.
    This routine may be  useful in cases where a FITS file is created but
   then an error occurs which prevents the file from being completed.
\end{description}

\begin{verbatim}
  int fits_delete_file / ffdelt
      (fitsfile *fptr, > int *status)
\end{verbatim}


\section{HDU-Level Operations\label{FFMAHD}}

The following routines perform operations on entire HDUs: move, create,
insert, copy, and delete HDUs.


\begin{description}
\item[1 ] Move to a specified (absolute) HDU in the FITS file.  When a FITS file
    is first opened or created it is automatically positioned to the first
   HDU (the primary array) in the file which has hdunum = 1.
\end{description}

\begin{verbatim}
  int fits_movabs_hdu / ffmahd
      (fitsfile *fptr, int hdunum, > int *hdutype, int *status)
\end{verbatim}

\begin{description}
\item[2 ]Move a relative number of HDUs forward or backwards in the FITS file.
\end{description}

\begin{verbatim}
  int fits_movrel_hdu / ffmrhd
      (fitsfile *fptr, int nmove, > int *hdutype, int *status)
\end{verbatim}

\begin{description}
\item[3 ] Get the number of the current HDU in the FITS file (primary array = 1).
   This routine returns the HDU number rather than a status value.
\end{description}

\begin{verbatim}
  int fits_get_hdunum / ffghdn
      (fitsfile *fptr, > int *hdunum)
\end{verbatim}

\begin{description}
\item[4 ]Create a new primary array if a new empty FITS file has just been
   created otherwise append a new IMAGE extension following the current HDU.
  This routine simply combines calls to ffcrhd and ffphps.
\end{description}

\begin{verbatim}
  int fits_create_img / ffcrim
      ( fitsfile *fptr, int bitpix, int naxis, long *naxes, > int *status)
\end{verbatim}

\begin{description}
\item[5 ]Create (append) a new table extension following the current HDU.
   This routine simply combines calls to ffcrhd and ffphtb or ffphbn.
   The type of table is specified by the tbltype parameter which can have
  symbolic constant values of ASCII\_TBL or BINARY\_TBL.
\end{description}

\begin{verbatim}
  int fits_create_tbl / ffcrtb
      (fitsfile *fptr, int tbltype, long naxis2, int tfields, char **ttype,
       char **tform, char **tunit, char *extname, int *status)
\end{verbatim}

\begin{description}
\item[6 ]Create (append) a new empty HDU following the last extension that
    has been previously accessed by the program.   This will overwrite
    any later extensions that may exist in the FITS file but which
    have not been accessed.
    For example, if an existing FITS file contains a primary array plus 5
    extensions and a program (1) opens the FITS file, (2) moves to
    extension 4, (3) moves back to the primary array, and (4) then calls
    ffcrhd, then the new extension will be written following the 4th
   extension, overwriting the existing 5th extension.
\end{description}

\begin{verbatim}
  int fits_create_hdu / ffcrhd
      (fitsfile *fptr, > int *status)
\end{verbatim}

\begin{description}
\item[7 ] Insert a new IMAGE extension immediately following the CHDU.
    Any following extensions will be shifted down to make room for
    the new extension.  If there are no other following extensions
    then the new image extension will simply be appended to the
   end of the file.  The new extension will become the CHDU.
\end{description}

\begin{verbatim}
  int fits_insert_img / ffiimg
      (fitsfile *fptr, int bitpix, int naxis, long *naxes, > int *status)
\end{verbatim}

\begin{description}
\item[8 ] Insert a new ASCII TABLE extension immediately following the CHDU.
    Any following extensions will be shifted down to make room for
    the new extension.  If there are no other following extensions
    then the new table extension will simply be appended to the
   end of the file.  The new extension will become the CHDU.
\end{description}

\begin{verbatim}
  int fits_insert_atbl / ffitab
      (fitsfile *fptr, long rowlen, long nrows, int tfields, char **ttype,
       long *tbcol, char **tform, char **tunit, char *extname, > int *status)
\end{verbatim}

\begin{description}
\item[9 ] Insert a new binary table extension immediately following the CHDU.
    Any following extensions will be shifted down to make room for
    the new extension.  If there are no other following extensions
    then the new bintable extension will simply be appended to the
    end of the file.  If there are following extensions and if
    the table contains variable length array columns
    then pcount must specify the expected final size of the data heap,
    otherwise pcount must = 0.  The new extension will become the CHDU.
\end{description}

\begin{verbatim}
  int fits_insert_btbl / ffibin
      (fitsfile *fptr, long nrows, int tfields, char **ttype,
      char **tform, char **tunit, char *extname, long pcount, > int *status)
\end{verbatim}

\begin{description}
\item[10] Delete the CHDU in the FITS file.  Any following HDUs will be shifted
    forward in the file, to fill in the gap created by the deleted HDU.
    This routine will only delete extensions; the primary array (the first
    HDU in the file) cannot be deleted.  The physical size of the FITS file
    will not change and the end of the file will be padded out with
    zeros to fill in the space left after the CHDU is deleted. If
    there are more extensions in the file following the one that is deleted,
    then the the CHDU will be defined to point to the following extension.
    If there are no following extensions then the CHDU will be redefined
    to point to the previous HDU.  The output HDUTYPE parameter
    indicates the type of the new CHDU after the previous CHDU has been
   deleted.
\end{description}

\begin{verbatim}
  int fits_delete_hdu / ffdhdu
      (fitsfile *fptr, > int *hdutype, int *status)
\end{verbatim}

\begin{description}
\item[11] Copy the entire CHDU from the FITS file associated with infptr to the CHDU
    of the FITS file associated with outfptr. This will overwrite any data
    previously in the outfptr CHDU.  Space will be reserved for MOREKEYS
    additional  keywords in the output header if there is not already enough
   space.
\end{description}

\begin{verbatim}
  int fits_copy_hdu / ffcopy
      (fitsfile *infptr, fitsfile *outfptr, int morekeys, > int *status)
\end{verbatim}

\begin{description}
\item[12] Copy the data (and not the header) from the CHDU associated with infptr
    to the CHDU associated with outfptr. This will overwrite
    any data previously in the output CHDU.  This low level routine is used
    by ffcopy, but it may also be useful in certain application programs
    which want to copy the data from one FITS file to another but also
    want to modify the header keywords. The required FITS header keywords
    which define the structure of the HDU must be written to the
   output CHDU before calling this routine.
\end{description}

\begin{verbatim}
  int fits_copy_data / ffcpdt
      (fitsfile *infptr, fitsfile *outfptr, > int *status)
\end{verbatim}

\begin{description}
\item[13] This routine forces CFITSIO to scan the current header keywords that
    define the structure of the HDU (such as the NAXISn, PCOUNT and GCOUNT
    keywords) so that it can initialize the internal buffers that describe
    the HDU structure.  This routine is
    useful for reinitializing the structure of an HDU, e.g.,
    if the number of rows in a table, as specified by the NAXIS2 keyword,
    has been modified from its initial value.  In practice it should
    rarely be necessary to call this routine because CFITSIO
   internally calls it in most situations.
\end{description}

\begin{verbatim}
  int fits_set_hdustruc / ffrdef
      (fitsfile *fptr, > int *status)   (DEPRECATED)
\end{verbatim}


\section{FITS Header I/O Routines}


\subsection{ Header Space and Position Routines \label{FFHDEF}}


\begin{description}
\item[1 ] Reserve space in the CHU for MOREKEYS more header keywords.
    This routine may be called to reserve space for keywords which are
    to be written at a later time, after the data unit or subsequent
    extensions have been written to the FITS file.  If this routine is
    not explicitly called then the initial size of the FITS header will be
    limited to the space available at the time that  the first data is written
    to the associated data unit.   CFITSIO will dynamically
    add more space to the header if needed, however it is more efficient
   to preallocate the required space if the size is known in advance.
\end{description}

\begin{verbatim}
  int fits_set_hdrsize / ffhdef
      (fitsfile *fptr, int morekeys, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Return the number of existing keywords in the CHU (NOT counting the
    END keyword which is not considered a real keyword) and the remaining
    space available to write additional keywords in the CHU (returns
    morekeys = -1 if the header has not yet been closed).
    Note that CFITSIO will attempt to dynamically add space for more
   keywords if required when appending new keywords to a header.
\end{description}

\begin{verbatim}
  int fits_get_hdrspace / ffghsp
      (fitsfile *fptr, > int *keysexist, int *morekeys, int *status)
\end{verbatim}

\begin{description}
\item[3 ] Return the number of keywords in the header (not counting the END
    keyword) and the current position
    in the header.  The position is the number of the keyword record that
    will be read next (or one greater than the position of the last keyword
    that was read or written). A value of 1 is returned if the pointer is
   positioned at the beginning of the header.
\end{description}

\begin{verbatim}
  int fits_get_hdrpos / ffghps
      (fitsfile *fptr, > int *keysexist, int *keynum, int *status)
\end{verbatim}

\subsection{ Read or Write Standard Header Routines \label{FFPHPS}}

These routines provide a simple method of reading or writing most of
the keyword values that are normally required in a FITS files.  These
routines are provided for convenience and are not required to
be used.  If preferred, users may call the lower-level routines
described in the previous section to individually read or write the
required keywords.  Note that in most cases the required keywords such
as NAXIS, TFIELD, TTYPEn, etc, which define the structure of the HDU
must be written to the header before any data can be written to the
image or table.


\begin{description}
\item[1 ] Put the primary header or IMAGE extension keywords into the CHU.
The simpler ffphps routine is equivalent to calling ffphpr with the
default values of simple = TRUE, pcount = 0, gcount = 1, and extend =
TRUE.  The PCOUNT, GCOUNT and EXTEND keywords are not required in the
primary header and are only written if pcount is not equal to zero,
gcount is not equal to zero or one, and if extend is TRUE,
respectively.  When writing to an IMAGE extension, the SIMPLE and
 EXTEND parameters are ignored.
\end{description}

\begin{verbatim}
  int fits_write_imghdr / ffphps
      (fitsfile *fptr, int bitpix, int naxis, long *naxes, > int *status)

  int fits_write_grphdr / ffphpr
      (fitsfile *fptr, int simple, int bitpix, int naxis, long *naxes,
       long pcount, long gcount, int extend, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Get primary header or IMAGE extension keywords from the CHU.  When
    reading from an IMAGE extension the SIMPLE and EXTEND parameters are
   ignored.
\end{description}

\begin{verbatim}
  int fits_read_imghdr / ffghpr
      (fitsfile *fptr, int maxdim, > int *simple, int *bitpix, int *naxis,
       long *naxes, long *pcount, long *gcount, int *extend, int *status)
\end{verbatim}

\begin{description}
\item[3 ] Put the ASCII table header keywords into the CHU The optional
    TUNITn and EXTNAME keywords are written only if the input string
   values are not null.
\end{description}

\begin{verbatim}
  int fits_write_atblhdr / ffphtb
      (fitsfile *fptr, long rowlen, long nrows, int tfields, char **ttype,
       long *tbcol, char **tform, char **tunit, char *extname, > int *status)
\end{verbatim}

\begin{description}
\item[4 ] Get the ASCII table header keywords from the CHU
\end{description}

\begin{verbatim}
  int fits_read_atblhdr / ffghtb
      (fitsfile *fptr,int maxdim, > long *rowlen, long *nrows,
       int *tfields, char **ttype, long *tbcol, char **tform, char **tunit,
       char *extname,  int *status)
\end{verbatim}

\begin{description}
\item[5 ]Put the binary table header keywords into the CHU. The optional
   TUNITn and EXTNAME keywords are written only if the input string
   values are not null.  The pcount parameter, which specifies the
   size of the variable length array heap, should always = 0;
   CFITSIO will automatically update the PCOUNT keyword value if any
  variable length array data is written to the heap.
\end{description}

\begin{verbatim}
  int fits_write_btblhdr / ffphbn
      (fitsfile *fptr, long nrows, int tfields, char **ttype,
       char **tform, char **tunit, char *extname, long pcount, > int *status)
\end{verbatim}

\begin{description}
\item[6 ]Get the binary table header keywords from the CHU
\end{description}

\begin{verbatim}
  int fits_read_btblhdr / ffghbn
      (fitsfile *fptr, int maxdim, > long *nrows, int *tfields,
       char **ttype, char **tform, char **tunit, char *extname,
       long *pcount, int *status)
\end{verbatim}


\subsection{ Write Keyword Routines  \label{FFPREC}}


\begin{description}
\item[1 ]Put (append) an 80-character keyword record into the CHU.  The
   record will be padded with blanks if the input null-terminated
  card string is less than 80 characters long.
\end{description}

\begin{verbatim}
  int fits_write_record / ffprec
      (fitsfile *fptr, char *card, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Put (append) a COMMENT keyword into the CHU.  The comment string will
   be split over multiple COMMENT keywords if it is longer than 70 characters.
\end{description}

\begin{verbatim}
  int fits_write_comment / ffpcom
      (fitsfile *fptr, char *comment, > int *status)
\end{verbatim}

\begin{description}
\item[3 ]Put (append) a HISTORY keyword into the CHU.  The comment string will
  be split over multiple COMMENT keywords if it is longer than 70 characters.
\end{description}

\begin{verbatim}
  int fits_write_history / ffphis
      (fitsfile *fptr, char *history, > int *status)
\end{verbatim}

\begin{description}
\item[4 ] Put (append) the DATE keyword into the CHU.  The keyword value will contain
    the current system date as a character string in 'dd/mm/yy' format. If
    a DATE keyword already exists in the header, then this routine will
   simply update the keyword value with the current date.
\end{description}

\begin{verbatim}
  int fits_write_date / ffpdat
      (fitsfile *fptr, > int *status)
\end{verbatim}

\begin{description}
\item[5 ] Put (append) a new keyword of the appropriate datatype into the CHU.
    This is a generic routine in which
    the datatype parameter specifies the datatype of the keyword value
    with one of the following symbolic constant values:  TSTRING,
    TLOGICAL, TBYTE, TSHORT, TINT, TLONG, TFLOAT, TDOUBLE.  This
    routine then calls one of the datatype specific keyword writing
   routines described immediately below.
\end{description}

\begin{verbatim}
  int fits_write_key / ffpky
      (fitsfile *fptr, int datatype, char *keyname, void *value,
          char *comment, > int *status)
\end{verbatim}

\begin{description}
\item[6 ] Put (append) a new keyword of the appropriate datatype into the CHU.
    There is a separate routine for each datatype.
    Note that ffpkys will only write string values up to 68 characters in
    length and longer strings will be truncated.  The ffpkls routine can be
    used to write longer strings, using the non-standard FITS convention
   that was described in an earlier section.
\end{description}

\begin{verbatim}
  int fits_write_key_str / ffpkys
      (fitsfile *fptr, char *keyname, char *value, char *comment,
       > int *status)

  int fits_write_key_[log, lng] /  ffpky[lj]
      (fitsfile *fptr, char *keyname, DTYPE numval, char *comment,
       > int *status)

  int fits_write_key_[flt, dbl, fixflg, fixdbl] / ffpky[edfg]
      (fitsfile *fptr, char *keyname, DTYPE numval, int decimals,
       char *comment, > int *status)
\end{verbatim}

\begin{description}
\item[7 ] Put (append) a string valued keyword into the CHU which may be longer
    than 68 characters in length.  This uses the Long String Keyword
    convention that is described in the "Local FITS Conventions"
    section of this document.  Since this uses a non-standard FITS
    convention to encode the long keyword string, programs which use
    this routine should also call the ffplsw routine to add some COMMENT
    keywords to warn users of the FITS file that this convention is
    being used.  The ffplsw routine also writes a keyword called LONGSTRN to
    record the version of the longstring convention that has been used, in
    case a new convention is adopted at some point in the future.   If the
    LONGSTRN keyword is already present in the header, then ffplsw will
   simply return and will not write duplicate keywords.
\end{description}

\begin{verbatim}
  int fits_write_key_longstr / ffpkls
      (fitsfile *fptr, char *keyname, char *longstr, char *comment,
       > int *status)

  int fits_write_key_longwarn / ffplsw
      (fitsfile *fptr, > int *status)
\end{verbatim}

\begin{description}
\item[8 ] Put (append) a numbered sequence of keywords into the CHU.   One may
    append the same comment to every keyword (and eliminate the need
    to have an array of identical comment strings, one for each keyword) by
    including the ampersand character as the last non-blank character in the
    (first) COMMENTS string parameter.  This same string
   will then be used for the comment field in all the keywords.
\end{description}

\begin{verbatim}
  int fits_write_keys_str / ffpkns
      (fitsfile *fptr, char *keyroot, int nstart, int nkeys,
       char **value, char **comment, > int *status)

  int fits_write_keys_[log, lng] / ffpkn[lj]
      (fitsfile *fptr, char *keyroot, int nstart, int nkeys,
       DTYPE *numval, char **comment, int *status)

  int fits_write_keys_[flt, dbl, fixflg, fixdbl] / ffpkne[edfg]
      (fitsfile *fptr, char *keyroot, int nstart, int nkey,
       DTYPE *numval, int decimals, char **comment, > int *status)
\end{verbatim}

\begin{description}
\item[9 ] Put (append) a `triple precision' keyword into the CHU in F28.16 format.
    The floating point keyword value is constructed by concatenating the
    input integer value with the input double precision fraction value
    (which must have a value between 0.0 and 1.0). The ffgkyt routine should
    be used to read this keyword value, because the other keyword reading
   routines will not preserve the full precision of the value.
\end{description}

\begin{verbatim}
  int fits_write_key_triple / ffpkyt
      (fitsfile *fptr, char *keyname, long intval, double frac,
       char *comment, > int *status)
\end{verbatim}

\subsection{ Insert Keyword Routines \label{FFIREC}}

These insert routines are somewhat less efficient than the `append' keyword
routines described above because the remaining keywords in the header must
be shifted down one position.


\begin{description}
\item[1 ] Insert a new keyword record into the CHU at the specified position
   (i.e., immediately preceding the (keynum)th keyword in the header.)
\end{description}

\begin{verbatim}
  int fits_insert_record / ffirec
      (fitsfile *fptr, int keynum, char *card, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Insert a new keyword into the CHU.  The new keyword is inserted
   immediately following the last keyword that has been read from the header.
\end{description}

\begin{verbatim}
  int fits_insert_key_str / ffikys
      (fitsfile *fptr, char *keyname, char *value, char *comment,
       > int *status)

  int fits_insert_key_[log, lng] / ffiky[lj]
      (fitsfile *fptr, char *keyname, DTYPE numval, char *comment,
       > int *status)

  int fits_insert_key_[flt, fixflt, dbl, fixdbl] / ffiky[edfg]
      (fitsfile *fptr, char *keyname, DTYPE numval, int decimals,
       char *comment, > int *status)
\end{verbatim}

\subsection{ Read Keyword Routines \label{FFGREC}}


\begin{description}
\item[1 ] Get the nth 80-character header record from the CHU
\end{description}

\begin{verbatim}
  int fits_read_record / ffgrec
      (fitsfile *fptr, int keynum, > char *card, int *status)
\end{verbatim}

\begin{description}
\item[2 ] Get the name, value (as a string), and comment of the nth keyword in CHU.
    This routine also checks that the returned keyword name (keyname) contains
   only legal ASCII characters.
\end{description}

\begin{verbatim}
  int fits_read_keyn / ffgkyn
      (fitsfile *fptr, int keynum, > char *keyname, char *value,
       char *comment, int *status)
\end{verbatim}

\begin{description}
\item[3 ] Get the 80-character header record for the named keyword
\end{description}

\begin{verbatim}
  int fits_read_card / ffgcrd
      (fitsfile *fptr, char *keyname, > char *card, int *status)
\end{verbatim}

\begin{description}
\item[4 ]  Get the literal keyword value as a character string.  Regardless
     of the datatype of the keyword, this routine simply returns the
     string of characters in the value field of the keyword along with
    the comment field.
\end{description}

\begin{verbatim}
  int fits_read_keyword / ffgkey
      (fitsfile *fptr, char *keyname, > char *value, char *comment,
       int *status)
\end{verbatim}

\begin{description}
\item[5 ] Get a keyword value (with the appropriate datatype) and comment from the
    CHU. The datatype parameter specifies the datatype of the keyword value
    and can have one of the following symbolic constant values:  TSTRING,
   TLOGICAL, TBYTE, TSHORT, TINT, TLONG, TFLOAT, TDOUBLE.
\end{description}

\begin{verbatim}
  int fits_read_key / ffgky
      (fitsfile *fptr, int datatype, char *keyname, > void *value,
       char *comment, int *status)
\end{verbatim}

\begin{description}
\item[6 ] Get a keyword value (with the appropriate datatype) and comment from
   the CHU.
\end{description}

\begin{verbatim}
  int fits_read_key_str / ffgkys
      (fitsfile *fptr, char *keyname, > char *value, char *comment,
       int *status);

  NOTE: after calling the following routine, programs must explicitly free
        the memory allocated for 'longstr' after it is no longer needed.

  int fits_read_key_longstr / ffgkls
      (fitsfile *fptr, char *keyname, > char **longstr, char *comment,
             int *status)

  int fits_read_key_[log, lng, flt, dbl] / ffgky[ljed]
      (fitsfile *fptr, char *keyname, > DTYPE *numval, char *comment,
       int *status)
\end{verbatim}

\begin{description}
\item[7 ] Get a sequence of numbered keyword values.
\end{description}

\begin{verbatim}
  int fits_read_keys_str / ffgkns
      (fitsfile *fptr, char *keyname, int nstart, int nkeys,
       > char **value, int *nfound,  int *status)

  int fits_read_keys_[log, lng, flt, dbl] / ffgkn[ljed]
      (fitsfile *fptr, char *keyname, int nstart, int nkeys,
       > DTYPE *numval, int *nfound, int *status)
\end{verbatim}

\begin{description}
\item[8 ] Get the value of a floating point keyword, returning the integer and
    fractional parts of the value in separate routine arguments.
    This routine may be used to read any keyword but is especially
   useful for reading the 'triple precision' keywords written by ffpkyt.
\end{description}

\begin{verbatim}
  int fits_read_key_triple / ffgkyt
      (fitsfile *fptr, char *keyname, > long *intval, double *frac,
       char *comment, int *status)
\end{verbatim}


\subsection{ Modify Keyword Routines \label{FFMREC}}


\begin{description}
\item[1 ] Modify (overwrite) the nth 80-character header record in the CHU.
\end{description}

\begin{verbatim}
  int fits_modify_record / ffmrec
      (fitsfile *fptr, int keynum, char *card, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Modify (overwrite) the 80-character header record for the named keyword
    in the CHU.  This can be used to overwrite the name of the keyword as
   well as its value and comment fields.
\end{description}

\begin{verbatim}
  int fits_modify_card / ffmcrd
      (fitsfile *fptr, char *keyname, char *card, > int *status)
\end{verbatim}

\begin{description}
\item[3 ] Modify (overwrite) the name of an existing keyword in the CHU
   preserving the current value and comment fields.
\end{description}

\begin{verbatim}
  int fits_modify_name / ffmnam
      (fitsfile *fptr, char *oldname, char *newname, > int *status)
\end{verbatim}

\begin{description}
\item[4 ] Modify (overwrite) the comment field of an existing keyword in the CHU.
\end{description}

\begin{verbatim}
  int fits_modify_comment / ffmcom
      (fitsfile *fptr, char *keyname, char *comment, > int *status)
\end{verbatim}

\begin{description}
\item[5 ] Modify the value and comment fields of an existing keyword in the CHU.
    Optionally, one may modify only the value field and leave the comment
    field unchanged by setting the input COMMENT parameter equal to
   the ampersand character (\&).
\end{description}

\begin{verbatim}
  int fits_modify_key_str / ffmkys
      (fitsfile *fptr, char *keyname, char *value, char *comment,
       > int *status);

  int fits_modify_key_[log, lng] / ffmky[lj]
      (fitsfile *fptr, char *keyname, DTYPE numval, char *comment,
       > int *status)

  int fits_modify_key_[flt, dbl, fixflt, fixdbl] / ffmky[edfg]
      (fitsfile *fptr, char *keyname, DTYPE numval, int decimals,
                  char *comment, > int *status)
\end{verbatim}

\subsection{ Update Keyword Routines \label{FFUCRD}}

These update routines modify the value of the keyword if it already exists,
otherwise the new keyword is appended to the header.


\begin{description}
\item[1 ] Update an 80-character record in the CHU.
\end{description}

\begin{verbatim}
  int fits_update_card / ffucrd
      (fitsfile *fptr, char *keyname, char *card, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Update the value and comment fields of a keyword in the CHU.
\end{description}

\begin{verbatim}
  int fits_update_key_str / ffukys
      (fitsfile *fptr, char *keyname, char *value, char *comment,
       > int *status)

  int fits_update_key_[log, lng] / ffuky[lj]
      (fitsfile *fptr, char *keyname, DTYPE numval, char *comment,
       > int *status)

  int fits_update_key_[flt, dbl, fixflt, fixdbl] / ffuky[edfg]
      (fitsfile *fptr, char *keyname, DTYPE numval, int decimals,
       char *comment, > int *status)
\end{verbatim}

\subsection{ Delete Keyword Routines \label{FFDREC}}


\begin{description}
\item[1 ] Delete an existing keyword record.  The space previously occupied by
    the keyword is reclaimed by moving all the following header records up
    one row in the header.  The first routine deletes a keyword at a
    specified position in the header (the first keyword is at position 1),
   whereas the second routine deletes a specifically named keyword.
\end{description}

\begin{verbatim}
  int fits_delete_record / ffdrec
      (fitsfile *fptr, int   keynum,  > int *status)

  int fits_delete_key / ffdkey
      (fitsfile *fptr, char *keyname, > int *status)
\end{verbatim}


\section{Data Scaling and Undefined Pixel Parameters  \label{FFPSCL}}

These routines define or modify the internal parameters used by
CFITSIO to either scale the data or to represent undefined pixels.
Generally CFITSIO will scale the data according to the values of the BSCALE
and BZERO (or TSCALn and TZEROn) keywords, however these routines
may be used to override the keyword values.  This may be useful when
one wants to read or write the raw unscaled values in the FITS file.
Similarly, CFITSIO generally uses the value of the BLANK or TNULLn
keyword to signify an undefined pixel, but these routines may be used
to override this value.  These routines do not create or modify the
corresponding header keyword values.


\begin{description}
\item[1 ] Reset the scaling factors in the primary array or image extension; does
    not change the BSCALE and BZERO keyword values and only affects the
    automatic scaling performed when the data elements are written/read
    to/from the FITS file.   When reading from a FITS file the returned
    data value = (the value given in the FITS array) * BSCALE + BZERO.
    The inverse formula is used when writing data values to the FITS
   file.
\end{description}

\begin{verbatim}
  int fits_set_bscale / ffpscl
      (fitsfile *fptr, double scale, double zero, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Reset the scaling parameters for a table column; does not change
    the TSCALn or TZEROn keyword values and only affects the automatic
    scaling performed when the data elements are written/read to/from
    the FITS file.  When reading from a FITS file the returned data
    value = (the value given in the FITS array) * TSCAL + TZERO.  The
   inverse formula is used when writing data values to the FITS file.
\end{description}

\begin{verbatim}
  int fits_set_tscale / fftscl
      (fitsfile *fptr, int colnum, double scale, double zero,
       > int *status)
\end{verbatim}

\begin{description}
\item[3 ] Define the integer value to be used to signify undefined pixels in the
    primary array or image extension.  This is only used if BITPIX = 8, 16,
    or 32.  This does not create or change the value of the BLANK keyword in
   the header.
\end{description}

\begin{verbatim}
  int fits_set_imgnul / ffpnul
      (fitsfile *fptr, long nulval, > int *status)
\end{verbatim}

\begin{description}
\item[4 ] Define the string to be used to signify undefined pixels in
    a column in an ASCII table.  This does not create or change the value
   of the TNULLn keyword.
\end{description}

\begin{verbatim}
  int fits_set_atblnull / ffsnul
      (fitsfile *fptr, int colnum, char *nulstr, > int *status)
\end{verbatim}

\begin{description}
\item[5 ] Define the value to be used to signify undefined pixels in
    an integer column in a binary table (where TFORMn = 'B', 'I', or 'J').
   This does not create or  change the value of the TNULLn keyword.
\end{description}

\begin{verbatim}
  int fits_set_btblnul / fftnul
      (fitsfile *fptr, int colnum, long nulval, > int *status)
\end{verbatim}


\section{FITS Primary Array or IMAGE Extension I/O Routines}

These routines put or get data values in the primary data array (i.e.,
the first HDU in the FITS file) or an IMAGE extension.   Automatic data
type conversion is performed for if the data type of the primary array
(as defined by the BITPIX keyword) differs from the data type of the
array in the calling routine.  The data values are also scaled by the
BSCALE and BZERO header values as they are being written or read from
the FITS array.

The more primitive reading and writing routines (i. e., ffppr\_,
ffppn\_, ffppn, ffgpv\_, or ffgpf\_) simply treat the primary
array as a long 1-dimensional array of pixels, ignoring the
intrinsic dimensionality of the array.  When dealing with
a 2D image, for example, the application program must calculate
the pixel offset in the 1-D array that corresponds to any
particular X, Y coordinate in the image.

For convenience, higher-level routines are also provided to specificly
deal with 2D images (ffp2d\_ and ffg2d\_) and 3D data cubes (ffp3d\_
and ffg3d\_).  The dimensionality of the FITS image is passed by the
naxis1, naxis2, and naxis3 parameters and the declared dimensions of
the program array are passed in the dim1 and dim2 parameters.  Note
that the dimensions of the program array may be larger than the
dimensions of the FITS array.  For example if a FITS image with NAXIS1
= NAXIS2 = 400 is read into a program array which is dimensioned as 512
x 512 pixels, then the image will just fill the lower left corner of
the array with pixels in the range 1 - 400 in the X an Y directions.
This has the effect of taking a contiguous set of pixel value in the
FITS array and writing them to a non-contiguous array in program memory
(i.e., there are now some blank pixels around the edge of the image in
the program array).

The most general set of routines (ffpss\_, ffgsv\_, and ffgsf\_) may be
used to transfer a rectangular subset of the pixels in a FITS
N-dimensional image to or from an array which has been declared in the
calling program.  The fpixels and lpixels parameters are integer arrays
which specify the starting and ending pixels in each dimension
(starting with 1, not 0) of the FITS image that is to be read or
written.  It is important to note that these are the starting and
ending pixels in the FITS image, not in the declared array in the
program. The array parameter in these routines is treated simply as a
large one-dimensional array of the appropriate datatype containing the
pixel values; The pixel values in the FITS array are read/written
from/to this program array in strict sequence without any gaps;  it is
up to the calling routine to correctly interpret the dimensionality of
this array.  The two FITS reading routines (ffgsv\_ and ffgsf\_ ) also
have an `inc' parameter which defines the data sampling interval in
each dimension of the FITS array.  For example, if inc[0]=2 and
inc[1]=3 when reading a 2-dimensional FITS image, then only every other
pixel in the first dimension and every 3rd pixel in the second
dimension will be returned to the 'array' parameter.

Two types of routines are provided to read the data array which differ
in the way undefined pixels are handled.  The first type of routines
(e.g., ffgpv\_) simply return an array of data elements in which
undefined pixels are set equal to a value specified by the user in the
`nulval' parameter.  An additional feature of these routines is that if
the user sets nulval = 0, then no checks for undefined pixels will be
performed, thus reducing the amount of CPU processing.  The second type
of routines (e.g., ffgpf\_) returns the data element array and, in
addition, a char array which defines whether the corresponding data
pixel is defined (= 1) or not (= 0).  The latter type of routines may
be more convenient to use in some circumstances, however, it requires
an additional array of logical values which can be unwieldy when
working with large data arrays.


\subsection{Write Image Data Routines \label{FFPPR}}

\begin{description}
\item[1 ] Put elements into the data array. The datatype parameter specifies
    the datatype of the array of values and can have one of the following
   symbolic constant values: TBYTE, TSHORT, TINT, TLONG, TFLOAT, TDOUBLE.
\end{description}

\begin{verbatim}
  int fits_write_img / ffppr
      (fitsfile *fptr, int datatype, long firstelem, long nelements,
       void *array, int *status);
\end{verbatim}

\begin{description}
\item[2 ] Put elements into the data array.  The datatype is specified
   by the suffix of the name of the routine.
\end{description}

\begin{verbatim}
  int fits_write_img_[byt, sht, lng, flt, dbl] / ffppr[bijed]
      (fitsfile *fptr, long group, long firstelem, long nelements,
       DTYPE *array, > int *status);
\end{verbatim}

\begin{description}
\item[3 ]Put elements into the data array, substituting the appropriate FITS null
   value for all elements which are equal to the value of NULLVAL.  For
   integer FITS arrays, the null value defined by the BLANK keyword or
   a previous call to ffpnul
   will be substituted;  for floating point FITS arrays (BITPIX = -32
   or -64) then the special IEEE NaN (Not-a-Number) value will be
  substituted.
\end{description}

\begin{verbatim}
  int fits_write_imgnull_[byt, sht, lng, flt, dbl] / ffppn[bijed]
      (fitsfile *fptr, long group, long firstelem,
           long nelements, DTYPE *array, DTYPE nulval, > int *status);
\end{verbatim}

\begin{description}
\item[4 ]Set data array elements as undefined.
\end{description}

\begin{verbatim}
  int fits_write_img_null / ffppru
      (fitsfile *fptr, long group, long firstelem, long nelements,
       > int *status)
\end{verbatim}

\begin{description}
\item[5 ] Put values into group parameters.  This routine only applies
   to the obsolete `Random Grouped' FITS format files.
\end{description}

\begin{verbatim}
  int fits_write_grppar_[byt, sht, lng, flt, dbl] / ffpgp[bijed]
      (fitsfile *fptr, long group, long firstelem, long nelements,
       > DTYPE *array, int *status)
\end{verbatim}

\begin{description}
\item[6 ] Put 2-D image into the data array.
\end{description}

\begin{verbatim}
  int fits_write_2d_[byt, sht, lng, flt, dbl] / ffp2d[bijed]
      (fitsfile *fptr, long group, long dim1, long naxis1,
       long naxis2, DTYPE *array, > int *status)
\end{verbatim}

\begin{description}
\item[7 ] Put 3-D cube into the data array.
\end{description}

\begin{verbatim}
  int its_write_3d_[byt, sht, lng, flt, dbl] / ffp3d[bijed]
      (fitsfile *fptr, long group, long dim1, long dim2,
       long naxis1, long naxis2, long naxis3, DTYPE *array, > int *status)
\end{verbatim}

\begin{description}
\item[8 ]   Put an arbitrary data subsection into the data array.
\end{description}

\begin{verbatim}
  int fits_write_subset_[byt, sht, lng, flt, dbl] / ffpss[bijed]
      (fitsfile *fptr, long group, long naxis, long *naxes,
       long *fpixel, long *lpixel, DTYPE *array, > int *status)
\end{verbatim}


\subsection{ Read Image Data Routines \label{FFGPV}}


\begin{description}
\item[1 ] Get elements from the data array.  The datatype parameter specifies
    the datatype of the array of values and can have one of the following
    symbolic constant values: TBYTE, TSHORT, TINT, TLONG, TFLOAT, TDOUBLE.
    Undefined array elements will be returned with a value = *nullval,
    (note that this is the address to the null value, not the null value
    itself) unless nulval = 0 in which case no checks for undefined pixels
   will be performed.
\end{description}

\begin{verbatim}
  int fits_read_img / ffgpv
      (fitsfile *fptr, int  datatype, long firstelem, long nelements,
       void *nulval, > void *array, int *anynul, int *status)
\end{verbatim}

\begin{description}
\item[2 ] Get elements from the data array.  Undefined array elements will be
    returned with a value = nullval, unless nullval = 0 in which case no
   checks for undefined pixels will be performed.
\end{description}

\begin{verbatim}
  int fits_read_img_[byt, sht, lng, flt, dbl] / ffgpv[bijed]
      (fitsfile *fptr, long group, long firstelem, long nelements,
       DTYPE nulval, > DTYPE *array, int *anynul, int *status)
\end{verbatim}

\begin{description}
\item[3 ] Get elements and nullflags from data array.
    Any undefined array elements will have the corresponding nularray element
   set equal to 1, else 0.
\end{description}

\begin{verbatim}
  int  fits_read_imgnull_[byt, sht, lng, flt, dbl] / ffgpf[bijed]
      (fitsfile *fptr, long group, long firstelem, long nelements,
       > DTYPE *array, char *nularray, int *anynul, int *status)
\end{verbatim}

\begin{description}
\item[4 ] Get values from group parameters.   This routine only applies
   to the obsolete `Random Grouped' FITS format files.
\end{description}

\begin{verbatim}
  int  fits_read_grppar_[byt, sht, lng, flt, dbl] / ffggp[bijed]
      (fitsfile *fptr, long group, long firstelem, long nelements,
       > DTYPE *array, int *status)
\end{verbatim}

\begin{description}
\item[5 ]  Get 2-D image from the data array.  Undefined
     pixels in the array will be set equal to the value of 'nulval',
     unless nulval=0 in which case no testing for undefined pixels will
    be performed.
\end{description}

\begin{verbatim}
  int  fits_read_2d_[byt, sht, lng, flt, dbl] / ffg2d[bijed]
      (fitsfile *fptr, long group, DTYPE nulval, long dim1, long naxis1,
       long naxis2, > DTYPE *array, int *anynul, int *status)
\end{verbatim}

\begin{description}
\item[6 ] Get 3-D cube from the data array.   Undefined
    pixels in the array will be set equal to the value of 'nulval',
    unless nulval=0 in which case no testing for undefined pixels will
   be performed.
\end{description}

\begin{verbatim}
  int  fits_read_3d_[byt, sht, lng, flt, dbl] / ffg3d[bijed]
      (fitsfile *fptr, long group, DTYPE nulval, long dim1,
       long dim2, long naxis1, long naxis2, long naxis3,
       > DTYPE *array, int *anynul, int *status)
\end{verbatim}


\begin{description}
\item[7 ]   Get an arbitrary data subsection from the data array.  Undefined
       pixels in the array will be set equal to the value of 'nulval',
       unless nullval=0 in which case no testing for undefined pixels will
      be performed.
\end{description}

\begin{verbatim}
  int  fits_read_subset_[byt, sht, lng, flt, dbl] / ffgsv[bijed]
      (fitsfile *fptr, int group, int naxis, long *naxes,
       long *fpixels, long *lpixels, long *inc, DTYPE nulval,
       > DTYPE *array, int *anynul, int *status)
\end{verbatim}

\begin{description}
\item[8 ]   Get an arbitrary data subsection from the data array.  Any Undefined
       pixels in the array will have the corresponding 'nularray'
      element set equal to TRUE.
\end{description}

\begin{verbatim}
  int  fits_read_subsetnull_[byt, sht, lng, flt, dbl] / ffgsf[bijed]
      (fitsfile *fptr, int group, int naxis, long *naxes,
       long *fpixels, long *lpixels, long *inc, > DTYPE *array,
       char *nularray, int *anynul, int *status)
\end{verbatim}


\section{FITS ASCII and Binary Table Data I/O Routines}


\subsection{Column Information Routines \label{FFGCNO}}


\begin{description}
\item[1 ] Get the table column number (and name) of the column whose name
matches an input template name.  The table column names are defined by
the TTYPEn keywords in the FITS header.  If a column does not have a
TTYPEn keyword, then these routines assume that the name consists of
all blank characters.  These 2 routines perform the same function
except that ffgcno only returns the number of the matching column whereas
ffgcnn also returns the name of the column.  If casesen = TRUE then
the column name match will be case-sensitive.

The input column name template (templt) is either the exact name of the
column to be searched for, or it may contain wild card characters (* or
?), or it may contain the integer number of the desired column (where
the number is expressed as ASCII digits).  The wild cards behave
similarly to UNIX filename matching:  the '*' character matches any
sequence of characters (including zero characters) and the '?'
character matches any single character.  As an example, the template
strings `AB?DE', `AB*E', and `AB*CDE' will all match the string
'ABCDE'.  If more than one column name in the table matches the
template string, then the first match is returned and the status value
will be set to COL\_NOT\_UNIQUE (237) as a warning that a unique match
was not found.  To find the other cases that match the template, simply
call the routine again leaving the input status value equal to 237 and
the next matching name will then be returned.  Repeat this process
until a status = COL\_NOT\_FOUND (219) is returned.  If these routines
fail to match the template to any of the columns in the table, they
lastly check if the template can be interpreted as a simple positive
integer (e.g., '7', or '512') and if so, they return that column
number.  If no matches are found then a status = COL\_NOT\_FOUND (219)
error is returned.

Note that the FITS Standard recommends that only letters, digits, and
the underscore character be used in column names (with no embedded
spaces in the name).  Trailing blank characters are not significant.
It is recommended that the column names in a given table be unique
within the first 8 characters, and HIGHLY recommended that the names be
unique withing the first 16 characters.
\end{description}

\begin{verbatim}
  int fits_get_colnum / ffgcno
      (fitsfile *fptr, int casesen, char *templt, > int *colnum,
       int *status)

  int fits_get_colname / ffgcnn
      (fitsfile *fptr, int casesen, char *templt, > char *colname,
       int *colnum, int *status)
\end{verbatim}

\begin{description}
\item[2 ] Get the datatype of a column in an ASCII or binary table.  This
    routine returns an integer code value corresponding to the datatype
    of the column. (See the ffbnfm and ffasfm routines in the Utilities
    section of this document for a list of the code values).  The vector
    repeat count (which is alway 1 for ASCII table columns) is also returned.
    If the specified column has an ASCII character datatype (code = 16) then
    the width of a unit string in the column is also returned.  Note that
    this routine supports the local convention for specifying arrays of
    strings within a binary table character column, using the syntax
    TFORM = 'rAw' where 'r' is the total number of characters (= the width
    of the column) and 'w' is the width of a unit string within the column.
    Thus if the column has TFORM = '60A12' then this routine will return
   typecode = 16, repeat = 60, and width = 12.
\end{description}

\begin{verbatim}
  int fits_get_coltype / ffgtcl
      (fitsfile *fptr, int colnum, > int *typecode, long *repeat,
       long *width, int *status)
\end{verbatim}

\begin{description}
\item[3 ] Get information about an existing ASCII table column.
\end{description}

\begin{verbatim}
int fits_get_acolparms / ffgacl
    (fitsfile *fptr, int colnum, > char *ttype, long *tbcol,
     char *tunit, char *tform, double *scale, double *zero,
     char *nulstr, char *tdisp, int *status)
\end{verbatim}

\begin{description}
\item[4 ] Get information about an existing binary table column. DATATYPE is a
    character string which returns the datatype of the column as defined
    by the TFORMn keyword (e.g., 'I', 'J','E', 'D', etc.).  In the case
    of an ASCII character column, typecode will have a value of the
    form 'An' where 'n' is an integer expressing the width of the field
    in characters.  For example, if TFORM = '160A8' then ffgbcl will return
    typechar='A8' and repeat=20.   All the returned parameters are scalar
   quantities.
\end{description}

\begin{verbatim}
  int fits_get_bcolparms / ffgbcl
      (fitsfile *fptr, int colnum, > char *ttype, char *tunit,
       char *typechar, long *repeat, double *scale, double *zero,
       long *nulval, char *tdisp, int  *status)
\end{verbatim}

\begin{description}
\item[ 5] Put (append) a TDIMn keyword whose value has the form '(l,m,n...)'
    where l, m, n... are the dimensions of a multidimension array
   column in a binary table.
\end{description}

\begin{verbatim}
  int fits_write_tdim / ffptdm
      (fitsfile *fptr, int colnum, int naxis, long *naxes, > int *status)
\end{verbatim}

\begin{description}
\item[ 6] Return the number of and size of the dimensions of a table column.
    Normally this information is given by the TDIMn keyword, but if
    this keyword is not present then this routine returns naxis = 1
   and naxes[0] equal to the repeat count in the TFORM keyword.
\end{description}

\begin{verbatim}
  int fits_read_tdim / ffgtdm
      (fitsfile *fptr, int colnum, int maxdim, > int *naxis,
       long *naxes, int *status)
\end{verbatim}

\subsection{Low-Level Table Access Routines \label{FFGTBB}}

The following 2 routines provide low-level access to the data in ASCII
or binary tables and are mainly useful as an efficient way to copy all
or part of a table from one location to another.  These routines simply
read or write the specified number of consecutive bytes in an ASCII or
binary table, without regard for column boundaries or the row length in
the table.  These routines do not perform any machine dependent data
conversion or byte swapping.


\begin{description}
\item[1 ] Read a consecutive array of bytes from an ASCII or binary table
\end{description}

\begin{verbatim}
  int fits_read_tblbytes / ffgtbb
      (fitsfile *fptr, long firstrow, long firstchar, long nchars,
       > unsigned char *values, int *status)
\end{verbatim}

\begin{description}
\item[2 ] Write a consecutive array of bytes to an ASCII or binary table
\end{description}

\begin{verbatim}
  int fits_write_tblbytes / ffptbb
      (fitsfile *fptr, long firstrow, long firstchar, long nchars,
       unsigned char *values, > int *status)
\end{verbatim}

\subsection{ Insert or Delete Rows and Columns Routines \label{FFIROW}}


\begin{description}
\item[1 ] Insert blank rows into an existing ASCII or binary table (in the CDU).
    All the rows FOLLOWING row FROW are shifted down by NROWS rows.  If
    FROW = 0 then the blank rows are inserted at the beginning of the
    table.  This routine modifies the NAXIS2 keyword to reflect the new
   number of rows in the table.
\end{description}

\begin{verbatim}
  int fits_insert_rows / ffirow
      (fitsfile *fptr, long firstrow, long nrows, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Delete rows from an existing ASCII or binary table (in the CDU).
    The NROWS number of rows are deleted, starting with row FROW, and
    any remaining rows in the table are shifted up to fill in the space.
    This routine modifies the NAXIS2 keyword to reflect the new number
    of rows in the table.  Note that the physical size of the FITS file will
    not be reduced by this operation, and the empty FITS blocks if any
   at the end of the file will be padded with zeros.
\end{description}

\begin{verbatim}
  int fits_delete_rows / ffdrow
      (fitsfile *fptr, long firstrow, long nrows, > int *status)
\end{verbatim}

\begin{description}
\item[3 ] Insert a blank column (or columns) into an existing ASCII or binary
    table (in the CDU).  COLNUM specifies the column number that the (first)
    new column should occupy in the table.  NCOLS specifies how many
    columns are to be inserted. Any existing columns from this position and
    higher are moved over to allow room for the new column(s).
    The index number on all the following keywords will be incremented
    if necessary to reflect the new position of the column(s) in the table:
    TBCOLn, TFORMn, TTYPEn, TUNITn, TNULLn, TSCALn, TZEROn, TDISPn, TDIMn,
    TLMINn, TLMAXn, TDMINn, TDMAXn, TCTYPn, TCRPXn, TCRVLn, TCDLTn, TCROTn,
   and TCUNIn.
\end{description}

\begin{verbatim}
  int fits_insert_col / fficol
      (fitsfile *fptr, int colnum, char *ttype, char *tform,
       > int *status)

  int fits_insert_cols / fficls
      (fitsfile *fptr, int colnum, int ncols, char **ttype,
       char **tform, > int *status)
\end{verbatim}

\begin{description}
\item[4 ] Delete a column from an existing ASCII or binary table (in the CDU).
    The index number of all the keywords listed above (for fficol) will be
    decremented if necessary to reflect the new position of the column(s) in
    the table.  Those index keywords that refer to the deleted column will
    also be deleted.  Note that the physical size of the FITS file will
    not be reduced by this operation, and the empty FITS blocks if any
   at the end of the file will be padded with zeros.
\end{description}

\begin{verbatim}
  int fits_delete_col / ffdcol(fitsfile *fptr, int colnum, > int *status)
\end{verbatim}

\subsection{ Write Column Data Routines \label{FFPCLS}}

The following routines put or get data values in the current ASCII or
Binary table extension.  Automatic data type conversion is performed
for numerical data types (B,I,J,E,D) if the data type of the column
(defined by the TFORM keyword) differs from the data type of the
calling routine.  The data values are also scaled by the TSCALn and
TZEROn header values as they are being written to or read from the FITS
array.  The fftscl routine MUST be used to define the scaling
parameters when writing data to the table or to override the default
scaling values given in the header when reading from the table.

    In the case of binary tables with vector elements, the 'felem'
parameter defines the starting pixel within the element vector.  This
parameter is ignored with ASCII tables. Similarly, in the case of
binary tables the 'nelements' parameter specifies the total number of
vector values read or written (continuing on subsequent rows if
required) and not the number of table elements.  Two sets of
routines are provided to get the column data which differ in the way
undefined pixels are handled.  The first set of routines (ffgcv)
simply return an array of data elements in which undefined pixels are
set equal to a value specified by the user in the 'nullval' parameter.
An additional feature of these routines is that if the user sets
nullval = 0, then no checks for undefined pixels will be performed,
thus increasing the speed of the program.  The second set of routines
(ffgcf) returns the data element array and in addition a logical array
of flags which defines whether the corresponding data pixel is undefined.


\begin{description}
\item[1 ] Put elements into an ASCII or binary table column (in the CDU).
\end{description}

\begin{verbatim}
  int fits_write_col / ffpcl
      (fitsfile *fptr, int datatype, int colnum, long firstrow,
       long firstelem, long nelements, char **array, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Put elements into an ASCII or binary table column (in the CDU).
\end{description}

\begin{verbatim}
  int fits_write_col_str / ffpcls
      (fitsfile *fptr, int colnum, long firstrow, long firstelem,
       long nelements, char **array, > int *status)

  int fits_write_col_[log, byt, sht, lng, flt, dbl, cmp, dblcmp] /
      ffpcl[lbijedcm]
      (fitsfile *fptr, int colnum, long firstrow,
           long firstelem, long nelements, DTYPE *array, > int *status)
\end{verbatim}

\begin{description}
\item[3 ] Put elements into an ASCII or binary table column (in the CDU)
    substituting the appropriate FITS null value for any elements that
    are equal to NULLVAL.  This family of routines must NOT be used to
    write to  variable length array columns. For ASCII TABLE extensions, the
    null value defined by the previous call to ffsnul will be substituted;
    For integer FITS columns, in a binary table  the null value
    defined by the previous call to fftnul will be substituted;
    For floating point FITS columns a special IEEE NaN (Not-a-Number)
   value will be substituted.
\end{description}

\begin{verbatim}
  int fits_write_colnul_[byt, sht, lng, flt, dbl] / ffpcn[bijed]
      (fitsfile *fptr, int colnum, long firstrow, long firstelem,
       long nelements, DTYPE *array, DTYPE nulval, > int *status)
\end{verbatim}

\begin{description}
\item[4 ] Put bit values into a binary byte ('B') or bit ('X') table column (in the
    CDU).  Larray is an array of logical values corresponding to the sequence of
    bits to be written.  If larray is true then the corresponding bit is
    set to 1, otherwise the bit is set to 0.  Note that in the case of
    'X' columns, CFITSIO can write to all 8 bits of each byte whether
    they are formally valid or not.  Thus if the column is defined as
    '4X', and one calls ffpclx with  firstbit=1 and nbits=8, then all 8 bits
    will be written into the first byte (as opposed to writing the
    first 4 bits into the first row and then the next 4 bits into the
    next row), even though the last 4 bits of each byte are formally
   not defined.
\end{description}

\begin{verbatim}
  int fits_write_col_bit / ffpclx
      (fitsfile *fptr, int colnum, long firstrow, long firstbit,
       long nbits, char *larray, > int *status)
\end{verbatim}

\begin{description}
\item[5 ] Set table elements in a column as undefined
\end{description}

\begin{verbatim}
   int fits_write_col_null / ffpclu
       (fitsfile *fptr, int colnum, long firstrow, long firstelem,
        long nelements, > int *status)
\end{verbatim}

\begin{description}
\item[6 ] Put the descriptor for a variable length column in a binary table.
    This routine can be used in conjunction with FFGDES to enable
    2 or more arrays to point to the same storage location to save
   storage space if the arrays are identical.
\end{description}

\begin{verbatim}
    int fits_write_descript / ffpdes
        (fitsfile *fptr, int colnum, long rownum, long repeat,
         long offset, > int *status)
\end{verbatim}

\begin{description}
\item[7 ] Define the zero indexed byte offset of the 'heap' measured from
    the start of the binary table data.  By default the heap is assumed
    to start immediately following the regular table data, i.e., at
    location NAXIS1 x NAXIS2.  This routine is only relevant for
    binary tables which contain variable length array columns (with
    TFORMn = 'Pt').  This routine also automatically writes
    the value of theap to a keyword in the extension header.  This
    routine must be called after the required keywords have been
    written (with ffphbn) and after the table structure has been defined
   (with ffbdef) but before any data is written to the table.
\end{description}

\begin{verbatim}
  int fits_write_theap / ffpthp
      (fitsfile *fptr, long theap, > int *status)
\end{verbatim}

\subsection{ Read Column Data Routines \label{FFGCL}}


\begin{description}
\item[1 ] Get elements from an ASCII or binary table column (in the CDU).  These
    routines return the values of the table column array elements.  Undefined
    array elements will be returned with a value = nulval, unless nulval = 0
    (or = ' ' for ffgcvs) in which case no checking for undefined values will
    be performed. The ANYF parameter is set to true if any of the returned
    elements are undefined. (Note: the ffgcl routine simple gets an array
    of logical data values without any checks for undefined values;  use
   the ffgcfl routine to check for undefined logical elements).
\end{description}

\begin{verbatim}
  int fits_read_col / ffgcv
      (fitsfile *fptr, int datatype, int colnum, long firstrow, long firstelem,
       long nelements, void *nulval, void *array, int *anynul, int *status)

  int fits_read_col_log / ffgcl
      (fitsfile *fptr, int colnum, long firstrow, long firstelem,
       long nelements, > char *array, int  *status)

  int fits_read_col_str / ffgcvs
      (fitsfile *fptr, int colnum, long firstrow, long firstelem,
       long nelements, char *nulstr, > char **array, int *anynul,
       int *status)

  int fits_read_col_[byt, sht, lng, flt, dbl, cmp, dblcmp] / ffgcv[bijedcm]
      (fitsfile *fptr, int colnum, long firstrow, long firstelem,
       long nelements, DTYPE nulval, > DTYPE *array, int *anynul,
       int *status)
\end{verbatim}

\begin{description}
\item[2 ]  Get elements and null flags from an ASCII or binary table column (in the
    CHDU).  These routines return the values of the table column array elements.
    Any undefined array elements will have the corresponding nularray element
    set equal to TRUE.  The anynul parameter is set to true if any of the
   returned elements are undefined.
\end{description}

\begin{verbatim}
  int fits_read_colnull_str / ffgcfs
      (fitsfile *fptr, int colnum, long firstrow, long firstelem,
       long nelements, > char **array, char *nularray, int *anynul,
       int *status)

  int fits_read_col_log / ffgcfl
      (fitsfile *fptr, int colnum, long firstrow, long firstelem,
       long nelements, > char *array, char *nularray, int *anynul,
       int *status)

  int fits_read_col_[byt, sht, lng, flt, dbl, cmp, dblcmp] / ffgcf[bijedcm]
      (fitsfile *fptr, int colnum, long firstrow,
       long firstelem, long nelements, > DTYPE *array,
       char *nularray, int *anynul, int *status)
\end{verbatim}

\begin{description}
\item[3 ] Get an arbitrary data subsection from an N-dimensional array
    in a binary table vector column.  Undefined pixels
    in the array will be set equal to the value of 'nulval',
    unless nulval=0 in which case no testing for undefined pixels will
    be performed.  The first and last rows in the table to be read
    are specified by fpixels(naxis+1) and lpixels(naxis+1), and hence
    are treated as the next higher dimension of the FITS N-dimensional
    array.  The INC parameter specifies the sampling interval in
   each dimension between the data elements that will be returned.
\end{description}

\begin{verbatim}
  int fits_read_subset_[byt, sht, lng, flt, dbl] / ffgsv[bijed]
      (fitsfile *fptr, int colnum, int naxis, long *naxes, long *fpixels,
       long *lpixels, long *inc, DTYPE nulval, > DTYPE *array, int *anynul,
       int *status)
\end{verbatim}

\begin{description}
\item[4 ] Get an arbitrary data subsection from an N-dimensional array
    in a binary table vector column.  Any Undefined
    pixels in the array will have the corresponding 'nularray'
    element set equal to TRUE.  The first and last rows in the table
    to be read are specified by fpixels(naxis+1) and lpixels(naxis+1),
    and hence are treated as the next higher dimension of the FITS
    N-dimensional array.  The INC parameter specifies the sampling
    interval in each dimension between the data elements that will be
   returned.
\end{description}

\begin{verbatim}
  int fits_read_subsetnull_[byt, sht, lng, flt, dbl] / ffgsf[bijed]
      (fitsfile *fptr, int colnum, int naxis, long *naxes,
       long *fpixels, long *lpixels, long *inc, > DTYPE *array,
       char *nularray, int *anynul, int *status)
\end{verbatim}

\begin{description}
\item[5 ] Get bit values from a byte ('B') or bit (`X`) table column (in the
    CDU).  Larray is an array of logical values corresponding to the
    sequence of bits to be read.  If larray is true then the
    corresponding bit was set to 1, otherwise the bit was set to 0.
    Note that in the case of 'X' columns, CFITSIO can read  all 8 bits
    of each byte whether they are formally valid or not.  Thus if the
    column is defined as '4X', and one calls ffgcx with  firstbit=1 and
    nbits=8, then all 8 bits will be read from the first byte (as
    opposed to reading the first 4 bits from the first row and then the
    first 4 bits from the next row), even though the last 4 bits of
   each byte are formally not defined.
\end{description}

\begin{verbatim}
  int fits_read_col_bit / ffgcx
      (fitsfile *fptr, int colnum, long firstrow, long firstbit,
       long nbits, > char *larray, int *status)
\end{verbatim}

\begin{description}
\item[6 ] Get the descriptor for a variable length column in a binary table.
    The descriptor consists of 2 integer parameters: the number of elements
   in the array and the starting offset relative to the start of the heap.
\end{description}

\begin{verbatim}
  int fits_read_descript / ffgdes
      (fitsfile *fptr, int colnum, long rownum, > long *repeat,
           long *offset, int *status)
\end{verbatim}


\section{Celestial Coordinate System Routines \label{FFGICS}}

The following routines are provided to help calculate the
transformation between pixel location in an image and the corresponding
celestial coordinates on the sky.  These support the following standard
map projections:  -SIN, -TAN, -ARC, -NCP, -GLS, -MER, and -AIT (these
are the legal values for the coordtype parameter).  These routines are
based on similar functions in Classic AIPS.  All the angular quantities
are given in units of degrees. (Note: these routines are provisional
and may change slightly in a future release of CFITSIO).


\begin{description}
\item[1 ] Get the values of all the standard FITS celestial coordinate system
    keywords from the header of a FITS image (i.e., the primary array or
    an image extension).  These values may then be passed to the routines
   that perform the coordinate transformations.
\end{description}

\begin{verbatim}
       Not yet implemented
\end{verbatim}

\begin{description}
\item[2 ] Get the values of all the standard FITS celestial coordinate system
    keywords from the header of a FITS table where the X and Y (or RA and
    DEC coordinates are stored in 2 separate columns of the table.
    These values may then be passed to the routines that perform the
   coordinate transformations.
\end{description}

\begin{verbatim}
       Not yet implemented
\end{verbatim}

\begin{description}
\item[3 ]  Calculate the celestial coordinate corresponding to the input
    X and Y pixel location in the image.
\end{description}

\begin{verbatim}
       Not yet implemented
\end{verbatim}

\begin{description}
\item[4 ]  Calculate the X and Y pixel location corresponding to the input
    celestial coordinate in the image.
\end{description}

\begin{verbatim}
       Not yet implemented
\end{verbatim}


\section{File Checksum Routines \label{FFPCKS}}

The following routines either compute or validate the checksums for the
CHDU.  The DATASUM keyword is used to store the numerical value of the
32-bit, 1's complement checksum for the data unit alone.  If there is
no data unit then the value is set to zero. The numerical value is
stored as an ASCII string of digits, enclosed in quotes, because the
value may be too large to represent as a 32-bit signed integer.  The
CHECKSUM keyword is used to store the ASCII encoded COMPLEMENT of the
checksum for the entire HDU.  Storing the complement, rather than the
actual checksum, forces the checksum for the whole HDU to equal zero.
If the file has been modified since the checksums were computed, then
the HDU checksum will usually not equal zero.  These checksum keyword
conventions are based on a paper by Rob Seaman published in the
proceedings of the ADASS IV conference in Baltimore in November 1994
and a later revision in June 1995.


\begin{description}
\item[1 ] Compute and write the DATASUM and CHECKSUM keyword values for the CHDU
    into the current header.  If the keywords already exist, their values
    will be updated only if necessary (i.e., if the file
    has been modified since the original keyword
   values were computed).
\end{description}

\begin{verbatim}
  int fits_write_chksum / ffpcks
      (fitsfile *fptr, > int *status)
\end{verbatim}

\begin{description}
\item[2 ] Update the CHECKSUM keyword value in the CHDU, assuming that the
    DATASUM keyword exists and already has the correct value.  This routine
    calculates the new checksum for the current header unit, adds it to the
    data unit checksum, encodes the value into an ASCII string, and writes
   the string to the CHECKSUM keyword.
\end{description}

\begin{verbatim}
  int fits_update_chksum / ffupck
      (fitsfile *fptr, > int *status)
\end{verbatim}

\begin{description}
\item[3 ] Verify the CHDU by computing the checksums and comparing
    them with the keywords.  The data unit is verified correctly
    if the computed checksum equals the value of the DATASUM
    keyword.  The checksum for the entire HDU (header plus data unit) is
    correct if it equals zero.  The output DATAOK and HDUOK parameters
    in this routine are integers which will have a value = 1
    if the data or HDU is verified correctly, a value = 0
    if the DATASUM or CHECKSUM keyword is not present, or value = -1
   if the computed checksum is not correct.
\end{description}

\begin{verbatim}
  int fits_verify_chksum / ffvcks
      (fitsfile *fptr, > int *dataok, int *hduok, int *status)
\end{verbatim}

\begin{description}
\item[4 ] Compute and return the checksum values for the CHDU (as
    double precision variables) without creating or modifying the
    CHECKSUM and DATASUM keywords.  This routine is used internally by
   ffvcks, but may be useful in other situations as well.
\end{description}

\begin{verbatim}
  int fits_get_chksum/ /ffgcks
      (fitsfile *fptr, > unsigned long *datasum, unsigned long *hdusum,
       int *status)
\end{verbatim}

\begin{description}
\item[5 ] Encode a checksum value (stored in a double precision variable)
    into a 16-character string.  If COMPLEMENT = .true. then the 32-bit
   sum value will be complemented before encoding.
\end{description}

\begin{verbatim}
  int fits_encode_chksum / ffesum
      (unsigned long sum, int complm, > char *ascii);
\end{verbatim}

\begin{description}
\item[6 ] Decode a 16-character checksum string into a unsigned long value.
    If COMPLEMENT = .true. then the 32-bit sum value will be complemented
    after decoding.  The checksum value is also returned as the
   value of the function.
\end{description}

\begin{verbatim}
  unsigned long fits_decode_chksum / ffdsum
           (char *ascii, int complm, > unsigned long *sum);
\end{verbatim}


\section{General Utility Routines \label{FFVERS}}

The following utility routines may be useful for certain applications:


\begin{description}
\item[1 ] Return the revision number of the fitsio library.
    This routine returns the current revision number of the CFITSIO
    software library.  The revision number will be incremented whenever any
   modifications or enhancements are made to the code.
\end{description}

\begin{verbatim}
 float fits_get_version ffvers
       ( > float *version)
\end{verbatim}

\begin{description}
\item[2 ] Return the starting byte address of the CHDU and the next HDU.
\end{description}

\begin{verbatim}
  void fits_get_hduaddr / ffghad
       (fitsfile *fptr, > long *chduaddr, long *nextaddr)
\end{verbatim}

\begin{description}
\item[3 ] Return a descriptive text string corresponding to a CFITSIO error
    status code.   The 30-character length string contains a brief
   description of the cause of the error.
\end{description}

\begin{verbatim}
 void fits_get_errstatus / ffgerr (int status, > char *err_text)
\end{verbatim}

\begin{description}
\item[4 ] Return the top (oldest) 80-character error message from the
    internal CFITSIO stack of error messages and shift any remaining
    messages on the stack up one level.  Any CFITSIO error will
    generate one or more messages on the stack.  Call this routine
    repeatedly to get each message in sequence.  The error stack is empty
   when a blank string is returned or the routine returns a value of zero.
\end{description}

\begin{verbatim}
  int fits_read_errmsg / ffgmsg (char *err_msg)
\end{verbatim}

\begin{description}
\item[5 ] Write an 80-character message to the CFITSIO error stack.  Application
    programs should not normally write to the stack, but there may be
   some situations where this is desirable.
\end{description}

\begin{verbatim}
  void fits_write_errmsg / ffpmsg (char *err_msg)
\end{verbatim}

\begin{description}
\item[6 ]  Clear the entire error message stack.  This routine is useful
     to clear any error message that may have been generated by
     a non-fatal CFITSIO error (such as failing to find an optional
    header keyword).  This routine is called without any arguments.
\end{description}

\begin{verbatim}
  void fits_clear_errmsg / ffcmsg (void)
\end{verbatim}

\begin{description}
\item[7 ] Convert a character string to uppercase (operates in place).
\end{description}

\begin{verbatim}
  void fits_uppercase / ffupch (char *string)
\end{verbatim}

\begin{description}
\item[8 ]  Compare the input template string against the reference string
    to see if they match.  The template string may contain wildcard
    characters: '*' will match any sequence of characters (including
    zero characters) and '%' will match any single character in the
    reference string.  If CASESN = .true. then the match will be
    case sensitive.  The returned MATCH parameter will be .true. if
    the 2 strings match, and EXACT will be .true. if the match is
    exact (i.e., if no wildcard characters were used in the match).
   Both strings must be 68 characters or less in length.
\end{description}

\begin{verbatim}
  void fits_compare_str / ffcmps
       (char *templt, char *string, int casesen, > int *match, int *exact)
\end{verbatim}


\begin{description}
\item[9 ] Test that the keyword name contains only legal characters: A-Z,0-9,
   hyphen, and underscore.
\end{description}

\begin{verbatim}
  int fits_test_keyword / fftkey (char *keyname, > int *status)
\end{verbatim}

\begin{description}
\item[10] Parse a header keyword record.
    This routine parses the input header record to return the value (as
    a character string) and comment strings.  If the keyword has no
    value (columns 9-10 not equal to '= '), then the value string is returned
    blank and the comment string is set equal to column 9 - 80 of the
   input string.
\end{description}

\begin{verbatim}
  int fits_parse_value / ffpsvc
      (char *card, > char *value, char *comment, int *status)
\end{verbatim}

\begin{description}
\item[11] Construct a sequence keyword name (ROOT + nnn).
    This routine appends the sequence number to the root string to create
   a keyword name (e.g., 'NAXIS' + 2 = 'NAXIS2')
\end{description}

\begin{verbatim}
  int fits_make_keyn / ffkeyn
      (char *keyroot, int value, > char *keyname, int *status)
\end{verbatim}

\begin{description}
\item[12] Construct a sequence keyword name (n + ROOT).
    This routine concatenates the sequence number to the front of the
   root string to create a keyword name (e.g., 1 + 'CTYP' = '1CTYP')
\end{description}

\begin{verbatim}
  int fits_make_nkey / ffnkey
      (int value, char *keyroot, > char *keyname, int *status)
\end{verbatim}

\begin{description}
\item[13] Determine the datatype of a keyword value string.
    This routine parses the keyword value string (usually columns 11-30
   of the header record) to determine its datatype.
\end{description}

\begin{verbatim}
  int fits_get_keytype / ffdtyp
      (char *value, > char *dtype, int *status)
\end{verbatim}

\begin{description}
\item[14] Parse the 'TFORM' binary table column format string.
    This routine parses the input TFORM character string and returns the
    integer datatype code, the repeat count of the field, and, in the case
    of character string fields, the length of the unit string.  The following
   datatype codes are used:
\end{description}

\begin{verbatim}
                Datatype                typecode value
                bit, X                   1
                byte, B                 11
                logical, L              14
                ASCII character, A      16
                short integer, I        21
                integer, J              41
                real, E                 42
                double precision, D     82
                complex, C              83
                double complex, M      163

   int fits_binary_tform / ffbnfm
       (char *tform, > int *typecode, long *repeat, long *width,
        int *status)
\end{verbatim}

\begin{description}
\item[15] Parse the 'TFORM' keyword value that defines the column format in
    an ASCII table.  This routine parses the input TFORM character
    string and returns the datatype code, the width of the column,
    and (if it is a floating point column) the number of decimal places
    to the right of the decimal point.  The returned datatype codes are
    the same as for the binary table, listed above, with the following
    additional rules:  integer columns that are between 1 and 4 characters
    wide are defined to be short integers (code = 21).  Wider integer
    columns are defined to be regular integers (code = 41).  Similarly,
    Fixed decimal point columns (with TFORM = 'Fw.d') are defined to
    be single precision reals (code = 42) if w is between 1 and 7 characters
    wide, inclusive.  Wider 'F' columns will return a double precision
    data code (= 82).  'Ew.d' format columns will have datacode = 42,
   and 'Dw.d' format columns will have datacode = 82.
\end{description}

\begin{verbatim}
  int fits_ascii_tform / ffasfm
      (char *tform, > int *typecode, long *width, int *decimals,
       int *status)
\end{verbatim}

\begin{description}
\item[16] Calculate the starting column positions and total ASCII table width
    based on the input array of ASCII table TFORM values.  The SPACE input
    parameter defines how many blank spaces to leave between each column
    (it is recommended to have one space between columns for better human
   readability).
\end{description}

\begin{verbatim}
  int fits_get_tbcol / ffgabc
      (int tfields, char **tform, int space, > long *rowlen,
       long *tbcol, int *status)
\end{verbatim}

\begin{description}
\item[17] Parse a template string and return a formatted 80-character string
    suitable for appending to (or deleting from) a FITS header file.
    This routine is useful for parsing lines from an ASCII template file
    and reformatting them into legal FITS header records.  The formatted
    string may then be passed to the ffprec, ffmcrd, or ffdkey routines
   to append or modify a FITS header record.
\end{description}

\begin{verbatim}
  int fits_parse_template / ffgthd
      (char *templt, > char *card, int *keytype, int *status)
\end{verbatim}
    The input templt character string generally should contain 3 tokens:
    (1) the KEYNAME, (2) the VALUE, and (3) the COMMENT string.  The
    TEMPLATE string must adhere to the following format:


\begin{description}
\item[- ]     The KEYNAME token must begin in columns 1-8 and be a maximum  of 8
        characters long.  If the first 8 characters of the template line are
        blank then the remainder of the line is considered to be a FITS comment
        (with a blank keyword name).  A legal FITS keyword name may only
        contain the characters A-Z, 0-9, and '-' (minus sign) and
        underscore.  This routine will automatically convert any lowercase
        characters to uppercase in the output string.  If KEYNAME = 'COMMENT'
        or 'HISTORY' then the remainder of the line is considered to be a FITS
       COMMENT or HISTORY record, respectively.
\end{description}


\begin{description}
\item[- ]     The VALUE token must be separated from the KEYNAME token by one or more
        spaces and/or an '=' character.  The datatype of the VALUE token
        (numeric, logical, or character string) is automatically determined
        and  the output CARD string is formatted accordingly.  The value
        token may be forced to be interpreted as a string (e.g. if it is a
       string of numeric digits) by enclosing it in single quotes.
\end{description}


\begin{description}
\item[- ]     The COMMENT token is optional, but if present must be separated from
        the VALUE token by at least one blank space.  A leading '/' character
        may be used to mark the beginning of the comment field, otherwise the
        comment field begins with the first non-blank character following the
       value token.
\end{description}


\begin{description}
\item[- ]     One exception to the above rules is that if the first non-blank
        character in the template string is a minus sign ('-') followed
        by a single token, or a single token followed by an equal sign,
        then it is interpreted as the name of a keyword which is to be
       deleted from the FITS header.
\end{description}


\begin{description}
\item[- ]     The second exception is that if the template string starts with
        a minus sign and is followed by 2 tokens then the second token
        is interpreted as the new name for the keyword specified by
        first token.  In this case the old keyword name (first token)
        is returned in characters 1-8 of the returned CARD string, and
        the new keyword name (the second token) is returned in characters
        41-48 of the returned CARD string.  These old and new names
        may then be passed to the ffmnam routine which will change
       the keyword name.
\end{description}

    The keytype output parameter indicates how the returned CARD string
    should be interpreted:

\begin{verbatim}
        keytype                  interpretation
        -------          -------------------------------------------------
           -2            Modify the name of the keyword given in CARD(1:8)
                         to the new name given in CARD(41:48)

           -1            CARD(1:8) contains the name of a keyword to be deleted
                         from the FITS header.

            0            append the CARD string to the FITS header if the
                         keyword does not already exist, otherwise update
                         the value/comment if the keyword is already present
                         in the header.

            1            simply append this keyword to the FITS header (CARD
                         is either a HISTORY or COMMENT keyword).

            2            This is a FITS END record; it should not be written
                         to the FITS header because CFITSIO automatically
                         appends the END record when the header is closed.
\end{verbatim}
     EXAMPLES:  The following lines illustrate valid input template strings:

\begin{verbatim}
      INTVAL 7 This is an integer keyword
      RVAL           34.6   /     This is a floating point keyword
      EVAL=-12.45E-03  This is a floating point keyword in exponential notation
      lval F This is a boolean keyword
                  This is a comment keyword with a blank keyword name
      SVAL1 = 'Hello world'   /  this is a string keyword
      SVAL2  '123.5'  this is also a string keyword
      sval3  123+  /  this is also a string keyword with the value '123+    '
      # the following template line deletes the DATE keyword
      - DATE
      # the following template line modifies the NAME keyword to OBJECT
      - NAME OBJECT
\end{verbatim}

\chapter{   Summary of all CFITSIO User-Interface Routines }

 FITS File Open and Close Routines: page~\pageref{FFOPEN}

\begin{verbatim}
  int ffopen(fitsfile **fptr, char *filename, int iomode, > int *status)
  int ffinit(fitsfile **fptr, char *filename, > int *status)
  int ffflus(fitsfile *fptr, > int *status)
  int ffclos(fitsfile *fptr, > int *status)
  int ffdelt(fitsfile *fptr, > int *status)
\end{verbatim}
 HDU-Level Operations: page~\pageref{FFMAHD}

\begin{verbatim}
  int ffmahd(fitsfile *fptr, int hdunum, > int *hdutype, int *status)
  int ffmrhd(fitsfile *fptr, int nmove, > int *hdutype, int *status)
  int ffghdn(fitsfile *fptr, > int *hdunum)
  int ffcrim(fitsfile *fptr, int bitpix, int naxis, long *naxes, > int *status)
  int ffcrtb(fitsfile *fptr, int tbltype, long naxis2, int tfields,
      char **ttype, char **tform, char **tunit, char *extname, int *status)
  int ffcrhd(fitsfile *fptr, > int *status)
  int ffiimg(fitsfile *fptr, int bitpix, int naxis, long *naxes, > int *status)
  int ffitab(fitsfile *fptr, long rowlen, long nrows, int tfields, char **ttype,
         long *tbcol, char **tform, char **tunit, char *extname, > int *status)
  int ffibin(fitsfile *fptr, long nrows, int tfields, char **ttype,
       char **tform, char **tunit, char *extname, long pcount, > int *status)
  int ffdhdu(fitsfile *fptr, > int *hdutype, int *status)
  int ffcopy(fitsfile *infptr, fitsfile *outfptr, int morekeys, > int *status)
  int ffcpdt(fitsfile *infptr, fitsfile *outfptr, > int *status)
  int ffrdef(fitsfile *fptr, > int *status)   (DEPRECATED)
\end{verbatim}
 Header Space and Position Routines: page~\pageref{FFHDEF}

\begin{verbatim}
  int ffhdef(fitsfile *fptr, int morekeys, > int *status)
  int ffghsp(fitsfile *fptr, > int *keysexist, int *morekeys, int *status)
  int ffghps(fitsfile *fptr, > int *keysexist, int *keynum, int *status)
\end{verbatim}
 Read or Write Standard Header Routines: page~\pageref{FFPHPS}

\begin{verbatim}
  int ffphps( fitsfile *fptr, int bitpix, int naxis, long *naxes, > int *status)
  int ffphpr( fitsfile *fptr, int simple, int bitpix, int naxis, long *naxes,
            long pcount, long gcount, int extend, > int *status)
  int ffghpr(fitsfile *fptr, int maxdim, > int *simple, int *bitpix, int *naxis,
          long *naxes, long *pcount, long *gcount, int *extend, int *status)
  int ffphtb(fitsfile *fptr, long rowlen, long nrows, int tfields, char **ttype,
          long *tbcol, char **tform, char **tunit, char *extname, > int *status)
  int ffghtb(fitsfile *fptr,int maxdim, > long *rowlen, long *nrows,
           int *tfields, char **ttype, long *tbcol, char **tform, char **tunit,
           char *extname,  int *status)
  int ffphbn(fitsfile *fptr, long nrows, int tfields, char **ttype,
          char **tform, char **tunit, char *extname, long pcount, > int *status)
  int ffghbn(fitsfile *fptr, int maxdim, > long *nrows, int *tfields,
           char **ttype, char **tform, char **tunit, char *extname,
           long *pcount, int *status)
\end{verbatim}
 Write Keyword Routines: page~\pageref{FFPREC}

\begin{verbatim}
  int ffprec(fitsfile *fptr, char *card, > int *status)
  int ffpcom(fitsfile *fptr, char *comment, > int *status)
  int ffphis(fitsfile *fptr, char *history, > int *status)
  int ffpdat(fitsfile *fptr, > int *status)
  int ffpky(fitsfile *fptr, int datatype, char *keyname, void *value,
          char *comment, > int *status)
  int ffpkys(fitsfile *fptr, char *keyname, char *value, char *comment,
             > int *status)
  int ffpky[lj](fitsfile *fptr, char *keyname, DTYPE numval, char *comment,
                 > int *status)
  int ffpky[edfg](fitsfile *fptr, char *keyname, DTYPE numval, int decimals,
                  char *comment, > int *status)
  int ffpkls(fitsfile *fptr, char *keyname, char *longstr,
             char *comment, > int *status)
  int ffplsw(fitsfile *fptr, > int *status)
  int ffpkns(fitsfile *fptr, char *keyroot, int nstart, int nkeys,
             char **value, char **comment, > int *status)
  int ffpkn[lj](fitsfile *fptr, char *keyroot, int nstart, int nkeys,
             DTYPE *numval, char **comment, int *status)
  int ffpkne[edfg](fitsfile *fptr, char *keyroot, int nstart, int nkey,
                DTYPE *numval, int decimals, char **comment, > int *status)
  int ffpkyt(fitsfile *fptr, char *keyname, long intval, double frac,
             char *comment, > int *status)
\end{verbatim}
 Insert Keyword Routines: page~\pageref{FFIREC}

\begin{verbatim}
  int ffirec(fitsfile *fptr, int keynum, char *card, > int *status)
  int ffikys(fitsfile *fptr, char *keyname, char *value, char *comment,
             > int *status)
  int ffiky[lj](fitsfile *fptr, char *keyname, DTYPE numval, char *comment,
              > int *status)
  int ffiky[edfg](fitsfile *fptr, char *keyname, DTYPE numval, int decimals,
                  char *comment, > int *status)
\end{verbatim}
 Read Keyword Routines: page~\pageref{FFGREC}

\begin{verbatim}
  int ffgrec(fitsfile *fptr, int keynum, > char *card, int *status)
  int ffgkyn(fitsfile *fptr, int keynum, > char *keyname, char *value,
             char *comment, int *status)
  int ffgcrd(fitsfile *fptr, char *keyname, > char *card, int *status)
  int ffgkey(fitsfile *fptr, char *keyname, > char *value, char *comment,
           int *status)
  int ffgky(fitsfile *fptr, int datatype, char *keyname, > void *value,
       char *comment, int *status)
  int ffgkys(fitsfile *fptr, char *keyname, > char *value, char *comment,
             int *status);
  int ffgkls(fitsfile *fptr, char *keyname, > char **longstr, char *comment,
             int *status)
  int ffgky[ljed](fitsfile *fptr, char *keyname, > DTYPE *numval, char *comment,
             int *status)
  int ffgkns(fitsfile *fptr, char *keyname, int nstart, int nkeys,
             > char **value, int *nfound,  int *status)
  int ffgkn[ljed](fitsfile *fptr, char *keyname, int nstart, int nkeys,
                  > DTYPE *numval, int *nfound, int *status)
  int ffgkyt(fitsfile *fptr, char *keyname, > long *intval, double *frac,
             char *comment, int *status)
\end{verbatim}
 Modify Keyword Routines: page~\pageref{FFMREC}

\begin{verbatim}
  int ffmrec(fitsfile *fptr, int keynum, char *card, > int *status)
  int ffmcrd(fitsfile *fptr, char *keyname, char *card, > int *status)
  int ffmnam(fitsfile *fptr, char *oldname, char *newname, > int *status)
  int ffmcom(fitsfile *fptr, char *keyname, char *comment, > int *status)
  int ffmkys(fitsfile *fptr, char *keyname, char *value, char *comment,
             > int *status);
  int ffmky[lj](fitsfile *fptr, char *keyname, DTYPE numval, char *comment,
               > int *status)
  int ffmky[edfg](fitsfile *fptr, char *keyname, DTYPE numval, int decimals,
                  char *comment, > int *status)
\end{verbatim}
 Update Keyword Routines: page~\pageref{FFUCRD}

\begin{verbatim}
  int ffucrd(fitsfile *fptr, char *keyname, char *card, > int *status)
  int ffukys(fitsfile *fptr, char *keyname, char *value, char *comment,
             > int *status)
  int ffuky[lj](fitsfile *fptr, char *keyname, DTYPE numval, char *comment,
               > int *status)
  int ffuky[edfg](fitsfile *fptr, char *keyname, DTYPE numval, int decimals,
                  char *comment, > int *status)
\end{verbatim}
 Delete Keyword Routines: page~\pageref{FFDREC}

\begin{verbatim}
  int ffdrec(fitsfile *fptr, int   keynum,  > int *status)
  int ffdkey(fitsfile *fptr, char *keyname, > int *status)
\end{verbatim}
 Define Data Scaling Parameters and Undefined Pixel Flags: page~\pageref{FFPSCL}

\begin{verbatim}
  int ffpscl(fitsfile *fptr, double scale, double zero, > int *status)
  int fftscl(fitsfile *fptr, int colnum, double scale, double zero,
             > int *status)
  int ffpnul(fitsfile *fptr, long nulval, > int *status)
  int ffsnul(fitsfile *fptr, int colnum, char *nulstr, > int *status)
  int fftnul(fitsfile *fptr, int colnum, long nulval, > int *status)
\end{verbatim}
 Write Image Data Routines: page~\pageref{FFPPR}

\begin{verbatim}
  int ffppr(fitsfile *fptr, int datatype, long firstelem, long nelements,
           void *array, int *status);
  int ffppr[bijed](fitsfile *fptr, long group, long firstelem,
           long nelements, DTYPE *array, > int *status);
  int ffppn[bijed](fitsfile *fptr, long group, long firstelem,
           long nelements, DTYPE *array, DTYPE nulval, > int *status);
  int ffpgp[bijed](fitsfile *fptr, long group, long firstelem, long nelements,
           > DTYPE *array, int *status)
  int ffppru(fitsfile *fptr, long group, long firstelem,
           long nelements, > int *status)
  int ffp2d[bijed](fitsfile *fptr, long group, long dim1, long naxis1,
           long naxis2, DTYPE *array, > int *status)
  int ffp3d[bijed](fitsfile *fptr, long group, long dim1, long dim2,
           long naxis1, long naxis2, long naxis3, DTYPE *array, > int *status)
  int ffpss[bijed](fitsfile *fptr, long group, long naxis, long *naxes,
           long *fpixel, long *lpixel, DTYPE *array, > int *status)
\end{verbatim}
 Read Image Data Routines: page~\pageref{FFGPV}

\begin{verbatim}
  int ffgpv(fitsfile *fptr, int  datatype, long firstelem, long nelements,
           void *nulval, > void *array, int *anynul, int *status)
  int ffgpv[bijed](fitsfile *fptr, long group, long firstelem, long nelements,
           DTYPE nulval, > DTYPE *array, int *anynul, int *status)
  int ffgpf[bijed](fitsfile *fptr, long group, long firstelem, long nelements,
          > DTYPE *array, char *nularray, int *anynul, int *status)
  int ffggp[bijed](fitsfile *fptr, long group, long firstelem, long nelements,
          > DTYPE *array, int *status)
  int ffg2d[bijed](fitsfile *fptr, long group, DTYPE nulval, long dim1,
           long naxis1, long naxis2, > DTYPE *array,
           int *anynul, int *status)
  int ffg3d[bijed](fitsfile *fptr, long group, DTYPE nulval, long dim1,
           long dim2, long naxis1, long naxis2, long naxis3,
           > DTYPE *array, int *anynul, int *status)
  int ffgsv[bijed](fitsfile *fptr, int group, int naxis, long *naxes,
            long *fpixels, long *lpixels, long *inc, DTYPE nulval,
            > DTYPE *array, int *anynul, int *status)
  int ffgsf[bijed](fitsfile *fptr, int group, int naxis, long *naxes,
            long *fpixels, long *lpixels, long *inc, > DTYPE *array,
            char *nularray, int *anynul, int *status)
\end{verbatim}
 Table Column Information Routines: page~\pageref{FFGCNO}

\begin{verbatim}
  int ffgcno(fitsfile *fptr, int casesen, char *templt, > int *colnum,
           int *status)
  int ffgcnn(fitsfile *fptr, int casesen, char *templt, > char *colname,
           int *colnum, int *status)
  int ffgtcl(fitsfile *fptr, int colnum, > int *typecode, long *repeat,
           long *width, int *status)
  int ffgacl(fitsfile *fptr, int colnum, > char *ttype, long *tbcol,
           char *tunit, char *tform, double *scale, double *zero,
           char *nulstr, char *tdisp, int *status)
  int ffgbcl(fitsfile *fptr, int colnum, > char *ttype, char *tunit,
           char *typechar, long *repeat, double *scale, double *zero,
           long *nulval, char *tdisp, int  *status)
  int ffptdm( fitsfile *fptr, int colnum, int naxis, long *naxes,
            >  int *status)
  int ffgtdm(fitsfile *fptr, int colnum, int maxdim, > int *naxis,
           long *naxes, int *status)
\end{verbatim}
 Low-Level Table Access Routines: page~\pageref{FFGTBB}

\begin{verbatim}
  int ffgtbb(fitsfile *fptr, long firstrow, long firstchar, long nchars,
           > unsigned char *values, int *status)
  int ffptbb(fitsfile *fptr, long firstrow, long firstchar, long nchars,
           unsigned char *values, > int *status)
\end{verbatim}
 Insert or Delete Rows and Columns Routines: page~\pageref{FFIROW}

\begin{verbatim}
  int ffirow(fitsfile *fptr, long firstrow, long nrows, > int *status)
  int ffdrow(fitsfile *fptr, long firstrow, long nrows, > int *status)
  int fficol(fitsfile *fptr, int colnum, char *ttype, char *tform,
            > int *status)
  int fficls(fitsfile *fptr, int colnum, int ncols, char **ttype,
           char **tform, > int *status)
  int ffdcol(fitsfile *fptr, int colnum, > int *status)
\end{verbatim}
 Write Column Data Routines: page~\pageref{FFPCLS}

\begin{verbatim}
  int ffpcl(fitsfile *fptr, int datatype, int colnum, long firstrow,
           long firstelem, long nelements, char **array, > int *status)
  int ffpcls(fitsfile *fptr, int colnum, long firstrow, long firstelem,
           long nelements, char **array, > int *status)
  int ffpcl[lbijedcm](fitsfile *fptr, int colnum, long firstrow,
           long firstelem, long nelements, DTYPE *array, > int *status)
  int ffpcn[bijed](fitsfile *fptr, int colnum, long firstrow,
           long firstelem, long nelements, DTYPE *array, DTYPE nulval,
           > int *status)
  int ffpclx(fitsfile *fptr, int colnum, long firstrow, long firstbit,
           long nbits, char *larray, > int *status)
  int ffpclu(fitsfile *fptr, int colnum, long firstrow, long firstelem,
           long nelements, > int *status)
  int ffpdes(fitsfile *fptr, int colnum, long rownum, long repeat,
           long offset, > int *status)
  int ffpthp(fitsfile *fptr, long theap, > int *status)
\end{verbatim}
 Read Column Data Routines: page~\pageref{FFGCL}

\begin{verbatim}
  int ffgcv(fitsfile *fptr, int datatype, int colnum, long firstrow,
           long firstelem, long nelements, void *nulval, void *array,
           int *anynul, int *status)
  int ffgcl (fitsfile *fptr, int colnum, long firstrow, long firstelem,
           long nelements, > char *array, int  *status)
  int ffgcvs(fitsfile *fptr, int colnum, long firstrow, long firstelem,
           long nelements, char *nulstr, > char **array, int *anynul,
           int *status)
  int ffgcv[bijedcm](fitsfile *fptr, int colnum, long firstrow,
           long firstelem, long nelements, DTYPE nulval, > DTYPE *array,
           int *anynul, int *status)
  int ffgcfs(fitsfile *fptr, int colnum, long firstrow, long firstelem,
           long nelements, > char **array, char *nularray, int *anynul,
           int *status)
  int ffgcfl(fitsfile *fptr, int colnum, long firstrow, long firstelem,
           long nelements, > char *array, char *nularray, int *anynul,
           int *status)
  int ffgcf[bijedcm](fitsfile *fptr, int colnum, long firstrow,
           long firstelem, long nelements, > DTYPE *array,
           char *nularray, int *anynul, int *status)
  int ffgsv[bijed](fitsfile *fptr, int colnum, int naxis, long *naxes,
            long *fpixels, long *lpixels, long *inc, DTYPE nulval,
            > DTYPE *array, int *anynul, int *status)
  int ffgsf[bijed](fitsfile *fptr, int colnum, int naxis, long *naxes,
            long *fpixels, long *lpixels, long *inc, > DTYPE *array,
            char *nularray, int *anynul, int *status)
  int ffgcx(fitsfile *fptr, int colnum, long firstrow, long firstbit,
            long nbits, > char *larray, int *status)
  int ffgdes(fitsfile *fptr, int colnum, long rownum, > long *repeat,
           long *offset, int *status)
\end{verbatim}
 Celestial Coordinate System Routines: page~\pageref{FFGICS}

\begin{verbatim}

\end{verbatim}
 File Checksum Routines: page~\pageref{FFPCKS}

\begin{verbatim}
  int ffpcks(fitsfile *fptr, > int *status)
  int ffupck(fitsfile *fptr, > int *status)
  int ffvcks(fitsfile *fptr, > int *dataok, int *hduok, int *status)
  int ffgcks(fitsfile *fptr, > unsigned long *datasum, unsigned long *hdusum,
      int *status)
  int ffesum(unsigned long sum, int complm, > char *ascii)
  unsigned long ffdsum(char *ascii, int complm, > unsigned long *sum)
\end{verbatim}
 General Utility Routines: page~\pageref{FFVERS}

\begin{verbatim}
  float ffvers( > float *version)
  void ffghad(fitsfile *fptr, > long *chduaddr, long *nextaddr)
  void ffgerr(int status, > char *err_text)
  int  ffgmsg(char *err_msg)
  void ffpmsg(char *err_msg)
  void ffcmsg(void)
  void ffupch(char *string)
  void ffcmps(char *templt, char *string, int casesen, > int *match, int *exact)
  int fftkey(char *keyname, > int *status)
  int ffpsvc(char *card, > char *value, char *comment, int *status)
  int ffkeyn(char *keyroot, int value, > char *keyname, int *status)
  int ffnkey(int value, char *keyroot, > char *keyname, int *status)
  int ffdtyp(char *value, > char *dtype, int *status)
  int ffbnfm(char *tform, > int *typecode, long *repeat, long *width,
                int *status)
  int ffasfm(char *tform, > int *typecode, long *width, int *decimals,
             int *status)
  int ffgabc(int tfields, char **tform, int space, > long *rowlen,
            long *tbcol, int *status)
  int ffgthd(char *templt, > char *card, int *keytype, int *status)
\end{verbatim}

\chapter{ Parameter Definitions }

\begin{verbatim}
anynul   - set to TRUE (=1) if any returned values are undefined, else FALSE
array    - array of numerical data values to read or write
ascii    - encoded checksum string
bitpix   - bits per pixel: 8 (unsigned char), 16 (short int),
           32 (long int), -32 (float), or -64 (double)
card     - header record to be read or written (80 char max, null-terminated)
casesen  - TRUE (=1) to force case-sensitive string matching, else FALSE (=0)
colname  - name of the column (null-terminated)
colnum   - column number (first column = 1)
comment  - the keyword comment field (72 char max, null-terminated)
complm   - should the checksum be complemented?
chduaddr - starting address (in bytes) of the CHDU
dataok   - was the data unit verification successful (=1) or
           not (= -1).  Equals zero if the DATASUM keyword is not present.
datasum  - 32-bit 1's complement checksum for the data unit
datatype - specifies the datatype of the value.  Allowed value are:
           TSTRING, TLOGICAL, TBYTE, TSHORT, TINT, TLONG, TFLOAT, TDOUBLE
decimals - number of decimal places to be displayed
dim1     - declared size of the first dimension of the image or cube array
dim2     - declared size of the second dimension of the data cube array
dtype    - datatype of the keyword ('C', 'L', 'I',  or 'F')
                C = character string
                L = logical
                I = integer
                F = floating point number
err_msg  - error message on the internal stack (80 chars max)
err_text - error message string corresponding to error number (30 chars max)
exact    - TRUE (=1) if the strings match exactly;
           FALSE (=0) if wildcards are used
extend   - TRUE (=1) if FITS file may have extensions, else FALSE (=0)
extname  - value of the EXTNAME keyword (null-terminated)
filename - name of the FITS file (null-terminated)
firstchar- starting byte in the row (first byte of row = 1)
firstelem- first element in a vector (ignored for ASCII tables)
firstrow - starting row number (first row of table = 1)
fpixels  - the first included pixel in each dimension (first pixel = 1)
fptr     - pointer to a 'fitsfile' structure describing the FITS file.
frac     - factional part of the keyword value
gcount   - number of groups in the primary array (usually = 1)
group    - data group number (=0 for non-grouped data)
hdunum   - sequence number of the HDU (Primary array = 1)
hduok    - was the HDU verification successful (=1) or
           not (= -1).  Equals zero if the CHECKSUM keyword is not present.
hdusum   - 32 bit 1's complement checksum for the entire CHDU
hdutype  - type of HDU: HDU_IMAGE (=0), HDU_ATABLE (=1), or HDU_BTABLE (=2)
history  - the HISTORY keyword comment string (70 char max, null-terminated)
inc      - sampling interval for pixels in each FITS dimension
infptr   - pointer to a 'fitsfile' structure describing the input FITS file.
intval   - integer part of the keyword value
iomode   - file access mode: either READONLY (=0) or READWRITE (=1)
keyname  - name of a keyword (8 char max, null-terminated)
keynum   - position of keyword in header (1st keyword = 1)
keyroot  - root string for the keyword name (5 char max, null-terminated)
keysexist- number of existing keyword records in the CHU
keytype  - header record type: -1=delete;  0=append or replace;
                   1=append; 2=this is the END keyword
longstr  - arbitrarily long string keyword value (null-terminated)
lpixels  - the last included pixel in each dimension (first pixel = 1)
match    - TRUE (=1) if the 2 strings match, else FALSE (=0)
maxdim   - maximum number of values to return
morekeys - space in the header for this many more keywords
naxes    - size of each dimension in the FITS array
naxis    - number of dimensions in the FITS array
naxis1   - length of the X/first axis of the FITS array
naxis2   - length of the Y/second axis of the FITS array
naxis3   - length of the Z/third axis of the FITS array
nchars   - number of characters to read or write
nelements- number of data elements to read or write
nextaddr - starting address (in bytes) of the HDU following the CHDU
nfound   - number of keywords found (highest keyword number)
nkeys    - number of keywords in the sequence
nmove    - number of HDUs to move (+ or -), relative to current position
nrows    - number of rows in the table
nstart   - first integer value
nularray - set to TRUE (=1) if corresponding data element is undefined
nulval   - numerical value to represent undefined pixels
nulstr   - character string used to represent undefined values in ASCII table
numval   - numerical data value, of the appropriate datatype
offset   -  byte offset in the heap to the first element of the vector
outfptr  - pointer to a 'fitsfile' structure describing the output FITS file.
pcount   - value of the PCOUNT keyword = size of binary table heap
repeat   - length of column vector (e.g. 12J); == 1 for ASCII table
rowlen   - length of a table row, in characters or bytes
rownum   - number of the row (first row = 1)
scale    - linear scaling factor; true value = (FITS value) * scale + zero
simple   - TRUE (=1) if FITS file conforms to the Standard, else FALSE (=0)
space    - number of blank spaces to leave between ASCII table columns
status   - returned error status code (0 = OK)
sum      - 32 bit unsigned checksum value
tbcol    - byte position in row to start of column (1st col has tbcol = 1)
tdisp    - Fortran style display format for the table column
templt   - template string used in comparison (null-terminated)
tfields  - number of fields (columns) in the table
tform    - format of the column (null-terminated); allowed values are:
           ASCII tables:  Iw, Aw, Fww.dd, Eww.dd, or Dww.dd
           binary tables: rL, rX, rB, rI, rJ, rA, rAw, rE, rD, rC, rM
           where 'w'=width of the field, 'd'=no. of decimals, 'r'=repeat count
theap    - zero indexed byte offset of starting address of the heap
           relative to the beginning of the binary table data
ttype    - label or name for table column (null-terminated)
tunit    - physical unit for table column (null-terminated)
typechar - symbolic code of the table column datatype
typecode - datatype code of the table column
                Datatype             typecode
                bit, X                   1
                byte, B                 11
                logical, L              14
                ASCII character, A      16
                short integer, I        21
                integer, J              41
                real, E                 42
                double precision, D     82
                complex, C              83
                double complex, M      163

value    - the keyword value string (70 char max, null-terminated)
version  - current version number of the CFITSIO library
width    - width of the character string field
zero     - scaling offset; true value = (FITS value) * scale + zero
        --------------------------------------------------------------------

coordtype -  type of coordinate projection (-SIN, -TAN, -ARC,
          -NCP, -GLS, -MER, or -AIT)
rot -  celestial coordinate rotation angle (degrees)
xcol -  number of the column containing the X coordinate values
xinc -  X axis coordinate increment at reference pixel (deg)
xpix -  X axis pixel location
xpos -  X axis celestial coordinate (usually RA) (deg)
xrpix -  X axis reference pixel array location
xrval -  X axis coordinate value at the reference pixel (deg)
ycol -  number of the column containing the X coordinate values
yinc -  Y axis coordinate increment at reference pixel (deg)
ypix -  y axis pixel location
ypos -  y axis celestial coordinate (usually DEC) (deg)
yrpix -  Y axis reference pixel array location
yrval -  Y axis coordinate value at the reference pixel (deg)
\end{verbatim}

\chapter{ CFITSIO Error Status Codes }

The following table lists all the error status codes used by CFITSIO.
Programmers are encouraged to use the symbolic  mnemonics (defined in
the file fitsio.h) rather than the actual integer status values to
improve the readability of their code.

\begin{verbatim}
 Symbolic Const    Value     Meaning
 --------------    -----  -----------------------------------------
 SAME_FILE         101    input and output files are the same
 FILE_NOT_OPENED   104    could not open the named file
 FILE_NOT_CREATED  105    could not create the named file
 WRITE_ERROR       106    error writing to FITS file
 END_OF_FILE       107    tried to move past end of file
 READ_ERROR        108    error reading from FITS file
 FILE_NOT_CLOSED   110    could not close the file
 ARRAY_TOO_BIG     111    array dimensions exceed internal limit
 READONLY_FILE     112    Cannot write to readonly file
 HEADER_NOT_EMPTY  201    header already contains keywords
 KEY_NO_EXIST      202    keyword not found in header
 KEY_OUT_BOUNDS    203    keyword record number is out of bounds
 NO_VALUE          204    keyword value field is blank
 NO_QUOTE          205    string is missing the closing quote
 BAD_KEYCHAR       207    illegal character in keyword name or card
 BAD_ORDER         208    required keywords out of order
 NOT_POS_INT       209    keyword value is not a positive integer
 NO_END            210    couldn't find END keyword
 BAD_BITPIX        211    illegal BITPIX keyword value
 BAD_NAXIS         212    illegal NAXIS keyword value
 BAD_NAXES         213    illegal NAXISn keyword value
 BAD_PCOUNT        214    illegal PCOUNT keyword value
 BAD_GCOUNT        215    illegal GCOUNT keyword value
 BAD_TFIELDS       216    illegal TFIELDS keyword value
 NEG_WIDTH         217    negative table row size
 NEG_ROWS          218    negative number of rows in table
 COL_NOT_FOUND     219    column with this name not found in table
 BAD_SIMPLE        220    illegal value of SIMPLE keyword
 NO_SIMPLE         221    Primary array doesn't start with SIMPLE
 NO_BITPIX         222    Second keyword not BITPIX
 NO_NAXIS          223    Third keyword not NAXIS
 NO_NAXES          224    Couldn't find all the NAXISn keywords
 NO_XTENSION       225    HDU doesn't start with XTENSION keyword
 NOT_ATABLE        226    the CHDU is not an ASCII table extension
 NOT_BTABLE        227    the CHDU is not a binary table extension
 NO_PCOUNT         228    couldn't find PCOUNT keyword
 NO_GCOUNT         229    couldn't find GCOUNT keyword
 NO_TFIELDS        230    couldn't find TFIELDS keyword
 NO_TBCOL          231    couldn't find TBCOLn keyword
 NO_TFORM          232    couldn't find TFORMn keyword
 NOT_IMAGE         233    the CHDU is not an IMAGE extension
 BAD_TBCOL         234    TBCOLn keyword value < 0 or > rowlength
 NOT_TABLE         235    the CHDU is not a table
 COL_TOO_WIDE      236    column is too wide to fit in table
 COL_NOT_UNIQUE    237    more than 1 column name matches template
 BAD_ROW_WIDTH     241    sum of column widths not = NAXIS1
 UNKNOWN_EXT       251    unrecognizable FITS extension type
 UNKNOWN_REC       252    unrecognizable FITS record
 END_JUNK          253    END keyword is not blank
 BAD_TFORM         261    illegal TFORM format code
 BAD_TFORM_DTYPE   262    unrecognizable TFORM datatype code
 BAD_TDIM          263    illegal TDIMn keyword value

 BAD_HDU_NUM       301    HDU number < 1 or > MAXHDU
 BAD_COL_NUM       302    column number < 1 or > tfields
 NEG_FILE_POS      304    tried to move to negative byte location in file
 NEG_BYTES         306    tried to read or write negative number of bytes
 BAD_ROW_NUM       307    illegal starting row number in table
 BAD_ELEM_NUM      308    illegal starting element number in vector
 NOT_ASCII_COL     309    this is not an ASCII string column
 NOT_LOGICAL_COL   310    this is not a logical datatype column
 BAD_ATABLE_FORMAT 311    ASCII table column has wrong format
 BAD_BTABLE_FORMAT 312    Binary table column has wrong format
 NO_NULL           314    null value has not been defined
 NOT_VARI_LEN      317    this is not a variable length column
 BAD_DIMEN         320    illegal number of dimensions in array
 BAD_PIX_NUM       321    first pixel number greater than last pixel
 ZERO_SCALE        322    illegal BSCALE or TSCALn keyword = 0
 NEG_AXIS          323    illegal axis length < 1

 BAD_I2C           401    bad int to formatted string conversion
 BAD_F2C           402    bad float to formatted string conversion
 BAD_INTKEY        403    can't interprete keyword value as integer
 BAD_LOGICALKEY    404    can't interprete keyword value as logical
 BAD_FLOATKEY      405    can't interprete keyword value as float
 BAD_DOUBLEKEY     406    can't interprete keyword value as double
 BAD_C2I           407    bad formatted string to int conversion
 BAD_C2F           408    bad formatted string to float conversion
 BAD_C2D           409    bad formatted string to double conversion
 BAD_DATATYPE      410    illegal datatype code value
 BAD_DECIM         411    bad number of decimal places specified
 NUM_OVERFLOW      412    overflow during datatype conversion
\end{verbatim}
\end{document}

