
/*  A Bison parser, made from eval.y
 by  GNU Bison version 1.25
  */

#define FFBISON 1  /* Identify Bison output.  */

#define	REAL	258
#define	REALV	259
#define	INTEGER	260
#define	INTEGERV	261
#define	BOOLEAN	262
#define	BOOLEANV	263
#define	STRING	264
#define	BITSTR	265
#define	FUNCTION	266
#define	IFUNCTION	267
#define	RFUNCTION	268
#define	BFUNCTION	269
#define	OR	270
#define	AND	271
#define	EQ	272
#define	NE	273
#define	GT	274
#define	LT	275
#define	LTE	276
#define	GTE	277
#define	POWER	278
#define	NOT	279
#define	INTCAST	280
#define	FLTCAST	281
#define	UMINUS	282

#line 1 "eval.y"

#define  APPROX 1.0e-7
#include "eval_defs.h"

#define LESSTHAN	1
#define LESSTHANEQ	2
#define GREATERTHAN	3
#define GREATERTHANEQ	4

/***************************************************************/
/*  Replace Bison's BACKUP macro with one that fixes a bug --  */
/*  must update state after popping the stack -- and allows    */
/*  popping multiple terms at one time.                        */
/***************************************************************/

#define FFNEWBACKUP(token, value) \
do								\
  if (ffchar == FFEMPTY )   					\
    { ffchar = (token);                                         \
      memcpy( &fflval, &(value), sizeof(value) );               \
      ffchar1 = FFTRANSLATE (ffchar);				\
      while (fflen--) FFPOPSTACK;				\
      ffstate = *ffssp;						\
      goto ffbackup;						\
    }								\
  else								\
    { fferror ("syntax error: cannot back up"); FFERROR; }	\
while (0)

/*****  Internal functions  *****/

#ifdef __cplusplus
extern "C" {
#endif

void  fferror(char *msg);

static char  saobox (double xcen, double ycen, double xrad, double yrad,
		     double rot, double xcol, double ycol);
static char  ellipse(double xcen, double ycen, double xrad, double yrad,
		     double rot, double xcol, double ycol);
static char  circle (double xcen, double ycen, double rad,
		     double xcol, double ycol);
static char  near   (double x, double y, double tolerance);
static char  bitcmp (char *bitstrm1, char *bitstrm2);
static char  bitlgte(char *bits1, int oper, char *bits2);

static void  bitand(char *result, char *bitstrm1, char *bitstrm2);
static void  bitor (char *result, char *bitstrm1, char *bitstrm2);
static void  bitnot(char *result, char *bits);

static ivec  CastBvecToIvec(bvec vector);
static rvec  CastBvecToRvec(bvec vector);
static rvec  CastIvecToRvec(ivec vector);

static int   scalarOPivec(void *result, int scalar, int op, ivec vector);
static int   ivecOPivec  (void *result, ivec vec1, int op, ivec vec2);
static int   scalarOPrvec(void *result, double scalar, int op, rvec vector);
static int   rvecOPrvec  (void *result, rvec vec1, int op, rvec vec2);

#ifdef __cplusplus
    }
#endif


#line 67 "eval.y"
typedef union {
    double real;           /* real value */
    long   integer;        /* integer value */
    char   boolean;        /* logical value */
    bvec   boolvec;        /* boolean array */
    ivec   intvec;         /* integer array */
    rvec   realvec;        /* real array */
    iseq   intseq;         /* integer sequence */
    rseq   realseq;        /* real sequence */
    char   string[256];    /* string value */
} FFSTYPE;
#include <stdio.h>

#ifndef __cplusplus
#ifndef __STDC__
#define const
#endif
#endif



#define	FFFINAL		428
#define	FFFLAG		-32768
#define	FFNTBASE	44

#define FFTRANSLATE(x) ((unsigned)(x) <= 282 ? fftranslate[x] : 56)

static const char fftranslate[] = {     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,    40,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,    29,    33,     2,    41,
    42,    30,    27,    15,    28,     2,    31,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,    17,     2,     2,
    16,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    39,     2,    43,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,    32,     2,    22,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
     6,     7,     8,     9,    10,    11,    12,    13,    14,    18,
    19,    20,    21,    23,    24,    25,    26,    34,    35,    36,
    37,    38
};

#if FFDEBUG != 0
static const short ffprhs[] = {     0,
     0,     1,     4,     6,     9,    12,    15,    18,    21,    24,
    27,    30,    33,    35,    39,    43,    46,    50,    52,    56,
    60,    64,    68,    72,    76,    79,    83,    87,    91,    95,
    99,   103,   107,   111,   114,   117,   120,   123,   125,   129,
   133,   137,   141,   145,   149,   153,   157,   161,   165,   169,
   173,   177,   181,   185,   189,   193,   197,   201,   205,   209,
   212,   215,   218,   222,   224,   228,   232,   236,   240,   244,
   248,   252,   256,   260,   264,   268,   272,   276,   280,   284,
   288,   292,   296,   300,   304,   308,   312,   316,   320,   324,
   328,   332,   336,   340,   344,   348,   352,   356,   360,   364,
   368,   372,   376,   380,   384,   390,   396,   402,   408,   414,
   420,   426,   432,   436,   439,   442,   446,   448,   452,   456,
   460,   464,   467,   471,   475,   479,   483,   487,   491,   495,
   499,   503,   507,   511,   515,   519,   523,   527,   531,   535,
   539,   543,   547,   551,   555,   559,   563,   567,   571,   575,
   579,   583,   587,   591,   595,   599,   603,   607,   611,   615,
   619,   623,   627,   631,   635,   639,   643,   647,   651,   655,
   659,   663,   667,   671,   675,   679,   683,   687,   691,   695,
   699,   703,   707,   711,   715,   719,   723,   727,   731,   735,
   739,   743,   747,   751,   755,   759,   761,   765,   769,   773,
   777,   781,   785,   789,   793,   797,   801,   805,   809,   813,
   817,   821,   825,   829,   833,   836,   840,   844,   848,   851,
   855,   858,   861,   864,   867,   869,   873,   877,   881,   885,
   889,   893,   897,   901,   905,   909,   913,   917,   921,   925,
   929,   933,   937,   941,   945,   949,   953,   957,   961,   965,
   969,   973,   977,   981,   985,   989,   993,   997,  1001,  1005,
  1009,  1013,  1017,  1021,  1025,  1029,  1033,  1037,  1040,  1043,
  1046,  1050,  1054,  1060,  1068,  1078,  1090,  1094,  1098,  1102,
  1106,  1110,  1112,  1116
};

static const short ffrhs[] = {    -1,
    44,    45,     0,    40,     0,    47,    40,     0,    48,    40,
     0,    49,    40,     0,    50,    40,     0,    51,    40,     0,
    52,    40,     0,    55,    40,     0,    46,    40,     0,     1,
    40,     0,    10,     0,    46,    33,    46,     0,    46,    32,
    46,     0,    35,    46,     0,    41,    46,    42,     0,     5,
     0,    47,    29,    47,     0,    47,    27,    47,     0,    47,
    28,    47,     0,    47,    30,    47,     0,    47,    31,    47,
     0,    47,    34,    47,     0,    28,    47,     0,    41,    47,
    42,     0,    47,    30,    49,     0,    49,    30,    47,     0,
    11,    50,    42,     0,    11,    48,    42,     0,    12,    48,
    42,     0,    12,    52,    42,     0,    12,    50,    42,     0,
    48,    53,     0,    36,    51,     0,    36,    47,     0,    36,
    49,     0,     6,     0,    48,    29,    47,     0,    47,    29,
    48,     0,    48,    29,    48,     0,    48,    27,    47,     0,
    47,    27,    48,     0,    48,    27,    48,     0,    48,    28,
    47,     0,    47,    28,    48,     0,    48,    28,    48,     0,
    48,    30,    47,     0,    47,    30,    48,     0,    48,    30,
    48,     0,    48,    31,    47,     0,    47,    31,    48,     0,
    48,    31,    48,     0,    47,    30,    50,     0,    50,    30,
    47,     0,    48,    30,    50,     0,    50,    30,    48,     0,
    48,    30,    49,     0,    49,    30,    48,     0,    36,    52,
     0,    36,    48,     0,    36,    50,     0,    41,    48,    42,
     0,     7,     0,    46,    20,    46,     0,    46,    21,    46,
     0,    46,    24,    46,     0,    46,    25,    46,     0,    46,
    23,    46,     0,    46,    26,    46,     0,    47,    23,    47,
     0,    47,    24,    47,     0,    47,    26,    47,     0,    47,
    25,    47,     0,    47,    22,    47,     0,    47,    20,    47,
     0,    47,    21,    47,     0,    51,    23,    51,     0,    51,
    24,    51,     0,    51,    26,    51,     0,    51,    25,    51,
     0,    51,    22,    51,     0,    51,    20,    51,     0,    51,
    21,    51,     0,    47,    23,    51,     0,    47,    24,    51,
     0,    47,    26,    51,     0,    47,    25,    51,     0,    47,
    22,    51,     0,    47,    20,    51,     0,    47,    21,    51,
     0,    51,    23,    47,     0,    51,    24,    47,     0,    51,
    26,    47,     0,    51,    25,    47,     0,    51,    22,    47,
     0,    51,    20,    47,     0,    51,    21,    47,     0,    55,
    20,    55,     0,    55,    21,    55,     0,    49,    19,    49,
     0,    49,    18,    49,     0,    49,    20,    49,     0,    49,
    21,    49,     0,    47,    16,    47,    17,    47,     0,    47,
    16,    47,    17,    51,     0,    47,    16,    51,    17,    47,
     0,    47,    16,    51,    17,    51,     0,    51,    16,    47,
    17,    47,     0,    51,    16,    47,    17,    51,     0,    51,
    16,    51,    17,    47,     0,    51,    16,    51,    17,    51,
     0,    14,    54,    42,     0,    50,    53,     0,    35,    49,
     0,    41,    49,    42,     0,     8,     0,    50,    19,    50,
     0,    50,    18,    50,     0,    50,    20,    50,     0,    50,
    21,    50,     0,    35,    50,     0,    48,    20,    47,     0,
    47,    20,    48,     0,    48,    20,    48,     0,    48,    21,
    47,     0,    47,    21,    48,     0,    48,    21,    48,     0,
    48,    23,    47,     0,    47,    23,    48,     0,    48,    23,
    48,     0,    48,    24,    47,     0,    47,    24,    48,     0,
    48,    24,    48,     0,    48,    26,    47,     0,    47,    26,
    48,     0,    48,    26,    48,     0,    48,    25,    47,     0,
    47,    25,    48,     0,    48,    25,    48,     0,    52,    20,
    51,     0,    52,    20,    47,     0,    51,    20,    52,     0,
    47,    20,    52,     0,    48,    20,    51,     0,    51,    20,
    48,     0,    48,    20,    52,     0,    52,    20,    48,     0,
    52,    20,    52,     0,    52,    21,    51,     0,    52,    21,
    47,     0,    51,    21,    52,     0,    47,    21,    52,     0,
    48,    21,    51,     0,    51,    21,    48,     0,    48,    21,
    52,     0,    52,    21,    48,     0,    52,    21,    52,     0,
    52,    23,    51,     0,    52,    23,    47,     0,    51,    23,
    52,     0,    47,    23,    52,     0,    48,    23,    51,     0,
    51,    23,    48,     0,    48,    23,    52,     0,    52,    23,
    48,     0,    52,    23,    52,     0,    52,    24,    51,     0,
    52,    24,    47,     0,    51,    24,    52,     0,    47,    24,
    52,     0,    48,    24,    51,     0,    51,    24,    48,     0,
    48,    24,    52,     0,    52,    24,    48,     0,    52,    24,
    52,     0,    52,    26,    51,     0,    52,    26,    47,     0,
    51,    26,    52,     0,    47,    26,    52,     0,    48,    26,
    51,     0,    51,    26,    48,     0,    48,    26,    52,     0,
    52,    26,    48,     0,    52,    26,    52,     0,    52,    25,
    51,     0,    52,    25,    47,     0,    51,    25,    52,     0,
    47,    25,    52,     0,    48,    25,    51,     0,    51,    25,
    48,     0,    48,    25,    52,     0,    52,    25,    48,     0,
    52,    25,    52,     0,    41,    50,    42,     0,     3,     0,
    51,    27,    51,     0,    51,    28,    51,     0,    51,    30,
    51,     0,    51,    31,    51,     0,    51,    34,    51,     0,
    47,    27,    51,     0,    47,    28,    51,     0,    47,    30,
    51,     0,    47,    31,    51,     0,    47,    34,    51,     0,
    51,    30,    49,     0,    49,    30,    51,     0,    51,    27,
    47,     0,    51,    28,    47,     0,    51,    30,    47,     0,
    51,    31,    47,     0,    51,    34,    47,     0,    11,    52,
    42,     0,    13,    42,     0,    13,    51,    42,     0,    13,
    47,    42,     0,    13,    54,    42,     0,    28,    51,     0,
    41,    51,    42,     0,    52,    53,     0,    37,    47,     0,
    37,    51,     0,    37,    49,     0,     4,     0,    52,    27,
    51,     0,    52,    27,    47,     0,    51,    27,    52,     0,
    47,    27,    52,     0,    48,    27,    51,     0,    51,    27,
    48,     0,    48,    27,    52,     0,    52,    27,    48,     0,
    52,    27,    52,     0,    52,    28,    51,     0,    52,    28,
    47,     0,    51,    28,    52,     0,    47,    28,    52,     0,
    48,    28,    51,     0,    51,    28,    48,     0,    48,    28,
    52,     0,    52,    28,    48,     0,    52,    28,    52,     0,
    52,    30,    51,     0,    52,    30,    47,     0,    51,    30,
    52,     0,    47,    30,    52,     0,    48,    30,    51,     0,
    51,    30,    48,     0,    48,    30,    52,     0,    52,    30,
    48,     0,    52,    30,    52,     0,    52,    31,    51,     0,
    52,    31,    47,     0,    51,    31,    52,     0,    47,    31,
    52,     0,    48,    31,    51,     0,    51,    31,    48,     0,
    48,    31,    52,     0,    52,    31,    48,     0,    52,    31,
    52,     0,    51,    30,    50,     0,    50,    30,    51,     0,
    52,    30,    50,     0,    50,    30,    52,     0,    52,    30,
    49,     0,    49,    30,    52,     0,    37,    48,     0,    37,
    52,     0,    37,    50,     0,    41,    52,    42,     0,    39,
    47,    43,     0,    39,    47,    15,    47,    43,     0,    39,
    47,    15,    47,    15,    47,    43,     0,    39,    47,    15,
    47,    15,    47,    15,    47,    43,     0,    39,    47,    15,
    47,    15,    47,    15,    47,    15,    47,    43,     0,    51,
    15,    51,     0,    47,    15,    51,     0,    51,    15,    47,
     0,    54,    15,    51,     0,    54,    15,    47,     0,     9,
     0,    41,    55,    42,     0,    55,    27,    55,     0
};

#endif

#if FFDEBUG != 0
static const short ffrline[] = { 0,
   119,   120,   123,   124,   127,   130,   133,   136,   139,   142,
   145,   148,   152,   153,   155,   157,   159,   163,   164,   166,
   168,   170,   172,   179,   181,   183,   185,   187,   189,   205,
   221,   229,   237,   245,   280,   282,   284,   288,   289,   294,
   296,   299,   301,   303,   306,   308,   310,   313,   315,   317,
   320,   330,   332,   335,   337,   339,   341,   343,   349,   356,
   368,   370,   385,   389,   390,   392,   394,   396,   398,   400,
   402,   404,   406,   408,   410,   412,   414,   416,   418,   420,
   422,   424,   426,   428,   430,   432,   434,   436,   438,   440,
   442,   444,   446,   448,   450,   452,   454,   456,   458,   460,
   462,   464,   466,   468,   471,   473,   475,   477,   480,   482,
   484,   486,   489,   527,   562,   564,   568,   569,   585,   601,
   618,   635,   643,   645,   647,   650,   652,   654,   657,   659,
   661,   664,   666,   668,   671,   673,   675,   678,   680,   682,
   685,   687,   689,   691,   693,   695,   697,   699,   701,   704,
   706,   708,   710,   712,   714,   716,   718,   720,   723,   725,
   727,   729,   731,   733,   735,   737,   739,   742,   744,   746,
   748,   750,   752,   754,   756,   758,   761,   763,   765,   767,
   769,   771,   773,   775,   777,   780,   782,   784,   786,   788,
   790,   792,   794,   796,   799,   803,   804,   806,   808,   810,
   817,   819,   821,   823,   825,   832,   834,   836,   838,   840,
   842,   844,   851,   853,   869,   878,   907,   936,   952,   954,
   956,   991,   993,   995,   999,  1000,  1002,  1004,  1006,  1008,
  1010,  1012,  1014,  1016,  1019,  1021,  1023,  1025,  1027,  1029,
  1031,  1033,  1035,  1038,  1040,  1042,  1044,  1046,  1048,  1050,
  1052,  1054,  1057,  1065,  1073,  1075,  1077,  1086,  1088,  1090,
  1092,  1095,  1097,  1099,  1101,  1103,  1109,  1116,  1118,  1120,
  1122,  1126,  1129,  1133,  1138,  1144,  1153,  1155,  1157,  1159,
  1168,  1179,  1180,  1182
};
#endif


#if FFDEBUG != 0 || defined (FFERROR_VERBOSE)

static const char * const fftname[] = {   "$","error","$undefined.","REAL","REALV",
"INTEGER","INTEGERV","BOOLEAN","BOOLEANV","STRING","BITSTR","FUNCTION","IFUNCTION",
"RFUNCTION","BFUNCTION","','","'='","':'","OR","AND","EQ","NE","'~'","GT","LT",
"LTE","GTE","'+'","'-'","'%'","'*'","'/'","'|'","'&'","POWER","NOT","INTCAST",
"FLTCAST","UMINUS","'['","'\\n'","'('","')'","']'","lines","line","bits","iexpr",
"iexprv","bexpr","bexprv","rexpr","rexprv","index","param","sexpr", NULL
};
#endif

static const short ffr1[] = {     0,
    44,    44,    45,    45,    45,    45,    45,    45,    45,    45,
    45,    45,    46,    46,    46,    46,    46,    47,    47,    47,
    47,    47,    47,    47,    47,    47,    47,    47,    47,    47,
    47,    47,    47,    47,    47,    47,    47,    48,    48,    48,
    48,    48,    48,    48,    48,    48,    48,    48,    48,    48,
    48,    48,    48,    48,    48,    48,    48,    48,    48,    48,
    48,    48,    48,    49,    49,    49,    49,    49,    49,    49,
    49,    49,    49,    49,    49,    49,    49,    49,    49,    49,
    49,    49,    49,    49,    49,    49,    49,    49,    49,    49,
    49,    49,    49,    49,    49,    49,    49,    49,    49,    49,
    49,    49,    49,    49,    49,    49,    49,    49,    49,    49,
    49,    49,    49,    49,    49,    49,    50,    50,    50,    50,
    50,    50,    50,    50,    50,    50,    50,    50,    50,    50,
    50,    50,    50,    50,    50,    50,    50,    50,    50,    50,
    50,    50,    50,    50,    50,    50,    50,    50,    50,    50,
    50,    50,    50,    50,    50,    50,    50,    50,    50,    50,
    50,    50,    50,    50,    50,    50,    50,    50,    50,    50,
    50,    50,    50,    50,    50,    50,    50,    50,    50,    50,
    50,    50,    50,    50,    50,    50,    50,    50,    50,    50,
    50,    50,    50,    50,    50,    51,    51,    51,    51,    51,
    51,    51,    51,    51,    51,    51,    51,    51,    51,    51,
    51,    51,    51,    51,    51,    51,    51,    51,    51,    51,
    51,    51,    51,    51,    52,    52,    52,    52,    52,    52,
    52,    52,    52,    52,    52,    52,    52,    52,    52,    52,
    52,    52,    52,    52,    52,    52,    52,    52,    52,    52,
    52,    52,    52,    52,    52,    52,    52,    52,    52,    52,
    52,    52,    52,    52,    52,    52,    52,    52,    52,    52,
    52,    53,    53,    53,    53,    53,    54,    54,    54,    54,
    54,    55,    55,    55
};

static const short ffr2[] = {     0,
     0,     2,     1,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     1,     3,     3,     2,     3,     1,     3,     3,
     3,     3,     3,     3,     2,     3,     3,     3,     3,     3,
     3,     3,     3,     2,     2,     2,     2,     1,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     2,
     2,     2,     3,     1,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     5,     5,     5,     5,     5,     5,
     5,     5,     3,     2,     2,     3,     1,     3,     3,     3,
     3,     2,     3,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     1,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     2,     3,     3,     3,     2,     3,
     2,     2,     2,     2,     1,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     2,     2,     2,
     3,     3,     5,     7,     9,    11,     3,     3,     3,     3,
     3,     1,     3,     3
};

static const short ffdefact[] = {     1,
     0,     0,   196,   225,    18,    38,    64,   117,   282,    13,
     0,     0,     0,     0,     0,     0,     0,     0,     3,     0,
     2,     0,     0,     0,     0,     0,     0,     0,     0,    12,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,   215,     0,     0,     0,     0,     0,     0,     0,     0,
     0,    25,   219,    16,   115,   122,    36,    61,    37,    62,
    35,    60,   222,   268,   224,   270,   223,   269,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,    11,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     4,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     5,    34,     0,     0,     0,     0,     0,     6,
     0,     0,     0,     0,     0,     7,   114,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     8,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     9,   221,     0,     0,     0,    10,    30,    29,   214,
    31,    33,    32,     0,   217,     0,   216,     0,   218,   113,
    17,    26,    63,   116,   195,   220,   271,   283,     0,     0,
    65,    66,    69,    67,    68,    70,    15,    14,     0,     0,
    76,   124,    90,   144,    77,   127,    91,   153,    75,    89,
    71,   130,    85,   162,    72,   133,    86,   171,    74,   139,
    88,   189,    73,   136,    87,   180,    20,    43,   202,   229,
    21,    46,   203,   238,    19,    40,    22,    49,    27,    54,
   204,   247,    23,    52,   205,   256,    24,   206,   123,   125,
   145,   147,   126,   128,   154,   156,   129,   131,   163,   165,
   132,   134,   172,   174,   138,   140,   190,   192,   135,   137,
   181,   183,    42,    44,   230,   232,    45,    47,   239,   241,
    39,    41,    48,    50,    58,    56,   248,   250,    51,    53,
   257,   259,     0,   102,   101,   103,   104,    28,    59,   208,
   267,   119,   118,   120,   121,    55,    57,   263,   265,     0,
     0,    97,   146,    83,   143,    98,   155,    84,   152,    96,
    82,    92,   164,    78,   161,    93,   173,    79,   170,    95,
   191,    81,   188,    94,   182,    80,   179,   209,   231,   197,
   228,   210,   240,   198,   237,   211,   249,   207,   262,   199,
   246,   212,   258,   200,   255,   213,   201,   142,   148,   141,
   149,   151,   157,   150,   158,   160,   166,   159,   167,   169,
   175,   168,   176,   187,   193,   186,   194,   178,   184,   177,
   185,   227,   233,   226,   234,   236,   242,   235,   243,   245,
   251,   266,   264,   244,   252,   254,   260,   253,   261,     0,
    99,   100,   284,   278,   279,   277,   281,   280,    16,     0,
     0,     0,     0,   272,     0,     0,     0,   105,   106,   107,
   108,     0,   109,   110,   111,   112,     0,   273,     0,     0,
   274,     0,     0,   275,     0,   276,     0,     0
};

static const short ffdefgoto[] = {     1,
    21,    31,    32,    44,    34,    45,    36,    47,   114,    48,
    38
};

static const short ffpact[] = {-32768,
    24,   -34,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
   827,   827,   787,   827,   827,   827,   827,   827,-32768,   827,
-32768,   682,  1015,  1174,   352,   306,  1036,  1195,   143,-32768,
  1416,  1297,  1054,    95,    36,  1345,  1114,   -17,  1074,   157,
  1134,-32768,   922,   822,   427,   945,  1245,     3,  1216,  1233,
     7,-32768,-32768,-32768,-32768,   -28,-32768,   -28,-32768,   -28,
-32768,   -28,-32768,   -28,-32768,   -28,-32768,   -28,   288,   992,
  1094,   280,   276,   636,  1154,   -19,     5,     5,     5,     5,
     5,     5,     5,     5,-32768,   827,   827,   827,   827,   827,
   827,   827,   827,   827,   827,   827,   827,   827,   827,-32768,
   827,   827,   827,   827,   827,   827,   827,   827,   827,   827,
   827,   827,-32768,-32768,   827,   827,   827,   827,   827,-32768,
   827,   827,   827,   827,   827,-32768,-32768,   827,   827,   827,
   827,   827,   827,   827,   827,   827,   827,   827,   827,   827,
-32768,   827,   827,   827,   827,   827,   827,   827,   827,   827,
   827,-32768,-32768,     0,     0,     0,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,   827,-32768,   827,-32768,   827,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,     5,     5,
    18,    18,    18,    18,    18,    18,-32768,-32768,  1265,  1313,
   612,   531,   571,   780,   612,   531,   571,   780,   612,   571,
    92,    43,   447,   428,    92,    43,   447,   428,    92,    43,
   447,   428,    92,    43,   447,   428,    49,   184,   221,   226,
    49,   184,   221,   226,    49,   184,   -13,   -28,-32768,   -28,
    13,   -28,   -13,   -28,    13,   -28,   -13,    13,  1358,   531,
  1374,   780,  1358,   531,  1374,   780,   232,    43,   328,   428,
   232,    43,   328,   428,   232,    43,   328,   428,   232,    43,
   328,   428,   307,   184,   363,   226,   307,   184,   363,   226,
   307,   184,    47,   -28,-32768,   -28,   150,   -28,    47,   -28,
   150,   -28,   670,   189,   168,    28,    28,   -13,   -28,    13,
   -28,    23,   173,     9,     9,    47,   -28,   150,   -28,  1281,
  1329,   612,   531,   571,   780,   612,   531,   571,   780,   612,
   571,    92,    43,   447,   428,    92,    43,   447,   428,    92,
    43,   447,   428,    92,    43,   447,   428,    49,   184,   221,
   226,    49,   184,   221,   226,   -13,   -28,-32768,   -28,    13,
   -28,   -13,   -28,    13,   -28,   -13,    13,  1358,   531,  1374,
   780,  1358,   531,  1374,   780,   232,    43,   328,   428,   232,
    43,   328,   428,   232,    43,   328,   428,   232,    43,   328,
   428,   307,   184,   363,   226,   307,   184,   363,   226,    47,
   -28,-32768,   -28,   150,   -28,    47,   -28,   150,   -28,     0,
    57,    57,-32768,  1345,  1297,  1345,  1297,  1345,-32768,    35,
   827,   827,   827,-32768,   827,   827,   -22,  1389,  1404,  1389,
  1404,   850,  1389,  1404,  1389,  1404,   827,-32768,   874,   827,
-32768,   898,   827,-32768,   968,-32768,    76,-32768
};

static const short ffpgoto[] = {-32768,
-32768,   469,    -1,   481,   315,   664,   139,   633,   145,    85,
     6
};


#define	FFLAST		1449


static const short fftable[] = {    23,
   154,   155,   154,   155,   156,    30,    29,   156,     9,   156,
   112,    43,    49,    52,    10,    57,    63,   168,    70,   178,
    99,   168,   178,   427,     2,    76,     3,     4,     5,     6,
     7,     8,     9,    10,    11,    12,    13,    14,   125,   179,
   390,   122,   123,   124,   169,   180,   140,   112,   170,    83,
    84,    15,   125,   121,   122,   123,   124,   119,    16,    17,
    18,   112,    86,    19,    20,   125,    83,    84,    89,   107,
   108,   109,   110,   111,   112,   428,   171,   159,    97,    98,
    99,   112,    99,   156,   189,   191,   195,   199,   201,   205,
   209,   213,   217,   221,   225,   227,   233,   237,    51,   239,
   243,   247,   251,   255,   259,   263,   267,   271,   273,   279,
   283,     0,   115,   116,   117,   118,     0,   288,    94,    95,
    96,    97,    98,   296,   119,    99,   300,   302,   306,   310,
   312,   316,   320,   324,   328,   332,   336,   342,   346,    27,
   348,   352,   356,   360,   364,   368,   372,   376,   380,   386,
     0,    46,    50,    53,     0,    61,    67,     0,    74,   391,
   392,   393,   154,   155,   395,   128,   397,     0,     0,   156,
   127,   131,   153,     0,   121,   122,   123,   124,     0,   127,
     0,   153,   157,   140,   127,   153,   125,   117,   118,   127,
     0,   153,   123,   124,     0,   112,     0,   119,   162,     0,
   127,     0,   125,     0,   127,     0,   153,   116,   117,   118,
   127,   112,   153,   110,   111,     0,     0,   127,   119,   153,
     0,     0,   112,     0,   190,   193,   197,   200,   203,   207,
   211,   215,   219,   223,     0,   231,   235,   238,     0,   241,
   245,   249,   253,   257,   261,   265,   269,    86,   277,   281,
   138,   139,     0,    89,   140,   150,   151,   290,    94,    95,
    96,    97,    98,   298,   112,    99,   301,   304,   308,   311,
   314,   318,   322,   326,   330,   334,   340,   344,   347,     0,
   350,   354,   358,   362,   366,   370,   374,   378,   384,   388,
     0,     0,     0,   121,   122,   123,   124,   115,   116,   117,
   118,     0,   394,     0,   396,   125,   398,    77,    78,   119,
    79,    80,    81,    82,   112,    25,     0,   175,     0,    83,
    84,   174,    86,   121,   122,   123,   124,     0,    89,   171,
    55,    59,    65,     0,    72,   125,    97,    98,   153,     0,
    99,     0,   153,   128,   112,   126,     0,     0,   153,   131,
     0,     0,   153,     0,   136,   137,   153,   138,   139,     0,
   153,   140,     0,     0,   153,     0,     0,     0,   153,   115,
   116,   117,   118,     0,   127,     0,   153,     0,   128,     0,
   153,   119,     0,     0,   131,     0,   153,     0,     0,     0,
   153,   120,   138,   139,   153,   407,   140,     0,   153,   408,
   410,   412,   153,   413,   415,     0,   153,     0,     0,     0,
   153,   229,     0,     0,   153,   419,     0,     0,   422,     0,
   127,   425,   153,     0,   275,     0,   153,     0,     0,   284,
   285,   286,   287,     0,     0,   153,   127,   127,   127,   127,
     0,     0,     0,   153,   121,   122,   123,   124,     0,   153,
     0,     0,   338,   153,   148,   149,   125,   150,   151,   153,
     0,     0,     0,   153,   382,   112,   112,   153,     0,    22,
     0,   153,     0,   136,   137,   153,   138,   139,     0,   153,
   140,    24,     0,   127,    54,   153,     0,     0,    69,   153,
     0,    33,    39,     0,     0,   153,     0,    58,    64,   153,
    71,     0,     0,   153,     0,     0,     0,   153,     0,     0,
     0,   153,     0,     0,     0,   153,     0,     0,     0,   153,
     0,     0,     0,   153,     0,     0,     0,   127,     0,   153,
     0,     0,     0,   153,     0,     0,     0,     0,     0,   409,
   411,     0,     0,   414,   416,   181,   182,   183,   184,   185,
   186,   187,   188,   103,   104,   105,   106,   107,   108,   109,
   110,   111,     0,     0,     0,     0,     0,   192,   196,   112,
   202,   206,   210,   214,   218,   222,   226,   228,   234,     0,
     0,   240,   244,   248,   252,   256,   260,   264,   268,   272,
   274,   280,     0,   132,   133,   134,   135,   136,   137,   289,
   138,   139,     0,     0,   140,   297,     0,     0,     0,   303,
   307,     0,   313,   317,   321,   325,   329,   333,   337,   343,
     0,     0,   349,   353,   357,   361,   365,   369,   373,   377,
   381,   387,     0,    28,    90,    91,    92,    93,    94,    95,
    96,    97,    98,    37,    41,    99,     0,   399,   400,    62,
    68,   128,    75,     0,     0,   129,   130,   131,   132,   133,
   134,   135,   136,   137,    26,   138,   139,     0,     0,   140,
     0,     0,     0,     0,    35,    40,     0,   176,     0,    56,
    60,    66,     0,    73,   403,    86,     0,     0,     0,    87,
    88,    89,    90,    91,    92,    93,    94,    95,    96,    97,
    98,    77,    78,    99,    79,    80,    81,    82,     0,     0,
     0,     0,   404,    83,    84,     0,     0,     0,     0,   194,
   198,    85,   204,   208,   212,   216,   220,   224,     0,   232,
   236,     0,     0,   242,   246,   250,   254,   258,   262,   266,
   270,     0,   278,   282,     0,     0,     0,     0,     0,     0,
     0,   291,     0,     0,     0,     0,     0,   299,     0,     0,
   230,   305,   309,     0,   315,   319,   323,   327,   331,   335,
   341,   345,     0,   276,   351,   355,   359,   363,   367,   371,
   375,   379,   385,   389,   292,   293,   294,   295,     0,     3,
     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,
    14,   339,   144,   145,   146,   147,   148,   149,     0,   150,
   151,     0,     0,   383,    15,     0,     0,     0,   112,     0,
     0,    16,    17,    18,     0,     0,     0,    20,    42,     3,
     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,
    14,   101,   102,     0,   103,   104,   105,   106,   107,   108,
   109,   110,   111,     0,    15,     0,     0,     0,     0,     0,
   112,    16,    17,    18,   417,    86,     0,    20,     0,    87,
    88,    89,    90,    91,    92,    93,    94,    95,    96,    97,
    98,     0,     0,    99,     0,     0,     0,     0,   420,    86,
     0,     0,   418,    87,    88,    89,    90,    91,    92,    93,
    94,    95,    96,    97,    98,     0,     0,    99,     0,     0,
     0,     0,   423,    86,     0,     0,   421,    87,    88,    89,
    90,    91,    92,    93,    94,    95,    96,    97,    98,     0,
     0,    99,     0,     0,     0,     0,   164,    86,     0,     0,
   424,    87,    88,    89,    90,    91,    92,    93,    94,    95,
    96,    97,    98,     0,     0,    99,     0,     0,     0,   166,
   128,     0,     0,   165,   129,   130,   131,   132,   133,   134,
   135,   136,   137,     0,   138,   139,     0,     0,   140,     0,
     0,     0,     0,    86,     0,     0,   167,    87,    88,    89,
    90,    91,    92,    93,    94,    95,    96,    97,    98,     0,
     0,    99,     0,     0,     0,     0,     0,    86,     0,     0,
   426,    87,    88,    89,    90,    91,    92,    93,    94,    95,
    96,    97,    98,     0,     0,    99,     0,     0,     0,     0,
    86,     0,     0,   172,    87,    88,    89,    90,    91,    92,
    93,    94,    95,    96,    97,    98,     0,     0,    99,     0,
     0,   128,     0,     0,   100,   129,   130,   131,   132,   133,
   134,   135,   136,   137,     0,   138,   139,     0,     0,   140,
     0,     0,     0,   101,   102,   141,   103,   104,   105,   106,
   107,   108,   109,   110,   111,     0,     0,     0,     0,     0,
     0,     0,   112,   101,   102,   158,   103,   104,   105,   106,
   107,   108,   109,   110,   111,     0,     0,     0,     0,     0,
     0,     0,   112,   101,   102,   161,   103,   104,   105,   106,
   107,   108,   109,   110,   111,     0,     0,     0,     0,     0,
     0,     0,   112,   142,   143,   173,   144,   145,   146,   147,
   148,   149,     0,   150,   151,     0,     0,     0,     0,     0,
     0,     0,   112,   142,   143,   160,   144,   145,   146,   147,
   148,   149,     0,   150,   151,     0,     0,     0,     0,     0,
     0,     0,   112,   142,   143,   163,   144,   145,   146,   147,
   148,   149,     0,   150,   151,     0,     0,     0,     0,     0,
     0,     0,   112,   101,   102,   177,   103,   104,   105,   106,
   107,   108,   109,   110,   111,     0,     0,     0,     0,     0,
     0,     0,   112,   113,   142,   143,     0,   144,   145,   146,
   147,   148,   149,     0,   150,   151,     0,     0,     0,     0,
   164,    86,     0,   112,   152,    87,    88,    89,    90,    91,
    92,    93,    94,    95,    96,    97,    98,   166,   128,    99,
     0,     0,   129,   130,   131,   132,   133,   134,   135,   136,
   137,     0,   138,   139,   142,   143,   140,   144,   145,   146,
   147,   148,   149,     0,   150,   151,     0,     0,     0,     0,
    86,   401,     0,   112,    87,    88,    89,    90,    91,    92,
    93,    94,    95,    96,    97,    98,    86,   405,    99,     0,
    87,    88,    89,    90,    91,    92,    93,    94,    95,    96,
    97,    98,    86,     0,    99,     0,    87,    88,    89,    90,
    91,    92,    93,    94,    95,    96,    97,    98,   128,   402,
    99,     0,   129,   130,   131,   132,   133,   134,   135,   136,
   137,     0,   138,   139,   128,   406,   140,     0,   129,   130,
   131,   132,   133,   134,   135,   136,   137,     0,   138,   139,
   128,     0,   140,     0,   129,   130,   131,   132,   133,   134,
   135,   136,   137,    86,   138,   139,     0,     0,   140,    89,
    90,    91,    92,    93,    94,    95,    96,    97,    98,   128,
     0,    99,     0,     0,     0,   131,   132,   133,   134,   135,
   136,   137,     0,   138,   139,     0,     0,   140,    87,    88,
    89,    90,    91,    92,    93,    94,    95,    96,    97,    98,
     0,     0,    99,   129,   130,   131,   132,   133,   134,   135,
   136,   137,     0,   138,   139,    77,    78,   140,    79,    80,
    81,    82,     0,     0,     0,     0,     0,    83,    84
};

static const short ffcheck[] = {     1,
    20,    21,    20,    21,    27,    40,     1,    27,     9,    27,
    39,    13,    14,    15,    10,    17,    18,    15,    20,    42,
    34,    15,    42,     0,     1,    20,     3,     4,     5,     6,
     7,     8,     9,    10,    11,    12,    13,    14,    30,    35,
    41,    19,    20,    21,    42,    41,    34,    39,    42,    32,
    33,    28,    30,    18,    19,    20,    21,    30,    35,    36,
    37,    39,    16,    40,    41,    30,    32,    33,    22,    27,
    28,    29,    30,    31,    39,     0,    42,    42,    30,    31,
    34,    39,    34,    27,    86,    87,    88,    89,    90,    91,
    92,    93,    94,    95,    96,    97,    98,    99,    14,   101,
   102,   103,   104,   105,   106,   107,   108,   109,   110,   111,
   112,    -1,    18,    19,    20,    21,    -1,   119,    27,    28,
    29,    30,    31,   125,    30,    34,   128,   129,   130,   131,
   132,   133,   134,   135,   136,   137,   138,   139,   140,     1,
   142,   143,   144,   145,   146,   147,   148,   149,   150,   151,
    -1,    13,    14,    15,    -1,    17,    18,    -1,    20,   154,
   155,   156,    20,    21,   166,    16,   168,    -1,    -1,    27,
    26,    22,    28,    -1,    18,    19,    20,    21,    -1,    35,
    -1,    37,    40,    34,    40,    41,    30,    20,    21,    45,
    -1,    47,    20,    21,    -1,    39,    -1,    30,    42,    -1,
    56,    -1,    30,    -1,    60,    -1,    62,    19,    20,    21,
    66,    39,    68,    30,    31,    -1,    -1,    73,    30,    75,
    -1,    -1,    39,    -1,    86,    87,    88,    89,    90,    91,
    92,    93,    94,    95,    -1,    97,    98,    99,    -1,   101,
   102,   103,   104,   105,   106,   107,   108,    16,   110,   111,
    30,    31,    -1,    22,    34,    30,    31,   119,    27,    28,
    29,    30,    31,   125,    39,    34,   128,   129,   130,   131,
   132,   133,   134,   135,   136,   137,   138,   139,   140,    -1,
   142,   143,   144,   145,   146,   147,   148,   149,   150,   151,
    -1,    -1,    -1,    18,    19,    20,    21,    18,    19,    20,
    21,    -1,   164,    -1,   166,    30,   168,    20,    21,    30,
    23,    24,    25,    26,    39,     1,    -1,    42,    -1,    32,
    33,    42,    16,    18,    19,    20,    21,    -1,    22,    42,
    16,    17,    18,    -1,    20,    30,    30,    31,   194,    -1,
    34,    -1,   198,    16,    39,    40,    -1,    -1,   204,    22,
    -1,    -1,   208,    -1,    27,    28,   212,    30,    31,    -1,
   216,    34,    -1,    -1,   220,    -1,    -1,    -1,   224,    18,
    19,    20,    21,    -1,   230,    -1,   232,    -1,    16,    -1,
   236,    30,    -1,    -1,    22,    -1,   242,    -1,    -1,    -1,
   246,    40,    30,    31,   250,   390,    34,    -1,   254,   401,
   402,   403,   258,   405,   406,    -1,   262,    -1,    -1,    -1,
   266,    97,    -1,    -1,   270,   417,    -1,    -1,   420,    -1,
   276,   423,   278,    -1,   110,    -1,   282,    -1,    -1,   115,
   116,   117,   118,    -1,    -1,   291,   292,   293,   294,   295,
    -1,    -1,    -1,   299,    18,    19,    20,    21,    -1,   305,
    -1,    -1,   138,   309,    27,    28,    30,    30,    31,   315,
    -1,    -1,    -1,   319,   150,    39,    39,   323,    -1,     1,
    -1,   327,    -1,    27,    28,   331,    30,    31,    -1,   335,
    34,     1,    -1,   339,    16,   341,    -1,    -1,    20,   345,
    -1,    11,    12,    -1,    -1,   351,    -1,    17,    18,   355,
    20,    -1,    -1,   359,    -1,    -1,    -1,   363,    -1,    -1,
    -1,   367,    -1,    -1,    -1,   371,    -1,    -1,    -1,   375,
    -1,    -1,    -1,   379,    -1,    -1,    -1,   383,    -1,   385,
    -1,    -1,    -1,   389,    -1,    -1,    -1,    -1,    -1,   401,
   402,    -1,    -1,   405,   406,    77,    78,    79,    80,    81,
    82,    83,    84,    23,    24,    25,    26,    27,    28,    29,
    30,    31,    -1,    -1,    -1,    -1,    -1,    87,    88,    39,
    90,    91,    92,    93,    94,    95,    96,    97,    98,    -1,
    -1,   101,   102,   103,   104,   105,   106,   107,   108,   109,
   110,   111,    -1,    23,    24,    25,    26,    27,    28,   119,
    30,    31,    -1,    -1,    34,   125,    -1,    -1,    -1,   129,
   130,    -1,   132,   133,   134,   135,   136,   137,   138,   139,
    -1,    -1,   142,   143,   144,   145,   146,   147,   148,   149,
   150,   151,    -1,     1,    23,    24,    25,    26,    27,    28,
    29,    30,    31,    11,    12,    34,    -1,   179,   180,    17,
    18,    16,    20,    -1,    -1,    20,    21,    22,    23,    24,
    25,    26,    27,    28,     1,    30,    31,    -1,    -1,    34,
    -1,    -1,    -1,    -1,    11,    12,    -1,    42,    -1,    16,
    17,    18,    -1,    20,    15,    16,    -1,    -1,    -1,    20,
    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
    31,    20,    21,    34,    23,    24,    25,    26,    -1,    -1,
    -1,    -1,    43,    32,    33,    -1,    -1,    -1,    -1,    87,
    88,    40,    90,    91,    92,    93,    94,    95,    -1,    97,
    98,    -1,    -1,   101,   102,   103,   104,   105,   106,   107,
   108,    -1,   110,   111,    -1,    -1,    -1,    -1,    -1,    -1,
    -1,   119,    -1,    -1,    -1,    -1,    -1,   125,    -1,    -1,
    97,   129,   130,    -1,   132,   133,   134,   135,   136,   137,
   138,   139,    -1,   110,   142,   143,   144,   145,   146,   147,
   148,   149,   150,   151,   121,   122,   123,   124,    -1,     3,
     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,
    14,   138,    23,    24,    25,    26,    27,    28,    -1,    30,
    31,    -1,    -1,   150,    28,    -1,    -1,    -1,    39,    -1,
    -1,    35,    36,    37,    -1,    -1,    -1,    41,    42,     3,
     4,     5,     6,     7,     8,     9,    10,    11,    12,    13,
    14,    20,    21,    -1,    23,    24,    25,    26,    27,    28,
    29,    30,    31,    -1,    28,    -1,    -1,    -1,    -1,    -1,
    39,    35,    36,    37,    15,    16,    -1,    41,    -1,    20,
    21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
    31,    -1,    -1,    34,    -1,    -1,    -1,    -1,    15,    16,
    -1,    -1,    43,    20,    21,    22,    23,    24,    25,    26,
    27,    28,    29,    30,    31,    -1,    -1,    34,    -1,    -1,
    -1,    -1,    15,    16,    -1,    -1,    43,    20,    21,    22,
    23,    24,    25,    26,    27,    28,    29,    30,    31,    -1,
    -1,    34,    -1,    -1,    -1,    -1,    15,    16,    -1,    -1,
    43,    20,    21,    22,    23,    24,    25,    26,    27,    28,
    29,    30,    31,    -1,    -1,    34,    -1,    -1,    -1,    15,
    16,    -1,    -1,    42,    20,    21,    22,    23,    24,    25,
    26,    27,    28,    -1,    30,    31,    -1,    -1,    34,    -1,
    -1,    -1,    -1,    16,    -1,    -1,    42,    20,    21,    22,
    23,    24,    25,    26,    27,    28,    29,    30,    31,    -1,
    -1,    34,    -1,    -1,    -1,    -1,    -1,    16,    -1,    -1,
    43,    20,    21,    22,    23,    24,    25,    26,    27,    28,
    29,    30,    31,    -1,    -1,    34,    -1,    -1,    -1,    -1,
    16,    -1,    -1,    42,    20,    21,    22,    23,    24,    25,
    26,    27,    28,    29,    30,    31,    -1,    -1,    34,    -1,
    -1,    16,    -1,    -1,    40,    20,    21,    22,    23,    24,
    25,    26,    27,    28,    -1,    30,    31,    -1,    -1,    34,
    -1,    -1,    -1,    20,    21,    40,    23,    24,    25,    26,
    27,    28,    29,    30,    31,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    39,    20,    21,    42,    23,    24,    25,    26,
    27,    28,    29,    30,    31,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    39,    20,    21,    42,    23,    24,    25,    26,
    27,    28,    29,    30,    31,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    39,    20,    21,    42,    23,    24,    25,    26,
    27,    28,    -1,    30,    31,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    39,    20,    21,    42,    23,    24,    25,    26,
    27,    28,    -1,    30,    31,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    39,    20,    21,    42,    23,    24,    25,    26,
    27,    28,    -1,    30,    31,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    39,    20,    21,    42,    23,    24,    25,    26,
    27,    28,    29,    30,    31,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    39,    40,    20,    21,    -1,    23,    24,    25,
    26,    27,    28,    -1,    30,    31,    -1,    -1,    -1,    -1,
    15,    16,    -1,    39,    40,    20,    21,    22,    23,    24,
    25,    26,    27,    28,    29,    30,    31,    15,    16,    34,
    -1,    -1,    20,    21,    22,    23,    24,    25,    26,    27,
    28,    -1,    30,    31,    20,    21,    34,    23,    24,    25,
    26,    27,    28,    -1,    30,    31,    -1,    -1,    -1,    -1,
    16,    17,    -1,    39,    20,    21,    22,    23,    24,    25,
    26,    27,    28,    29,    30,    31,    16,    17,    34,    -1,
    20,    21,    22,    23,    24,    25,    26,    27,    28,    29,
    30,    31,    16,    -1,    34,    -1,    20,    21,    22,    23,
    24,    25,    26,    27,    28,    29,    30,    31,    16,    17,
    34,    -1,    20,    21,    22,    23,    24,    25,    26,    27,
    28,    -1,    30,    31,    16,    17,    34,    -1,    20,    21,
    22,    23,    24,    25,    26,    27,    28,    -1,    30,    31,
    16,    -1,    34,    -1,    20,    21,    22,    23,    24,    25,
    26,    27,    28,    16,    30,    31,    -1,    -1,    34,    22,
    23,    24,    25,    26,    27,    28,    29,    30,    31,    16,
    -1,    34,    -1,    -1,    -1,    22,    23,    24,    25,    26,
    27,    28,    -1,    30,    31,    -1,    -1,    34,    20,    21,
    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
    -1,    -1,    34,    20,    21,    22,    23,    24,    25,    26,
    27,    28,    -1,    30,    31,    20,    21,    34,    23,    24,
    25,    26,    -1,    -1,    -1,    -1,    -1,    32,    33
};
/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
#line 3 "/usr/local/share/bison.simple"

/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* As a special exception, when this file is copied by Bison into a
   Bison output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison.  */

#ifndef alloca
#ifdef __GNUC__
#define alloca __builtin_alloca
#else /* not GNU C.  */
#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)
#include <alloca.h>
#else /* not sparc */
#if defined (MSDOS) && !defined (__TURBOC__)
#include <malloc.h>
#else /* not MSDOS, or __TURBOC__ */
#if defined(_AIX)
#include <malloc.h>
 #pragma alloca
#else /* not MSDOS, __TURBOC__, or _AIX */
#ifdef __hpux
#ifdef __cplusplus
extern "C" {
void *alloca (unsigned int);
};
#else /* not __cplusplus */
void *alloca ();
#endif /* not __cplusplus */
#endif /* __hpux */
#endif /* not _AIX */
#endif /* not MSDOS, or __TURBOC__ */
#endif /* not sparc.  */
#endif /* not GNU C.  */
#endif /* alloca not defined.  */

/* This is the parser code that is written into each bison parser
  when the %semantic_parser declaration is not specified in the grammar.
  It was written by Richard Stallman by simplifying the hairy parser
  used when %semantic_parser is specified.  */

/* Note: there must be only one dollar sign in this file.
   It is replaced by the list of actions, each action
   as one case of the switch.  */

#define fferrok		(fferrstatus = 0)
#define ffclearin	(ffchar = FFEMPTY)
#define FFEMPTY		-2
#define FFEOF		0
#define FFACCEPT	return(0)
#define FFABORT 	return(1)
#define FFERROR		goto fferrlab1
/* Like FFERROR except do call fferror.
   This remains here temporarily to ease the
   transition to the new meaning of FFERROR, for GCC.
   Once GCC version 2 has supplanted version 1, this can go.  */
#define FFFAIL		goto fferrlab
#define FFRECOVERING()  (!!fferrstatus)
#define FFBACKUP(token, value) \
do								\
  if (ffchar == FFEMPTY && fflen == 1)				\
    { ffchar = (token), fflval = (value);			\
      ffchar1 = FFTRANSLATE (ffchar);				\
      FFPOPSTACK;						\
      goto ffbackup;						\
    }								\
  else								\
    { fferror ("syntax error: cannot back up"); FFERROR; }	\
while (0)

#define FFTERROR	1
#define FFERRCODE	256

#ifndef FFPURE
#define FFLEX		fflex()
#endif

#ifdef FFPURE
#ifdef FFLSP_NEEDED
#ifdef FFLEX_PARAM
#define FFLEX		fflex(&fflval, &fflloc, FFLEX_PARAM)
#else
#define FFLEX		fflex(&fflval, &fflloc)
#endif
#else /* not FFLSP_NEEDED */
#ifdef FFLEX_PARAM
#define FFLEX		fflex(&fflval, FFLEX_PARAM)
#else
#define FFLEX		fflex(&fflval)
#endif
#endif /* not FFLSP_NEEDED */
#endif

/* If nonreentrant, generate the variables here */

#ifndef FFPURE

int	ffchar;			/*  the lookahead symbol		*/
FFSTYPE	fflval;			/*  the semantic value of the		*/
				/*  lookahead symbol			*/

#ifdef FFLSP_NEEDED
FFLTYPE fflloc;			/*  location data for the lookahead	*/
				/*  symbol				*/
#endif

int ffnerrs;			/*  number of parse errors so far       */
#endif  /* not FFPURE */

#if FFDEBUG != 0
int ffdebug;			/*  nonzero means print parse trace	*/
/* Since this is uninitialized, it does not stop multiple parsers
   from coexisting.  */
#endif

/*  FFINITDEPTH indicates the initial size of the parser's stacks	*/

#ifndef	FFINITDEPTH
#define FFINITDEPTH 200
#endif

/*  FFMAXDEPTH is the maximum size the stacks can grow to
    (effective only if the built-in stack extension method is used).  */

#if FFMAXDEPTH == 0
#undef FFMAXDEPTH
#endif

#ifndef FFMAXDEPTH
#define FFMAXDEPTH 10000
#endif

/* Prevent warning if -Wstrict-prototypes.  */
#ifdef __GNUC__
int ffparse (void);
#endif

#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
#define __ff_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
#else				/* not GNU C or C++ */
#ifndef __cplusplus

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__ff_memcpy (to, from, count)
     char *to;
     char *from;
     int count;
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#else /* __cplusplus */

/* This is the most reliable way to avoid incompatibilities
   in available built-in functions on various systems.  */
static void
__ff_memcpy (char *to, char *from, int count)
{
  register char *f = from;
  register char *t = to;
  register int i = count;

  while (i-- > 0)
    *t++ = *f++;
}

#endif
#endif

#line 196 "/usr/local/share/bison.simple"

/* The user can define FFPARSE_PARAM as the name of an argument to be passed
   into ffparse.  The argument should have type void *.
   It should actually point to an object.
   Grammar actions can access the variable by casting it
   to the proper pointer type.  */

#ifdef FFPARSE_PARAM
#ifdef __cplusplus
#define FFPARSE_PARAM_ARG void *FFPARSE_PARAM
#define FFPARSE_PARAM_DECL
#else /* not __cplusplus */
#define FFPARSE_PARAM_ARG FFPARSE_PARAM
#define FFPARSE_PARAM_DECL void *FFPARSE_PARAM;
#endif /* not __cplusplus */
#else /* not FFPARSE_PARAM */
#define FFPARSE_PARAM_ARG
#define FFPARSE_PARAM_DECL
#endif /* not FFPARSE_PARAM */

int
ffparse(FFPARSE_PARAM_ARG)
     FFPARSE_PARAM_DECL
{
  register int ffstate;
  register int ffn;
  register short *ffssp;
  register FFSTYPE *ffvsp;
  int fferrstatus;	/*  number of tokens to shift before error messages enabled */
  int ffchar1 = 0;		/*  lookahead token as an internal (translated) token number */

  short	ffssa[FFINITDEPTH];	/*  the state stack			*/
  FFSTYPE ffvsa[FFINITDEPTH];	/*  the semantic value stack		*/

  short *ffss = ffssa;		/*  refer to the stacks thru separate pointers */
  FFSTYPE *ffvs = ffvsa;	/*  to allow ffoverflow to reallocate them elsewhere */

#ifdef FFLSP_NEEDED
  FFLTYPE fflsa[FFINITDEPTH];	/*  the location stack			*/
  FFLTYPE *ffls = fflsa;
  FFLTYPE *fflsp;

#define FFPOPSTACK   (ffvsp--, ffssp--, fflsp--)
#else
#define FFPOPSTACK   (ffvsp--, ffssp--)
#endif

  int ffstacksize = FFINITDEPTH;

#ifdef FFPURE
  int ffchar;
  FFSTYPE fflval;
  int ffnerrs;
#ifdef FFLSP_NEEDED
  FFLTYPE fflloc;
#endif
#endif

  FFSTYPE ffval;		/*  the variable used to return		*/
				/*  semantic values from the action	*/
				/*  routines				*/

  int fflen;

#if FFDEBUG != 0
  if (ffdebug)
    fprintf(stderr, "Starting parse\n");
#endif

  ffstate = 0;
  fferrstatus = 0;
  ffnerrs = 0;
  ffchar = FFEMPTY;		/* Cause a token to be read.  */

  /* Initialize stack pointers.
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized.  */

  ffssp = ffss - 1;
  ffvsp = ffvs;
#ifdef FFLSP_NEEDED
  fflsp = ffls;
#endif

/* Push a new state, which is found in  ffstate  .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
ffnewstate:

  *++ffssp = ffstate;

  if (ffssp >= ffss + ffstacksize - 1)
    {
      /* Give user a chance to reallocate the stack */
      /* Use copies of these so that the &'s don't force the real ones into memory. */
      FFSTYPE *ffvs1 = ffvs;
      short *ffss1 = ffss;
#ifdef FFLSP_NEEDED
      FFLTYPE *ffls1 = ffls;
#endif

      /* Get the current used size of the three stacks, in elements.  */
      int size = ffssp - ffss + 1;

#ifdef ffoverflow
      /* Each stack pointer address is followed by the size of
	 the data in use in that stack, in bytes.  */
#ifdef FFLSP_NEEDED
      /* This used to be a conditional around just the two extra args,
	 but that might be undefined if ffoverflow is a macro.  */
      ffoverflow("parser stack overflow",
		 &ffss1, size * sizeof (*ffssp),
		 &ffvs1, size * sizeof (*ffvsp),
		 &ffls1, size * sizeof (*fflsp),
		 &ffstacksize);
#else
      ffoverflow("parser stack overflow",
		 &ffss1, size * sizeof (*ffssp),
		 &ffvs1, size * sizeof (*ffvsp),
		 &ffstacksize);
#endif

      ffss = ffss1; ffvs = ffvs1;
#ifdef FFLSP_NEEDED
      ffls = ffls1;
#endif
#else /* no ffoverflow */
      /* Extend the stack our own way.  */
      if (ffstacksize >= FFMAXDEPTH)
	{
	  fferror("parser stack overflow");
	  return 2;
	}
      ffstacksize *= 2;
      if (ffstacksize > FFMAXDEPTH)
	ffstacksize = FFMAXDEPTH;
      ffss = (short *) alloca (ffstacksize * sizeof (*ffssp));
      __ff_memcpy ((char *)ffss, (char *)ffss1, size * sizeof (*ffssp));
      ffvs = (FFSTYPE *) alloca (ffstacksize * sizeof (*ffvsp));
      __ff_memcpy ((char *)ffvs, (char *)ffvs1, size * sizeof (*ffvsp));
#ifdef FFLSP_NEEDED
      ffls = (FFLTYPE *) alloca (ffstacksize * sizeof (*fflsp));
      __ff_memcpy ((char *)ffls, (char *)ffls1, size * sizeof (*fflsp));
#endif
#endif /* no ffoverflow */

      ffssp = ffss + size - 1;
      ffvsp = ffvs + size - 1;
#ifdef FFLSP_NEEDED
      fflsp = ffls + size - 1;
#endif

#if FFDEBUG != 0
      if (ffdebug)
	fprintf(stderr, "Stack size increased to %d\n", ffstacksize);
#endif

      if (ffssp >= ffss + ffstacksize - 1)
	FFABORT;
    }

#if FFDEBUG != 0
  if (ffdebug)
    fprintf(stderr, "Entering state %d\n", ffstate);
#endif

  goto ffbackup;
 ffbackup:

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
/* ffresume: */

  /* First try to decide what to do without reference to lookahead token.  */

  ffn = ffpact[ffstate];
  if (ffn == FFFLAG)
    goto ffdefault;

  /* Not known => get a lookahead token if don't already have one.  */

  /* ffchar is either FFEMPTY or FFEOF
     or a valid token in external form.  */

  if (ffchar == FFEMPTY)
    {
#if FFDEBUG != 0
      if (ffdebug)
	fprintf(stderr, "Reading a token: ");
#endif
      ffchar = FFLEX;
    }

  /* Convert token to internal form (in ffchar1) for indexing tables with */

  if (ffchar <= 0)		/* This means end of input. */
    {
      ffchar1 = 0;
      ffchar = FFEOF;		/* Don't call FFLEX any more */

#if FFDEBUG != 0
      if (ffdebug)
	fprintf(stderr, "Now at end of input.\n");
#endif
    }
  else
    {
      ffchar1 = FFTRANSLATE(ffchar);

#if FFDEBUG != 0
      if (ffdebug)
	{
	  fprintf (stderr, "Next token is %d (%s", ffchar, fftname[ffchar1]);
	  /* Give the individual parser a way to print the precise meaning
	     of a token, for further debugging info.  */
#ifdef FFPRINT
	  FFPRINT (stderr, ffchar, fflval);
#endif
	  fprintf (stderr, ")\n");
	}
#endif
    }

  ffn += ffchar1;
  if (ffn < 0 || ffn > FFLAST || ffcheck[ffn] != ffchar1)
    goto ffdefault;

  ffn = fftable[ffn];

  /* ffn is what to do for this token type in this state.
     Negative => reduce, -ffn is rule number.
     Positive => shift, ffn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (ffn < 0)
    {
      if (ffn == FFFLAG)
	goto fferrlab;
      ffn = -ffn;
      goto ffreduce;
    }
  else if (ffn == 0)
    goto fferrlab;

  if (ffn == FFFINAL)
    FFACCEPT;

  /* Shift the lookahead token.  */

#if FFDEBUG != 0
  if (ffdebug)
    fprintf(stderr, "Shifting token %d (%s), ", ffchar, fftname[ffchar1]);
#endif

  /* Discard the token being shifted unless it is eof.  */
  if (ffchar != FFEOF)
    ffchar = FFEMPTY;

  *++ffvsp = fflval;
#ifdef FFLSP_NEEDED
  *++fflsp = fflloc;
#endif

  /* count tokens shifted since error; after three, turn off error status.  */
  if (fferrstatus) fferrstatus--;

  ffstate = ffn;
  goto ffnewstate;

/* Do the default action for the current state.  */
ffdefault:

  ffn = ffdefact[ffstate];
  if (ffn == 0)
    goto fferrlab;

/* Do a reduction.  ffn is the number of a rule to reduce with.  */
ffreduce:
  fflen = ffr2[ffn];
  if (fflen > 0)
    ffval = ffvsp[1-fflen]; /* implement default value of the action */

#if FFDEBUG != 0
  if (ffdebug)
    {
      int i;

      fprintf (stderr, "Reducing via rule %d (line %d), ",
	       ffn, ffrline[ffn]);

      /* Print the symbols being reduced, and their result.  */
      for (i = ffprhs[ffn]; ffrhs[i] > 0; i++)
	fprintf (stderr, "%s ", fftname[ffrhs[i]]);
      fprintf (stderr, " -> %s\n", fftname[ffr1[ffn]]);
    }
#endif


  switch (ffn) {

case 4:
#line 125 "eval.y"
{  gParse.resultInfo.type    = INTEGER;
		   gParse.resultData.integer = ffvsp[-1].integer;       ;
    break;}
case 5:
#line 128 "eval.y"
{  gParse.resultInfo.type    = INTEGERV;
		   gParse.resultData.intvec  = ffvsp[-1].intvec;       ;
    break;}
case 6:
#line 131 "eval.y"
{  gParse.resultInfo.type    = BOOLEAN;
		   gParse.resultData.boolean = ffvsp[-1].boolean;       ;
    break;}
case 7:
#line 134 "eval.y"
{  gParse.resultInfo.type    = BOOLEANV;
		   gParse.resultData.boolvec = ffvsp[-1].boolvec;       ;
    break;}
case 8:
#line 137 "eval.y"
{  gParse.resultInfo.type    = REAL;
		   gParse.resultData.real    = ffvsp[-1].real;       ;
    break;}
case 9:
#line 140 "eval.y"
{  gParse.resultInfo.type    = REALV;
		   gParse.resultData.realvec = ffvsp[-1].realvec;       ;
    break;}
case 10:
#line 143 "eval.y"
{  gParse.resultInfo.type    = STRING;
		   strcpy(gParse.resultData.string,ffvsp[-1].string);  ;
    break;}
case 11:
#line 146 "eval.y"
{  gParse.resultInfo.type    = BITSTR;
		   strcpy(gParse.resultData.string,ffvsp[-1].string);  ;
    break;}
case 12:
#line 149 "eval.y"
{  fferrok; ;
    break;}
case 14:
#line 154 "eval.y"
{ bitand(ffval.string,ffvsp[-2].string,ffvsp[0].string); ;
    break;}
case 15:
#line 156 "eval.y"
{ bitor(ffval.string,ffvsp[-2].string,ffvsp[0].string); ;
    break;}
case 16:
#line 158 "eval.y"
{ bitnot(ffval.string,ffvsp[0].string); ;
    break;}
case 17:
#line 160 "eval.y"
{ strcpy(ffval.string,ffvsp[-1].string); ;
    break;}
case 19:
#line 165 "eval.y"
{ ffval.integer = ffvsp[-2].integer % ffvsp[0].integer; ;
    break;}
case 20:
#line 167 "eval.y"
{ ffval.integer = ffvsp[-2].integer + ffvsp[0].integer; ;
    break;}
case 21:
#line 169 "eval.y"
{ ffval.integer = ffvsp[-2].integer - ffvsp[0].integer; ;
    break;}
case 22:
#line 171 "eval.y"
{ ffval.integer = ffvsp[-2].integer * ffvsp[0].integer; ;
    break;}
case 23:
#line 173 "eval.y"
{ if(ffvsp[0].integer) ffval.integer = ffvsp[-2].integer / ffvsp[0].integer;
                  else {
                    fferror("divide by zero");
		    FFERROR;
                  }
                ;
    break;}
case 24:
#line 180 "eval.y"
{ ffval.integer = (int)(pow((double)ffvsp[-2].integer,(double)ffvsp[0].integer));;
    break;}
case 25:
#line 182 "eval.y"
{ ffval.integer = - ffvsp[0].integer; ;
    break;}
case 26:
#line 184 "eval.y"
{ ffval.integer = ffvsp[-1].integer; ;
    break;}
case 27:
#line 186 "eval.y"
{ if (ffvsp[0].boolean) ffval.integer = ffvsp[-2].integer; else ffval.integer = 0; ;
    break;}
case 28:
#line 188 "eval.y"
{ if (ffvsp[-2].boolean) ffval.integer = ffvsp[0].integer; else ffval.integer = 0; ;
    break;}
case 29:
#line 190 "eval.y"
{ int idx;
		  if (strcmp(ffvsp[-2].string,"SUM(") == 0) {
		     ffval.integer=0;
		     for(idx=0;idx<ffvsp[-1].boolvec.nelem;idx++) {
			if( ffvsp[-1].boolvec.bptr[idx] ) ffval.integer++;
			if( ffvsp[-1].boolvec.undef[idx] ) {
			   gParse.undef=1;
			}
		     }
		     free(ffvsp[-1].boolvec.bptr); free(ffvsp[-1].boolvec.undef);
		  } else {
                    fferror("Vector Function not supported");
		    FFERROR;
		  }
		;
    break;}
case 30:
#line 206 "eval.y"
{ int idx;
		  if (strcmp(ffvsp[-2].string,"SUM(") == 0) {
		     ffval.integer=0;
		     for(idx=0;idx<ffvsp[-1].intvec.nelem;idx++) {
			ffval.integer += ffvsp[-1].intvec.iptr[idx];
			if( ffvsp[-1].intvec.undef[idx] ) {
			   gParse.undef=1;
			}
		     }
		     free(ffvsp[-1].intvec.iptr); free(ffvsp[-1].intvec.undef);
		  } else {
                    fferror("Vector Function not supported");
		    FFERROR;
		  }
		;
    break;}
case 31:
#line 222 "eval.y"
{ if (strcmp(ffvsp[-2].string,"NELEM(") == 0)
                    ffval.integer = ffvsp[-1].intvec.nelem;
		  else {
                    fferror("Vector Function not supported");
		    FFERROR;
		  }
		;
    break;}
case 32:
#line 230 "eval.y"
{ if (strcmp(ffvsp[-2].string,"NELEM(") == 0)
                    ffval.integer = ffvsp[-1].realvec.nelem;
		  else {
                    fferror("Vector Function not supported");
		    FFERROR;
		  }
		;
    break;}
case 33:
#line 238 "eval.y"
{ if (strcmp(ffvsp[-2].string,"NELEM(") == 0)
                    ffval.integer = ffvsp[-1].boolvec.nelem;
		  else {
                    fferror("Vector Function not supported");
		    FFERROR;
		  }
		;
    break;}
case 34:
#line 246 "eval.y"
{ int idx,valid=1;
                  long elem=0;
                  if( ffvsp[-1].intvec.naxis == ffvsp[0].intseq.nelem ) {
                      for( idx=ffvsp[-1].intvec.naxis; idx; ) {
                         idx--;
                         if( ffvsp[0].intseq.val[idx]<1 || ffvsp[0].intseq.val[idx]>ffvsp[-1].intvec.naxes[idx] ) {
                             valid=0;
                             break;
                         }
                         elem = ffvsp[-1].intvec.naxes[idx]*elem + ffvsp[0].intseq.val[idx]-1;
                      }
                  } else valid=0;
                  if( valid ) {
                     ffval.integer = ffvsp[-1].intvec.iptr[elem];
                     gParse.undef = ffvsp[-1].intvec.undef[elem];
                     free(ffvsp[-1].intvec.iptr);  free(ffvsp[-1].intvec.undef);
                  } else if( ffvsp[0].intseq.nelem==1 && ffvsp[-1].intvec.naxis>1 &&
                             ffvsp[0].intseq.val[0]>=1 && ffvsp[0].intseq.val[0]<=ffvsp[-1].intvec.naxes[ffvsp[-1].intvec.naxis-1] ) {
                     elem=1;
                     ffvsp[-1].intvec.naxis--;
                     for( idx=0; idx<ffvsp[-1].intvec.naxis; idx++ ) elem *= ffvsp[-1].intvec.naxes[idx];
                     if( ffvsp[0].intseq.val[0]>1 ) {
                         memcpy( ffvsp[-1].intvec.iptr, ffvsp[-1].intvec.iptr+elem*(ffvsp[0].intseq.val[0]-1),
                                 elem*sizeof(long) );
                         memcpy( ffvsp[-1].intvec.undef, ffvsp[-1].intvec.undef+elem*(ffvsp[0].intseq.val[0]-1),
                                 elem*sizeof(char) );
                     }
                     ffvsp[-1].intvec.nelem = elem;
                     FFNEWBACKUP(INTEGERV,ffvsp[-1].intvec);
                  } else {
                     fferror("Bad vector index");
                     FFERROR;
                  }
                ;
    break;}
case 35:
#line 281 "eval.y"
{ ffval.integer = (int) ffvsp[0].real; ;
    break;}
case 36:
#line 283 "eval.y"
{ ffval.integer = ffvsp[0].integer; ;
    break;}
case 37:
#line 285 "eval.y"
{ if (ffvsp[0].boolean) ffval.integer = 1; else ffval.integer = 0; ;
    break;}
case 39:
#line 290 "eval.y"
{ int idx;
                  for (idx=0;idx<ffvsp[-2].intvec.nelem;idx++) ffvsp[-2].intvec.iptr[idx]%=ffvsp[0].integer;
                  ffval.intvec = ffvsp[-2].intvec;
                ;
    break;}
case 40:
#line 295 "eval.y"
{ if( scalarOPivec(&(ffval.intvec),ffvsp[-2].integer,'%',ffvsp[0].intvec) ) FFERROR; ;
    break;}
case 41:
#line 297 "eval.y"
{ if( ivecOPivec(&(ffval.intvec),ffvsp[-2].intvec,'%',ffvsp[0].intvec) ) FFERROR; ;
    break;}
case 42:
#line 300 "eval.y"
{ if( scalarOPivec(&(ffval.intvec),ffvsp[0].integer,'+',ffvsp[-2].intvec) ) FFERROR; ;
    break;}
case 43:
#line 302 "eval.y"
{ if( scalarOPivec(&(ffval.intvec),ffvsp[-2].integer,'+',ffvsp[0].intvec) ) FFERROR; ;
    break;}
case 44:
#line 304 "eval.y"
{ if( ivecOPivec(&(ffval.intvec),ffvsp[-2].intvec,'+',ffvsp[0].intvec) ) FFERROR; ;
    break;}
case 45:
#line 307 "eval.y"
{ if( scalarOPivec(&(ffval.intvec),-ffvsp[0].integer,'+',ffvsp[-2].intvec) ) FFERROR; ;
    break;}
case 46:
#line 309 "eval.y"
{ if( scalarOPivec(&(ffval.intvec),ffvsp[-2].integer,'-',ffvsp[0].intvec) ) FFERROR; ;
    break;}
case 47:
#line 311 "eval.y"
{ if( ivecOPivec(&(ffval.intvec),ffvsp[-2].intvec,'-',ffvsp[0].intvec) ) FFERROR; ;
    break;}
case 48:
#line 314 "eval.y"
{ if( scalarOPivec(&(ffval.intvec),ffvsp[0].integer,'*',ffvsp[-2].intvec) ) FFERROR; ;
    break;}
case 49:
#line 316 "eval.y"
{ if( scalarOPivec(&(ffval.intvec),ffvsp[-2].integer,'*',ffvsp[0].intvec) ) FFERROR; ;
    break;}
case 50:
#line 318 "eval.y"
{ if( ivecOPivec(&(ffval.intvec),ffvsp[-2].intvec,'*',ffvsp[0].intvec) ) FFERROR; ;
    break;}
case 51:
#line 321 "eval.y"
{ int idx;
		  if(ffvsp[0].integer) {
		     for (idx=0;idx<ffvsp[-2].intvec.nelem;idx++) ffvsp[-2].intvec.iptr[idx]/=ffvsp[0].integer;
		  } else {
		     fferror("divide by zero");
		     FFERROR;
		  }
                  ffval.intvec = ffvsp[-2].intvec;
                ;
    break;}
case 52:
#line 331 "eval.y"
{ if( scalarOPivec(&(ffval.intvec),ffvsp[-2].integer,'/',ffvsp[0].intvec) ) FFERROR; ;
    break;}
case 53:
#line 333 "eval.y"
{ if( ivecOPivec(&(ffval.intvec),ffvsp[-2].intvec,'/',ffvsp[0].intvec) ) FFERROR; ;
    break;}
case 54:
#line 336 "eval.y"
{ if( scalarOPivec(&(ffval.intvec),ffvsp[-2].integer,'*',CastBvecToIvec(ffvsp[0].boolvec)) ) FFERROR; ;
    break;}
case 55:
#line 338 "eval.y"
{ if( scalarOPivec(&(ffval.intvec),ffvsp[0].integer,'*',CastBvecToIvec(ffvsp[-2].boolvec)) ) FFERROR; ;
    break;}
case 56:
#line 340 "eval.y"
{ if( ivecOPivec(&(ffval.intvec),ffvsp[-2].intvec,'*',CastBvecToIvec(ffvsp[0].boolvec)) ) FFERROR; ;
    break;}
case 57:
#line 342 "eval.y"
{ if( ivecOPivec(&(ffval.intvec),CastBvecToIvec(ffvsp[-2].boolvec),'*',ffvsp[0].intvec) ) FFERROR; ;
    break;}
case 58:
#line 344 "eval.y"
{ int idx;
                  ffval.intvec = ffvsp[-2].intvec;
                  if( ! ffvsp[0].boolean )
                     for(idx=0;idx<ffval.intvec.nelem;idx++) ffval.intvec.iptr[idx]=0;
                ;
    break;}
case 59:
#line 350 "eval.y"
{ int idx;
                  ffval.intvec = ffvsp[0].intvec;
                  if( ! ffvsp[-2].boolean )
                     for(idx=0;idx<ffval.intvec.nelem;idx++) ffval.intvec.iptr[idx]=0;
                ;
    break;}
case 60:
#line 357 "eval.y"
{ int idx;
                  ffval.intvec.nelem = ffvsp[0].realvec.nelem;
                  ffval.intvec.naxis = ffvsp[0].realvec.naxis;
                  for(idx=0;idx<ffval.intvec.naxis;idx++) ffval.intvec.naxes[idx]=ffvsp[0].realvec.naxes[idx];
                  ffval.intvec.undef = ffvsp[0].realvec.undef;
                  ffval.intvec.iptr  = (long*)malloc(ffval.intvec.nelem*sizeof(long));
                  for(idx=0;idx<ffval.intvec.nelem;idx++) {
                     ffval.intvec.iptr[idx] = (long)ffvsp[0].realvec.rptr[idx];
		  }
		  free(ffvsp[0].realvec.rptr);
                ;
    break;}
case 61:
#line 369 "eval.y"
{ ffval.intvec = ffvsp[0].intvec; ;
    break;}
case 62:
#line 371 "eval.y"
{ int idx;
                  ffval.intvec.nelem = ffvsp[0].boolvec.nelem; 
                  ffval.intvec.naxis = ffvsp[0].boolvec.naxis;
                  for(idx=0;idx<ffval.intvec.naxis;idx++) ffval.intvec.naxes[idx]=ffvsp[0].boolvec.naxes[idx];
                  ffval.intvec.undef = ffvsp[0].boolvec.undef;
                  ffval.intvec.iptr  = (long*)malloc(ffval.intvec.nelem*sizeof(long));
                  for(idx=0;idx<ffval.intvec.nelem;idx++) {
                     if (ffvsp[0].boolvec.bptr[idx])
			ffval.intvec.iptr[idx] = 1;
		     else
			ffval.intvec.iptr[idx] = 0;
		  }
		  free(ffvsp[0].boolvec.bptr);
                ;
    break;}
case 63:
#line 386 "eval.y"
{ ffval.intvec = ffvsp[-1].intvec; ;
    break;}
case 65:
#line 391 "eval.y"
{ ffval.boolean = bitcmp(ffvsp[-2].string,ffvsp[0].string); ;
    break;}
case 66:
#line 393 "eval.y"
{ ffval.boolean = !bitcmp(ffvsp[-2].string,ffvsp[0].string); ;
    break;}
case 67:
#line 395 "eval.y"
{ ffval.boolean = bitlgte(ffvsp[-2].string,LESSTHAN,ffvsp[0].string); ;
    break;}
case 68:
#line 397 "eval.y"
{ ffval.boolean = bitlgte(ffvsp[-2].string,LESSTHANEQ,ffvsp[0].string); ;
    break;}
case 69:
#line 399 "eval.y"
{ ffval.boolean = bitlgte(ffvsp[-2].string,GREATERTHAN,ffvsp[0].string); ;
    break;}
case 70:
#line 401 "eval.y"
{ ffval.boolean = bitlgte(ffvsp[-2].string,GREATERTHANEQ,ffvsp[0].string); ;
    break;}
case 71:
#line 403 "eval.y"
{ ffval.boolean = (ffvsp[-2].integer > ffvsp[0].integer);  ;
    break;}
case 72:
#line 405 "eval.y"
{ ffval.boolean = (ffvsp[-2].integer < ffvsp[0].integer);  ;
    break;}
case 73:
#line 407 "eval.y"
{ ffval.boolean = (ffvsp[-2].integer >= ffvsp[0].integer); ;
    break;}
case 74:
#line 409 "eval.y"
{ ffval.boolean = (ffvsp[-2].integer <= ffvsp[0].integer); ;
    break;}
case 75:
#line 411 "eval.y"
{ ffval.boolean = (fabs((double)ffvsp[-2].integer - (double)ffvsp[0].integer) < APPROX); ;
    break;}
case 76:
#line 413 "eval.y"
{ ffval.boolean = (ffvsp[-2].integer == ffvsp[0].integer); ;
    break;}
case 77:
#line 415 "eval.y"
{ ffval.boolean = (ffvsp[-2].integer != ffvsp[0].integer); ;
    break;}
case 78:
#line 417 "eval.y"
{ ffval.boolean = (ffvsp[-2].real > ffvsp[0].real);  ;
    break;}
case 79:
#line 419 "eval.y"
{ ffval.boolean = (ffvsp[-2].real < ffvsp[0].real);  ;
    break;}
case 80:
#line 421 "eval.y"
{ ffval.boolean = (ffvsp[-2].real >= ffvsp[0].real); ;
    break;}
case 81:
#line 423 "eval.y"
{ ffval.boolean = (ffvsp[-2].real <= ffvsp[0].real); ;
    break;}
case 82:
#line 425 "eval.y"
{ ffval.boolean = (fabs(ffvsp[-2].real - ffvsp[0].real) < APPROX); ;
    break;}
case 83:
#line 427 "eval.y"
{ ffval.boolean = (ffvsp[-2].real == ffvsp[0].real); ;
    break;}
case 84:
#line 429 "eval.y"
{ ffval.boolean = (ffvsp[-2].real != ffvsp[0].real); ;
    break;}
case 85:
#line 431 "eval.y"
{ ffval.boolean = ((double)ffvsp[-2].integer > ffvsp[0].real); ;
    break;}
case 86:
#line 433 "eval.y"
{ ffval.boolean = ((double)ffvsp[-2].integer < ffvsp[0].real); ;
    break;}
case 87:
#line 435 "eval.y"
{ ffval.boolean = ((double)ffvsp[-2].integer >= ffvsp[0].real); ;
    break;}
case 88:
#line 437 "eval.y"
{ ffval.boolean = ((double)ffvsp[-2].integer <= ffvsp[0].real); ;
    break;}
case 89:
#line 439 "eval.y"
{ ffval.boolean = (fabs((double)ffvsp[-2].integer - ffvsp[0].real) < APPROX); ;
    break;}
case 90:
#line 441 "eval.y"
{ ffval.boolean = ((double)ffvsp[-2].integer == ffvsp[0].real); ;
    break;}
case 91:
#line 443 "eval.y"
{ ffval.boolean = ((double)ffvsp[-2].integer != ffvsp[0].real); ;
    break;}
case 92:
#line 445 "eval.y"
{ ffval.boolean = (ffvsp[-2].real > (double)ffvsp[0].integer); ;
    break;}
case 93:
#line 447 "eval.y"
{ ffval.boolean = (ffvsp[-2].real < (double)ffvsp[0].integer); ;
    break;}
case 94:
#line 449 "eval.y"
{ ffval.boolean = (ffvsp[-2].real >= (double)ffvsp[0].integer); ;
    break;}
case 95:
#line 451 "eval.y"
{ ffval.boolean = (ffvsp[-2].real <= (double)ffvsp[0].integer); ;
    break;}
case 96:
#line 453 "eval.y"
{ ffval.boolean = (fabs(ffvsp[-2].real - (double)ffvsp[0].integer) < APPROX); ;
    break;}
case 97:
#line 455 "eval.y"
{ ffval.boolean = (ffvsp[-2].real == (double)ffvsp[0].integer); ;
    break;}
case 98:
#line 457 "eval.y"
{ ffval.boolean = (ffvsp[-2].real != (double)ffvsp[0].integer); ;
    break;}
case 99:
#line 459 "eval.y"
{ ffval.boolean = (strcmp(ffvsp[-2].string,ffvsp[0].string) == 0); ;
    break;}
case 100:
#line 461 "eval.y"
{ ffval.boolean = (strcmp(ffvsp[-2].string,ffvsp[0].string) != 0); ;
    break;}
case 101:
#line 463 "eval.y"
{ ffval.boolean = (ffvsp[-2].boolean && ffvsp[0].boolean); ;
    break;}
case 102:
#line 465 "eval.y"
{ ffval.boolean = (ffvsp[-2].boolean || ffvsp[0].boolean); ;
    break;}
case 103:
#line 467 "eval.y"
{ ffval.boolean = ( (ffvsp[-2].boolean &&  ffvsp[0].boolean) || (!ffvsp[-2].boolean && !ffvsp[0].boolean) ); ;
    break;}
case 104:
#line 469 "eval.y"
{ ffval.boolean = ( (ffvsp[-2].boolean && !ffvsp[0].boolean) || (!ffvsp[-2].boolean &&  ffvsp[0].boolean) ); ;
    break;}
case 105:
#line 472 "eval.y"
{ ffval.boolean = ( ffvsp[-4].integer>=ffvsp[-2].integer && ffvsp[-4].integer<=ffvsp[0].integer ); ;
    break;}
case 106:
#line 474 "eval.y"
{ ffval.boolean = ( ffvsp[-4].integer>=ffvsp[-2].integer && ffvsp[-4].integer<=ffvsp[0].real ); ;
    break;}
case 107:
#line 476 "eval.y"
{ ffval.boolean = ( ffvsp[-4].integer>=ffvsp[-2].real && ffvsp[-4].integer<=ffvsp[0].integer ); ;
    break;}
case 108:
#line 478 "eval.y"
{ ffval.boolean = ( ffvsp[-4].integer>=ffvsp[-2].real && ffvsp[-4].integer<=ffvsp[0].real ); ;
    break;}
case 109:
#line 481 "eval.y"
{ ffval.boolean = ( ffvsp[-4].real>=ffvsp[-2].integer && ffvsp[-4].real<=ffvsp[0].integer ); ;
    break;}
case 110:
#line 483 "eval.y"
{ ffval.boolean = ( ffvsp[-4].real>=ffvsp[-2].integer && ffvsp[-4].real<=ffvsp[0].real ); ;
    break;}
case 111:
#line 485 "eval.y"
{ ffval.boolean = ( ffvsp[-4].real>=ffvsp[-2].real && ffvsp[-4].real<=ffvsp[0].integer ); ;
    break;}
case 112:
#line 487 "eval.y"
{ ffval.boolean = ( ffvsp[-4].real>=ffvsp[-2].real && ffvsp[-4].real<=ffvsp[0].real ); ;
    break;}
case 113:
#line 490 "eval.y"
{
                  switch(ffvsp[-1].realseq.nelem) {
                  case 3:
		     if (strcmp(ffvsp[-2].string,"NEAR(") == 0)
		       ffval.boolean = near(ffvsp[-1].realseq.val[0],ffvsp[-1].realseq.val[1],ffvsp[-1].realseq.val[2]);
		     else {
                       fferror("Boolean Function not supported");
		       FFERROR;
		     }
                     break;
                  case 5:
                     if (strcmp(ffvsp[-2].string,"CIRCLE(") == 0)
                        ffval.boolean = circle(ffvsp[-1].realseq.val[0],ffvsp[-1].realseq.val[1],ffvsp[-1].realseq.val[2],
                                    ffvsp[-1].realseq.val[3],ffvsp[-1].realseq.val[4]);
                     else {
                        fferror("Boolean Function not supported");
		        FFERROR;
		     }
                     break;
                  case 7:
                     if (strcmp(ffvsp[-2].string,"BOX(") == 0)
                       ffval.boolean = saobox(ffvsp[-1].realseq.val[0],ffvsp[-1].realseq.val[1],ffvsp[-1].realseq.val[2],ffvsp[-1].realseq.val[3],
                                   ffvsp[-1].realseq.val[4],ffvsp[-1].realseq.val[5],ffvsp[-1].realseq.val[6]);
                     else if (strcmp(ffvsp[-2].string,"ELLIPSE(") == 0)
                       ffval.boolean = ellipse(ffvsp[-1].realseq.val[0],ffvsp[-1].realseq.val[1],ffvsp[-1].realseq.val[2],ffvsp[-1].realseq.val[3],
                                   ffvsp[-1].realseq.val[4],ffvsp[-1].realseq.val[5],ffvsp[-1].realseq.val[6]);
                     else {
                       fferror("SAO Image Function not supported");
		       FFERROR;
		     }
                     break;
                  default:
                     fferror("Wrong number of arguments");
		     FFERROR;
                     break;
                  }
		;
    break;}
case 114:
#line 528 "eval.y"
{ int idx,valid=1;
                  long elem=0;
                  if( ffvsp[-1].boolvec.naxis == ffvsp[0].intseq.nelem ) {
                      for( idx=ffvsp[-1].boolvec.naxis; idx; ) {
                         idx--;
                         if( ffvsp[0].intseq.val[idx]<1 || ffvsp[0].intseq.val[idx]>ffvsp[-1].boolvec.naxes[idx] ) {
                             valid=0;
                             break;
                         }
                         elem = ffvsp[-1].boolvec.naxes[idx]*elem + ffvsp[0].intseq.val[idx]-1;
                      }
                  } else valid=0;
                  if( valid ) {
		     ffval.boolean = ffvsp[-1].boolvec.bptr[elem];
                     gParse.undef = ffvsp[-1].boolvec.undef[elem];
		     free(ffvsp[-1].boolvec.bptr);  free(ffvsp[-1].boolvec.undef);
                  } else if( ffvsp[0].intseq.nelem==1 && ffvsp[-1].boolvec.naxis>1 &&
                             ffvsp[0].intseq.val[0]>=1 && ffvsp[0].intseq.val[0]<=ffvsp[-1].boolvec.naxes[ffvsp[-1].boolvec.naxis-1] ) {
                     elem=1;
                     ffvsp[-1].boolvec.naxis--;
                     for( idx=0; idx<ffvsp[-1].boolvec.naxis; idx++ ) elem *= ffvsp[-1].boolvec.naxes[idx];
                     if( ffvsp[0].intseq.val[0]>1 ) {
                         memcpy( ffvsp[-1].boolvec.bptr, ffvsp[-1].boolvec.bptr+elem*(ffvsp[0].intseq.val[0]-1),
                                 elem*sizeof(char) );
                         memcpy( ffvsp[-1].boolvec.undef, ffvsp[-1].boolvec.undef+elem*(ffvsp[0].intseq.val[0]-1),
                                 elem*sizeof(char) );
                     }
                     ffvsp[-1].boolvec.nelem = elem;
                     FFNEWBACKUP(BOOLEANV, ffvsp[-1].boolvec);
                  } else {
                     fferror("Bad vector index");
                     FFERROR;
                  }
                ;
    break;}
case 115:
#line 563 "eval.y"
{ ffval.boolean = ( ! ffvsp[0].boolean ); ;
    break;}
case 116:
#line 565 "eval.y"
{ ffval.boolean = ffvsp[-1].boolean; ;
    break;}
case 118:
#line 570 "eval.y"
{ int idx;
                  if( ffvsp[-2].boolvec.nelem==ffvsp[0].boolvec.nelem ) {
                     for(idx=0;idx<ffvsp[-2].boolvec.nelem;idx++) {
                         ffvsp[-2].boolvec.bptr[idx]   = (ffvsp[-2].boolvec.bptr[idx] && ffvsp[0].boolvec.bptr[idx]);
                         ffvsp[-2].boolvec.undef[idx] |= ffvsp[0].boolvec.undef[idx];
                     }
                     free(ffvsp[0].boolvec.bptr); free(ffvsp[0].boolvec.undef);
                     ffval.boolvec = ffvsp[-2].boolvec;
                  } else {
                     free(ffvsp[-2].boolvec.bptr); free(ffvsp[0].boolvec.undef);
                     free(ffvsp[0].boolvec.bptr); free(ffvsp[0].boolvec.undef);
                     fferror("vector sizes do not match");
		     FFERROR;
                  }
                ;
    break;}
case 119:
#line 586 "eval.y"
{ int idx;
                  if( ffvsp[-2].boolvec.nelem==ffvsp[0].boolvec.nelem ) {
                     for(idx=0;idx<ffvsp[-2].boolvec.nelem;idx++) {
                         ffvsp[-2].boolvec.bptr[idx]   = (ffvsp[-2].boolvec.bptr[idx] || ffvsp[0].boolvec.bptr[idx]);
                         ffvsp[-2].boolvec.undef[idx] |= ffvsp[0].boolvec.undef[idx];
                     }
                     free(ffvsp[0].boolvec.bptr); free(ffvsp[0].boolvec.undef);
                     ffval.boolvec = ffvsp[-2].boolvec;
                  } else {
                     free(ffvsp[-2].boolvec.bptr); free(ffvsp[0].boolvec.undef);
                     free(ffvsp[0].boolvec.bptr); free(ffvsp[0].boolvec.undef);
                     fferror("vector sizes do not match");
		     FFERROR;
                  }
                ;
    break;}
case 120:
#line 602 "eval.y"
{ int idx;
                  if( ffvsp[-2].boolvec.nelem==ffvsp[0].boolvec.nelem ) {
                     for(idx=0;idx<ffvsp[-2].boolvec.nelem;idx++) {
                         ffvsp[-2].boolvec.bptr[idx]  =   ( ffvsp[-2].boolvec.bptr[idx] &&  ffvsp[0].boolvec.bptr[idx])
                                        || (!ffvsp[-2].boolvec.bptr[idx] && !ffvsp[0].boolvec.bptr[idx]);
                         ffvsp[-2].boolvec.undef[idx] |= ffvsp[0].boolvec.undef[idx];
                     }
                     free(ffvsp[0].boolvec.bptr); free(ffvsp[0].boolvec.undef);
                     ffval.boolvec = ffvsp[-2].boolvec;
                  } else {
                     free(ffvsp[-2].boolvec.bptr); free(ffvsp[0].boolvec.undef);
                     free(ffvsp[0].boolvec.bptr); free(ffvsp[0].boolvec.undef);
                     fferror("vector sizes do not match");
		     FFERROR;
                  }
                ;
    break;}
case 121:
#line 619 "eval.y"
{ int idx;
                  if( ffvsp[-2].boolvec.nelem==ffvsp[0].boolvec.nelem ) {
                     for(idx=0;idx<ffvsp[-2].boolvec.nelem;idx++) {
                         ffvsp[-2].boolvec.bptr[idx]  =   ( ffvsp[-2].boolvec.bptr[idx] && !ffvsp[0].boolvec.bptr[idx])
                                        || (!ffvsp[-2].boolvec.bptr[idx] &&  ffvsp[0].boolvec.bptr[idx]);
                         ffvsp[-2].boolvec.undef[idx] |= ffvsp[0].boolvec.undef[idx];
                     }
                     free(ffvsp[0].boolvec.bptr); free(ffvsp[0].boolvec.undef);
                     ffval.boolvec = ffvsp[-2].boolvec;
                  } else {
                     free(ffvsp[-2].boolvec.bptr); free(ffvsp[0].boolvec.undef);
                     free(ffvsp[0].boolvec.bptr); free(ffvsp[0].boolvec.undef);
                     fferror("vector sizes do not match");
		     FFERROR;
                  }
                ;
    break;}
case 122:
#line 636 "eval.y"
{ int idx;
                  for(idx=0;idx<ffvsp[0].boolvec.nelem;idx++) {
                     ffvsp[0].boolvec.bptr[idx] = ( ! ffvsp[0].boolvec.bptr[idx] );
                  }
                  ffval.boolvec = ffvsp[0].boolvec;
                ;
    break;}
case 123:
#line 644 "eval.y"
{ if( scalarOPivec(&(ffval.boolvec),ffvsp[0].integer,EQ,ffvsp[-2].intvec) ) FFERROR; ;
    break;}
case 124:
#line 646 "eval.y"
{ if( scalarOPivec(&(ffval.boolvec),ffvsp[-2].integer,EQ,ffvsp[0].intvec) ) FFERROR; ;
    break;}
case 125:
#line 648 "eval.y"
{ if( ivecOPivec(&(ffval.boolvec),ffvsp[-2].intvec,EQ,ffvsp[0].intvec) ) FFERROR; ;
    break;}
case 126:
#line 651 "eval.y"
{ if( scalarOPivec(&(ffval.boolvec),ffvsp[0].integer,NE,ffvsp[-2].intvec) ) FFERROR; ;
    break;}
case 127:
#line 653 "eval.y"
{ if( scalarOPivec(&(ffval.boolvec),ffvsp[-2].integer,NE,ffvsp[0].intvec) ) FFERROR; ;
    break;}
case 128:
#line 655 "eval.y"
{ if( ivecOPivec(&(ffval.boolvec),ffvsp[-2].intvec,NE,ffvsp[0].intvec) ) FFERROR; ;
    break;}
case 129:
#line 658 "eval.y"
{ if( scalarOPivec(&(ffval.boolvec),ffvsp[0].integer,LT,ffvsp[-2].intvec) ) FFERROR; ;
    break;}
case 130:
#line 660 "eval.y"
{ if( scalarOPivec(&(ffval.boolvec),ffvsp[-2].integer,GT,ffvsp[0].intvec) ) FFERROR; ;
    break;}
case 131:
#line 662 "eval.y"
{ if( ivecOPivec(&(ffval.boolvec),ffvsp[-2].intvec,GT,ffvsp[0].intvec) ) FFERROR; ;
    break;}
case 132:
#line 665 "eval.y"
{ if( scalarOPivec(&(ffval.boolvec),ffvsp[0].integer,GT,ffvsp[-2].intvec) ) FFERROR; ;
    break;}
case 133:
#line 667 "eval.y"
{ if( scalarOPivec(&(ffval.boolvec),ffvsp[-2].integer,LT,ffvsp[0].intvec) ) FFERROR; ;
    break;}
case 134:
#line 669 "eval.y"
{ if( ivecOPivec(&(ffval.boolvec),ffvsp[-2].intvec,LT,ffvsp[0].intvec) ) FFERROR; ;
    break;}
case 135:
#line 672 "eval.y"
{ if( scalarOPivec(&(ffval.boolvec),ffvsp[0].integer,LTE,ffvsp[-2].intvec) ) FFERROR; ;
    break;}
case 136:
#line 674 "eval.y"
{ if( scalarOPivec(&(ffval.boolvec),ffvsp[-2].integer,GTE,ffvsp[0].intvec) ) FFERROR; ;
    break;}
case 137:
#line 676 "eval.y"
{ if( ivecOPivec(&(ffval.boolvec),ffvsp[-2].intvec,GTE,ffvsp[0].intvec) ) FFERROR; ;
    break;}
case 138:
#line 679 "eval.y"
{ if( scalarOPivec(&(ffval.boolvec),ffvsp[0].integer,GTE,ffvsp[-2].intvec) ) FFERROR; ;
    break;}
case 139:
#line 681 "eval.y"
{ if( scalarOPivec(&(ffval.boolvec),ffvsp[-2].integer,LTE,ffvsp[0].intvec) ) FFERROR; ;
    break;}
case 140:
#line 683 "eval.y"
{ if( ivecOPivec(&(ffval.boolvec),ffvsp[-2].intvec,LTE,ffvsp[0].intvec) ) FFERROR; ;
    break;}
case 141:
#line 686 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[0].real,EQ,ffvsp[-2].realvec) ) FFERROR; ;
    break;}
case 142:
#line 688 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),(double)ffvsp[0].integer,EQ,ffvsp[-2].realvec) ) FFERROR; ;
    break;}
case 143:
#line 690 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[-2].real,EQ,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 144:
#line 692 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),(double)ffvsp[-2].integer,EQ,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 145:
#line 694 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[0].real,EQ,CastIvecToRvec(ffvsp[-2].intvec)) ) FFERROR; ;
    break;}
case 146:
#line 696 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[-2].real,EQ,CastIvecToRvec(ffvsp[0].intvec)) ) FFERROR; ;
    break;}
case 147:
#line 698 "eval.y"
{ if( rvecOPrvec(&(ffval.boolvec),CastIvecToRvec(ffvsp[-2].intvec),EQ,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 148:
#line 700 "eval.y"
{ if( rvecOPrvec(&(ffval.boolvec),ffvsp[-2].realvec,EQ,CastIvecToRvec(ffvsp[0].intvec)) ) FFERROR; ;
    break;}
case 149:
#line 702 "eval.y"
{ if( rvecOPrvec(&(ffval.boolvec),ffvsp[-2].realvec,EQ,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 150:
#line 705 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[0].real,NE,ffvsp[-2].realvec) ) FFERROR; ;
    break;}
case 151:
#line 707 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),(double)ffvsp[0].integer,NE,ffvsp[-2].realvec) ) FFERROR; ;
    break;}
case 152:
#line 709 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[-2].real,NE,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 153:
#line 711 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),(double)ffvsp[-2].integer,NE,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 154:
#line 713 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[0].real,NE,CastIvecToRvec(ffvsp[-2].intvec)) ) FFERROR; ;
    break;}
case 155:
#line 715 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[-2].real,NE,CastIvecToRvec(ffvsp[0].intvec)) ) FFERROR; ;
    break;}
case 156:
#line 717 "eval.y"
{ if( rvecOPrvec(&(ffval.boolvec),CastIvecToRvec(ffvsp[-2].intvec),NE,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 157:
#line 719 "eval.y"
{ if( rvecOPrvec(&(ffval.boolvec),ffvsp[-2].realvec,NE,CastIvecToRvec(ffvsp[0].intvec)) ) FFERROR; ;
    break;}
case 158:
#line 721 "eval.y"
{ if( rvecOPrvec(&(ffval.boolvec),ffvsp[-2].realvec,NE,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 159:
#line 724 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[0].real,LT,ffvsp[-2].realvec) ) FFERROR; ;
    break;}
case 160:
#line 726 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),(double)ffvsp[0].integer,LT,ffvsp[-2].realvec) ) FFERROR; ;
    break;}
case 161:
#line 728 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[-2].real,GT,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 162:
#line 730 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),(double)ffvsp[-2].integer,GT,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 163:
#line 732 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[0].real,LT,CastIvecToRvec(ffvsp[-2].intvec)) ) FFERROR; ;
    break;}
case 164:
#line 734 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[-2].real,GT,CastIvecToRvec(ffvsp[0].intvec)) ) FFERROR; ;
    break;}
case 165:
#line 736 "eval.y"
{ if( rvecOPrvec(&(ffval.boolvec),CastIvecToRvec(ffvsp[-2].intvec),GT,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 166:
#line 738 "eval.y"
{ if( rvecOPrvec(&(ffval.boolvec),ffvsp[-2].realvec,GT,CastIvecToRvec(ffvsp[0].intvec)) ) FFERROR; ;
    break;}
case 167:
#line 740 "eval.y"
{ if( rvecOPrvec(&(ffval.boolvec),ffvsp[-2].realvec,GT,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 168:
#line 743 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[0].real,GT,ffvsp[-2].realvec) ) FFERROR; ;
    break;}
case 169:
#line 745 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),(double)ffvsp[0].integer,GT,ffvsp[-2].realvec) ) FFERROR; ;
    break;}
case 170:
#line 747 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[-2].real,LT,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 171:
#line 749 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),(double)ffvsp[-2].integer,LT,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 172:
#line 751 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[0].real,GT,CastIvecToRvec(ffvsp[-2].intvec)) ) FFERROR; ;
    break;}
case 173:
#line 753 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[-2].real,LT,CastIvecToRvec(ffvsp[0].intvec)) ) FFERROR; ;
    break;}
case 174:
#line 755 "eval.y"
{ if( rvecOPrvec(&(ffval.boolvec),CastIvecToRvec(ffvsp[-2].intvec),LT,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 175:
#line 757 "eval.y"
{ if( rvecOPrvec(&(ffval.boolvec),ffvsp[-2].realvec,LT,CastIvecToRvec(ffvsp[0].intvec)) ) FFERROR; ;
    break;}
case 176:
#line 759 "eval.y"
{ if( rvecOPrvec(&(ffval.boolvec),ffvsp[-2].realvec,LT,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 177:
#line 762 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[0].real,LTE,ffvsp[-2].realvec) ) FFERROR; ;
    break;}
case 178:
#line 764 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),(double)ffvsp[0].integer,LTE,ffvsp[-2].realvec) ) FFERROR; ;
    break;}
case 179:
#line 766 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[-2].real,GTE,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 180:
#line 768 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),(double)ffvsp[-2].integer,GTE,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 181:
#line 770 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[0].real,LTE,CastIvecToRvec(ffvsp[-2].intvec)) ) FFERROR; ;
    break;}
case 182:
#line 772 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[-2].real,GTE,CastIvecToRvec(ffvsp[0].intvec)) ) FFERROR; ;
    break;}
case 183:
#line 774 "eval.y"
{ if( rvecOPrvec(&(ffval.boolvec),CastIvecToRvec(ffvsp[-2].intvec),GTE,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 184:
#line 776 "eval.y"
{ if( rvecOPrvec(&(ffval.boolvec),ffvsp[-2].realvec,GTE,CastIvecToRvec(ffvsp[0].intvec)) ) FFERROR; ;
    break;}
case 185:
#line 778 "eval.y"
{ if( rvecOPrvec(&(ffval.boolvec),ffvsp[-2].realvec,GTE,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 186:
#line 781 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[0].real,GTE,ffvsp[-2].realvec) ) FFERROR; ;
    break;}
case 187:
#line 783 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),(double)ffvsp[0].integer,GTE,ffvsp[-2].realvec) ) FFERROR; ;
    break;}
case 188:
#line 785 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[-2].real,LTE,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 189:
#line 787 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),(double)ffvsp[-2].integer,LTE,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 190:
#line 789 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[0].real,GTE,CastIvecToRvec(ffvsp[-2].intvec)) ) FFERROR; ;
    break;}
case 191:
#line 791 "eval.y"
{ if( scalarOPrvec(&(ffval.boolvec),ffvsp[-2].real,LTE,CastIvecToRvec(ffvsp[0].intvec)) ) FFERROR; ;
    break;}
case 192:
#line 793 "eval.y"
{ if( rvecOPrvec(&(ffval.boolvec),CastIvecToRvec(ffvsp[-2].intvec),LTE,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 193:
#line 795 "eval.y"
{ if( rvecOPrvec(&(ffval.boolvec),ffvsp[-2].realvec,LTE,CastIvecToRvec(ffvsp[0].intvec)) ) FFERROR; ;
    break;}
case 194:
#line 797 "eval.y"
{ if( rvecOPrvec(&(ffval.boolvec),ffvsp[-2].realvec,LTE,ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 195:
#line 800 "eval.y"
{ ffval.boolvec = ffvsp[-1].boolvec; ;
    break;}
case 197:
#line 805 "eval.y"
{ ffval.real = ffvsp[-2].real + ffvsp[0].real; ;
    break;}
case 198:
#line 807 "eval.y"
{ ffval.real = ffvsp[-2].real - ffvsp[0].real; ;
    break;}
case 199:
#line 809 "eval.y"
{ ffval.real = ffvsp[-2].real * ffvsp[0].real; ;
    break;}
case 200:
#line 811 "eval.y"
{ if(ffvsp[0].real) ffval.real = ffvsp[-2].real / ffvsp[0].real;
                  else {
                    fferror("divide by zero");
		    FFERROR;
                  }
                ;
    break;}
case 201:
#line 818 "eval.y"
{ ffval.real = pow(ffvsp[-2].real,ffvsp[0].real);;
    break;}
case 202:
#line 820 "eval.y"
{ ffval.real = (double)ffvsp[-2].integer + ffvsp[0].real; ;
    break;}
case 203:
#line 822 "eval.y"
{ ffval.real = (double)ffvsp[-2].integer - ffvsp[0].real; ;
    break;}
case 204:
#line 824 "eval.y"
{ ffval.real = (double)ffvsp[-2].integer * ffvsp[0].real; ;
    break;}
case 205:
#line 826 "eval.y"
{ if(ffvsp[0].real) ffval.real = (double)ffvsp[-2].integer / ffvsp[0].real;
                  else {
                    fferror("divide by zero");
		    FFERROR;
                  }
                ;
    break;}
case 206:
#line 833 "eval.y"
{ ffval.real = pow((double)ffvsp[-2].integer,ffvsp[0].real);;
    break;}
case 207:
#line 835 "eval.y"
{ if (ffvsp[0].boolean) ffval.real = ffvsp[-2].real; else ffval.real = 0.0; ;
    break;}
case 208:
#line 837 "eval.y"
{ if (ffvsp[-2].boolean) ffval.real = ffvsp[0].real; else ffval.real = 0.0; ;
    break;}
case 209:
#line 839 "eval.y"
{ ffval.real = ffvsp[-2].real + (double)ffvsp[0].integer; ;
    break;}
case 210:
#line 841 "eval.y"
{ ffval.real = ffvsp[-2].real - (double)ffvsp[0].integer; ;
    break;}
case 211:
#line 843 "eval.y"
{ ffval.real = ffvsp[-2].real * (double)ffvsp[0].integer; ;
    break;}
case 212:
#line 845 "eval.y"
{ if(ffvsp[0].integer) ffval.real = ffvsp[-2].real / (double)ffvsp[0].integer;
                  else {
                    fferror("divide by zero");
		    FFERROR;
                  }
                ;
    break;}
case 213:
#line 852 "eval.y"
{ ffval.real = pow(ffvsp[-2].real,(double)ffvsp[0].integer);;
    break;}
case 214:
#line 854 "eval.y"
{ int idx;
		  if (strcmp(ffvsp[-2].string,"SUM(") == 0) {
		     ffval.real=0.0;
		     for(idx=0;idx<ffvsp[-1].realvec.nelem;idx++) {
			ffval.real += ffvsp[-1].realvec.rptr[idx];
			if( ffvsp[-1].realvec.undef[idx] ) {
			   gParse.undef=1;
			}
		     }
		     free(ffvsp[-1].realvec.rptr); free(ffvsp[-1].realvec.undef);
		  } else {
                    fferror("Vector Function not supported");
		    FFERROR;
		  }
		;
    break;}
case 215:
#line 870 "eval.y"
{ if (strcmp(ffvsp[-1].string,"RANDOM(") == 0)
                    ffval.real = (double)rand() / (double) 2147483647;
                  else
		    {
                     fferror("Function() not supported");
		     FFERROR;
		    }
                ;
    break;}
case 216:
#line 879 "eval.y"
{ if (strcmp(ffvsp[-2].string,"SIN(") == 0)
                    ffval.real = sin(ffvsp[-1].real);
                  else if (strcmp(ffvsp[-2].string,"COS(") == 0)
                    ffval.real = cos(ffvsp[-1].real);
                  else if (strcmp(ffvsp[-2].string,"TAN(") == 0)
                    ffval.real = tan(ffvsp[-1].real);
                  else if (strcmp(ffvsp[-2].string,"ARCSIN(") == 0)
                    ffval.real = asin(ffvsp[-1].real);
                  else if (strcmp(ffvsp[-2].string,"ARCCOS(") == 0)
                    ffval.real = acos(ffvsp[-1].real);
                  else if (strcmp(ffvsp[-2].string,"ARCTAN(") == 0)
                    ffval.real = atan(ffvsp[-1].real);
                  else if (strcmp(ffvsp[-2].string,"EXP(") == 0)
                    ffval.real = exp(ffvsp[-1].real);
                  else if (strcmp(ffvsp[-2].string,"LOG(") == 0)
                    ffval.real = log(ffvsp[-1].real);
                  else if (strcmp(ffvsp[-2].string,"LOG10(") == 0)
                    ffval.real = log10(ffvsp[-1].real);
                  else if (strcmp(ffvsp[-2].string,"SQRT(") == 0)
                    ffval.real = sqrt(ffvsp[-1].real);
                  else if (strcmp(ffvsp[-2].string,"ABS(") == 0)
                    ffval.real = fabs(ffvsp[-1].real);
                  else
		    {
                     fferror("Function(r) not supported");
		     FFERROR;
		    }
                ;
    break;}
case 217:
#line 908 "eval.y"
{ if (strcmp(ffvsp[-2].string,"SIN(") == 0)
                    ffval.real = sin((double)ffvsp[-1].integer);
                  else if (strcmp(ffvsp[-2].string,"COS(") == 0)
                    ffval.real = cos((double)ffvsp[-1].integer);
                  else if (strcmp(ffvsp[-2].string,"TAN(") == 0)
                    ffval.real = tan((double)ffvsp[-1].integer);
                  else if (strcmp(ffvsp[-2].string,"ARCSIN(") == 0)
                    ffval.real = asin((double)ffvsp[-1].integer);
                  else if (strcmp(ffvsp[-2].string,"ARCCOS(") == 0)
                    ffval.real = acos((double)ffvsp[-1].integer);
                  else if (strcmp(ffvsp[-2].string,"ARCTAN(") == 0)
                    ffval.real = atan((double)ffvsp[-1].integer);
                  else if (strcmp(ffvsp[-2].string,"EXP(") == 0)
                    ffval.real = exp((double)ffvsp[-1].integer);
                  else if (strcmp(ffvsp[-2].string,"LOG(") == 0)
                    ffval.real = log((double)ffvsp[-1].integer);
                  else if (strcmp(ffvsp[-2].string,"LOG10(") == 0)
                    ffval.real = log10((double)ffvsp[-1].integer);
                  else if (strcmp(ffvsp[-2].string,"SQRT(") == 0)
                    ffval.real = sqrt((double)ffvsp[-1].integer);
                  else if (strcmp(ffvsp[-2].string,"ABS(") == 0)
                    ffval.real = fabs((double)ffvsp[-1].integer);
                  else
		    {
                     fferror("Function(i) not supported");
		     FFERROR;
		    }
                ;
    break;}
case 218:
#line 937 "eval.y"
{ if (strcmp(ffvsp[-2].string,"ARCTAN2(") == 0)
                    {
                     if( ffvsp[-1].realseq.nelem==2 )
                        ffval.real = atan2(ffvsp[-1].realseq.val[0],ffvsp[-1].realseq.val[1]);
                     else {
                        fferror("Wrong number of arguments to ARCTAN2");
		        FFERROR;
                     }
                    }
                  else
		    {
                     fferror("Function(r,r) not supported");
		     FFERROR;
		    }
                ;
    break;}
case 219:
#line 953 "eval.y"
{ ffval.real = - ffvsp[0].real; ;
    break;}
case 220:
#line 955 "eval.y"
{ ffval.real = ffvsp[-1].real; ;
    break;}
case 221:
#line 957 "eval.y"
{ int idx,valid=1;
                  long elem=0;
                  if( ffvsp[-1].realvec.naxis == ffvsp[0].intseq.nelem ) {
                      for( idx=ffvsp[-1].realvec.naxis; idx; ) {
                         idx--;
                         if( ffvsp[0].intseq.val[idx]<1 || ffvsp[0].intseq.val[idx]>ffvsp[-1].realvec.naxes[idx] ) {
                             valid=0;
                             break;
                         }
                         elem = ffvsp[-1].realvec.naxes[idx]*elem + ffvsp[0].intseq.val[idx]-1;
                      }
                  } else valid=0;
                  if( valid ) {
		     ffval.real = ffvsp[-1].realvec.rptr[elem];
                     gParse.undef = ffvsp[-1].realvec.undef[elem];
		     free(ffvsp[-1].realvec.rptr);  free(ffvsp[-1].realvec.undef);
                  } else if( ffvsp[0].intseq.nelem==1 && ffvsp[-1].realvec.naxis>1 &&
                             ffvsp[0].intseq.val[0]>=1 && ffvsp[0].intseq.val[0]<=ffvsp[-1].realvec.naxes[ffvsp[-1].realvec.naxis-1] ) {
                     elem=1;
                     ffvsp[-1].realvec.naxis--;
                     for( idx=0; idx<ffvsp[-1].realvec.naxis; idx++ ) elem *= ffvsp[-1].realvec.naxes[idx];
                     if( ffvsp[0].intseq.val[0]>1 ) {
                         memcpy( ffvsp[-1].realvec.rptr, ffvsp[-1].realvec.rptr+elem*(ffvsp[0].intseq.val[0]-1),
                                 elem*sizeof(double) );
                         memcpy( ffvsp[-1].realvec.undef, ffvsp[-1].realvec.undef+elem*(ffvsp[0].intseq.val[0]-1),
                                 elem*sizeof(char) );
                     }
                     ffvsp[-1].realvec.nelem = elem;
                     FFNEWBACKUP(REALV, ffvsp[-1].realvec);
                  } else {
                     fferror("Bad vector index");
                     FFERROR;
                  }
                ;
    break;}
case 222:
#line 992 "eval.y"
{ ffval.real = (double) ffvsp[0].integer; ;
    break;}
case 223:
#line 994 "eval.y"
{ ffval.real = ffvsp[0].real; ;
    break;}
case 224:
#line 996 "eval.y"
{ if (ffvsp[0].boolean) ffval.real = 1.0; else ffval.real = 0.0; ;
    break;}
case 226:
#line 1001 "eval.y"
{ if( scalarOPrvec(&(ffval.realvec),ffvsp[0].real,'+',ffvsp[-2].realvec) ) FFERROR; ;
    break;}
case 227:
#line 1003 "eval.y"
{ if( scalarOPrvec(&(ffval.realvec),(double)ffvsp[0].integer,'+',ffvsp[-2].realvec) ) FFERROR; ;
    break;}
case 228:
#line 1005 "eval.y"
{ if( scalarOPrvec(&(ffval.realvec),ffvsp[-2].real,'+',ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 229:
#line 1007 "eval.y"
{ if( scalarOPrvec(&(ffval.realvec),(double)ffvsp[-2].integer,'+',ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 230:
#line 1009 "eval.y"
{ if( scalarOPrvec(&(ffval.realvec),ffvsp[0].real,'+',CastIvecToRvec(ffvsp[-2].intvec)) ) FFERROR; ;
    break;}
case 231:
#line 1011 "eval.y"
{ if( scalarOPrvec(&(ffval.realvec),ffvsp[-2].real,'+',CastIvecToRvec(ffvsp[0].intvec)) ) FFERROR; ;
    break;}
case 232:
#line 1013 "eval.y"
{ if( rvecOPrvec(&(ffval.realvec),CastIvecToRvec(ffvsp[-2].intvec),'+',ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 233:
#line 1015 "eval.y"
{ if( rvecOPrvec(&(ffval.realvec),ffvsp[-2].realvec,'+',CastIvecToRvec(ffvsp[0].intvec)) ) FFERROR; ;
    break;}
case 234:
#line 1017 "eval.y"
{ if( rvecOPrvec(&(ffval.realvec),ffvsp[-2].realvec,'+',ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 235:
#line 1020 "eval.y"
{ if( scalarOPrvec(&(ffval.realvec),-ffvsp[0].real,'+',ffvsp[-2].realvec) ) FFERROR; ;
    break;}
case 236:
#line 1022 "eval.y"
{ if( scalarOPrvec(&(ffval.realvec),(double)(-ffvsp[0].integer),'+',ffvsp[-2].realvec) ) FFERROR; ;
    break;}
case 237:
#line 1024 "eval.y"
{ if( scalarOPrvec(&(ffval.realvec),ffvsp[-2].real,'-',ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 238:
#line 1026 "eval.y"
{ if( scalarOPrvec(&(ffval.realvec),(double)ffvsp[-2].integer,'-',ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 239:
#line 1028 "eval.y"
{ if( scalarOPrvec(&(ffval.realvec),-ffvsp[0].real,'+',CastIvecToRvec(ffvsp[-2].intvec)) ) FFERROR; ;
    break;}
case 240:
#line 1030 "eval.y"
{ if( scalarOPrvec(&(ffval.realvec),ffvsp[-2].real,'-',CastIvecToRvec(ffvsp[0].intvec)) ) FFERROR; ;
    break;}
case 241:
#line 1032 "eval.y"
{ if( rvecOPrvec(&(ffval.realvec), CastIvecToRvec(ffvsp[-2].intvec), '-', ffvsp[0].realvec ) ) FFERROR; ;
    break;}
case 242:
#line 1034 "eval.y"
{ if( rvecOPrvec(&(ffval.realvec),ffvsp[-2].realvec,'-',CastIvecToRvec(ffvsp[0].intvec)) ) FFERROR; ;
    break;}
case 243:
#line 1036 "eval.y"
{ if( rvecOPrvec(&(ffval.realvec),ffvsp[-2].realvec,'-',ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 244:
#line 1039 "eval.y"
{ if( scalarOPrvec(&(ffval.realvec),ffvsp[0].real,'*',ffvsp[-2].realvec) ) FFERROR; ;
    break;}
case 245:
#line 1041 "eval.y"
{ if( scalarOPrvec(&(ffval.realvec),(double)ffvsp[0].integer,'*',ffvsp[-2].realvec) ) FFERROR; ;
    break;}
case 246:
#line 1043 "eval.y"
{ if( scalarOPrvec(&(ffval.realvec),ffvsp[-2].real,'*',ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 247:
#line 1045 "eval.y"
{ if( scalarOPrvec(&(ffval.realvec),(double)ffvsp[-2].integer,'*',ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 248:
#line 1047 "eval.y"
{ if( scalarOPrvec(&(ffval.realvec),ffvsp[0].real,'*',CastIvecToRvec(ffvsp[-2].intvec)) ) FFERROR; ;
    break;}
case 249:
#line 1049 "eval.y"
{ if( scalarOPrvec(&(ffval.realvec),ffvsp[-2].real,'*',CastIvecToRvec(ffvsp[0].intvec)) ) FFERROR; ;
    break;}
case 250:
#line 1051 "eval.y"
{ if( rvecOPrvec(&(ffval.realvec),CastIvecToRvec(ffvsp[-2].intvec),'*',ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 251:
#line 1053 "eval.y"
{ if( rvecOPrvec(&(ffval.realvec),ffvsp[-2].realvec,'*',CastIvecToRvec(ffvsp[0].intvec)) ) FFERROR; ;
    break;}
case 252:
#line 1055 "eval.y"
{ if( rvecOPrvec(&(ffval.realvec),ffvsp[-2].realvec,'*',ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 253:
#line 1058 "eval.y"
{ if(ffvsp[0].real) {
                          if( scalarOPrvec(&(ffval.realvec),1.0/ffvsp[0].real,'*',ffvsp[-2].realvec) ) FFERROR;
		  } else { 
		          fferror("divide by zero");
                          FFERROR;
                         }
                ;
    break;}
case 254:
#line 1066 "eval.y"
{ if(ffvsp[0].integer) {
                         if( scalarOPrvec(&(ffval.realvec),1.0/ffvsp[0].integer,'*',ffvsp[-2].realvec) ) FFERROR;
		  } else { 
		         fferror("divide by zero");
			 FFERROR;
		       }
                ;
    break;}
case 255:
#line 1074 "eval.y"
{ if( scalarOPrvec(&(ffval.realvec),ffvsp[-2].real,'/',ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 256:
#line 1076 "eval.y"
{ if( scalarOPrvec(&(ffval.realvec),(double)ffvsp[-2].integer,'/',ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 257:
#line 1078 "eval.y"
{ if(ffvsp[0].real) {
                         if( scalarOPrvec(&(ffval.realvec),1.0/ffvsp[0].real,'*',CastIvecToRvec(ffvsp[-2].intvec)) )
			    FFERROR;
		  } else { 
		         fferror("divide by zero");
			 FFERROR;
		       }
                ;
    break;}
case 258:
#line 1087 "eval.y"
{ if( scalarOPrvec(&(ffval.realvec),ffvsp[-2].real,'/',CastIvecToRvec(ffvsp[0].intvec)) ) FFERROR; ;
    break;}
case 259:
#line 1089 "eval.y"
{ if( rvecOPrvec(&(ffval.realvec),CastIvecToRvec(ffvsp[-2].intvec),'/',ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 260:
#line 1091 "eval.y"
{ if( rvecOPrvec(&(ffval.realvec),ffvsp[-2].realvec,'/',CastIvecToRvec(ffvsp[0].intvec)) ) FFERROR; ;
    break;}
case 261:
#line 1093 "eval.y"
{ if( rvecOPrvec(&(ffval.realvec),ffvsp[-2].realvec,'/',ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 262:
#line 1096 "eval.y"
{ if( scalarOPrvec(&(ffval.realvec),ffvsp[-2].real,'*',CastBvecToRvec(ffvsp[0].boolvec)) ) FFERROR; ;
    break;}
case 263:
#line 1098 "eval.y"
{ if( scalarOPrvec(&(ffval.realvec),ffvsp[0].real,'*',CastBvecToRvec(ffvsp[-2].boolvec)) ) FFERROR; ;
    break;}
case 264:
#line 1100 "eval.y"
{ if( rvecOPrvec(&(ffval.realvec),ffvsp[-2].realvec,'*',CastBvecToRvec(ffvsp[0].boolvec)) ) FFERROR; ;
    break;}
case 265:
#line 1102 "eval.y"
{ if( rvecOPrvec(&(ffval.realvec),CastBvecToRvec(ffvsp[-2].boolvec),'*',ffvsp[0].realvec) ) FFERROR; ;
    break;}
case 266:
#line 1104 "eval.y"
{ int idx;
                  ffval.realvec = ffvsp[-2].realvec;
                  if( ! ffvsp[0].boolean )
                     for(idx=0;idx<ffval.realvec.nelem;idx++) ffval.realvec.rptr[idx]=0.0;
                ;
    break;}
case 267:
#line 1110 "eval.y"
{ int idx;
                  ffval.realvec = ffvsp[0].realvec;
                  if( ! ffvsp[-2].boolean )
                     for(idx=0;idx<ffval.realvec.nelem;idx++) ffval.realvec.rptr[idx]=0.0;
                ;
    break;}
case 268:
#line 1117 "eval.y"
{ ffval.realvec = CastIvecToRvec(ffvsp[0].intvec); ;
    break;}
case 269:
#line 1119 "eval.y"
{ ffval.realvec = ffvsp[0].realvec; ;
    break;}
case 270:
#line 1121 "eval.y"
{ ffval.realvec = CastBvecToRvec(ffvsp[0].boolvec); ;
    break;}
case 271:
#line 1123 "eval.y"
{ ffval.realvec = ffvsp[-1].realvec; ;
    break;}
case 272:
#line 1127 "eval.y"
{ ffval.intseq.nelem = 1;
                  ffval.intseq.val[0]=ffvsp[-1].integer;  ;
    break;}
case 273:
#line 1130 "eval.y"
{ ffval.intseq.nelem = 2;
                  ffval.intseq.val[0]=ffvsp[-3].integer;
                  ffval.intseq.val[1]=ffvsp[-1].integer;  ;
    break;}
case 274:
#line 1134 "eval.y"
{ ffval.intseq.nelem = 3;
                  ffval.intseq.val[0]=ffvsp[-5].integer;
                  ffval.intseq.val[1]=ffvsp[-3].integer;
                  ffval.intseq.val[2]=ffvsp[-1].integer;  ;
    break;}
case 275:
#line 1139 "eval.y"
{ ffval.intseq.nelem = 4;
                  ffval.intseq.val[0]=ffvsp[-7].integer;
                  ffval.intseq.val[1]=ffvsp[-5].integer;
                  ffval.intseq.val[2]=ffvsp[-3].integer;
                  ffval.intseq.val[3]=ffvsp[-1].integer;  ;
    break;}
case 276:
#line 1145 "eval.y"
{ ffval.intseq.nelem = 5;
                  ffval.intseq.val[0]=ffvsp[-9].integer;
                  ffval.intseq.val[1]=ffvsp[-7].integer;
                  ffval.intseq.val[2]=ffvsp[-5].integer;
                  ffval.intseq.val[3]=ffvsp[-3].integer;
                  ffval.intseq.val[4]=ffvsp[-1].integer; ;
    break;}
case 277:
#line 1154 "eval.y"
{ ffval.realseq.nelem = 2; ffval.realseq.val[0]=ffvsp[-2].real; ffval.realseq.val[1]=ffvsp[0].real; ;
    break;}
case 278:
#line 1156 "eval.y"
{ ffval.realseq.nelem = 2; ffval.realseq.val[0]=ffvsp[-2].integer; ffval.realseq.val[1]=ffvsp[0].real; ;
    break;}
case 279:
#line 1158 "eval.y"
{ ffval.realseq.nelem = 2; ffval.realseq.val[0]=ffvsp[-2].real; ffval.realseq.val[1]=ffvsp[0].integer; ;
    break;}
case 280:
#line 1160 "eval.y"
{ if( ffvsp[-2].realseq.nelem+1==MAXSEQ ) {
                     fferror("Sequence too long.");
                     FFERROR;
                  }
                  ffval.realseq = ffvsp[-2].realseq;
                  ffval.realseq.val[ffvsp[-2].realseq.nelem] = ffvsp[0].real;
                  ffval.realseq.nelem++;
                ;
    break;}
case 281:
#line 1169 "eval.y"
{ if( ffvsp[-2].realseq.nelem+1==MAXSEQ ) {
                     fferror("Sequence too long.");
                     FFERROR;
                  }
                  ffval.realseq = ffvsp[-2].realseq;
                  ffval.realseq.val[ffvsp[-2].realseq.nelem] = ffvsp[0].integer;
                  ffval.realseq.nelem++;
                ;
    break;}
case 283:
#line 1181 "eval.y"
{ strcpy(ffval.string,ffvsp[-1].string); ;
    break;}
case 284:
#line 1183 "eval.y"
{ int ivalue = strlen(ffvsp[-2].string) - 1;
                 ffvsp[-2].string[ivalue] = (char)NULL;
                 strcat(ffvsp[-2].string,&(ffvsp[0].string[1]));
                 strcpy(ffval.string,ffvsp[-2].string);
               ;
    break;}
}
   /* the action file gets copied in in place of this dollarsign */
#line 498 "/usr/local/share/bison.simple"

  ffvsp -= fflen;
  ffssp -= fflen;
#ifdef FFLSP_NEEDED
  fflsp -= fflen;
#endif

#if FFDEBUG != 0
  if (ffdebug)
    {
      short *ssp1 = ffss - 1;
      fprintf (stderr, "state stack now");
      while (ssp1 != ffssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

  *++ffvsp = ffval;

#ifdef FFLSP_NEEDED
  fflsp++;
  if (fflen == 0)
    {
      fflsp->first_line = fflloc.first_line;
      fflsp->first_column = fflloc.first_column;
      fflsp->last_line = (fflsp-1)->last_line;
      fflsp->last_column = (fflsp-1)->last_column;
      fflsp->text = 0;
    }
  else
    {
      fflsp->last_line = (fflsp+fflen-1)->last_line;
      fflsp->last_column = (fflsp+fflen-1)->last_column;
    }
#endif

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  ffn = ffr1[ffn];

  ffstate = ffpgoto[ffn - FFNTBASE] + *ffssp;
  if (ffstate >= 0 && ffstate <= FFLAST && ffcheck[ffstate] == *ffssp)
    ffstate = fftable[ffstate];
  else
    ffstate = ffdefgoto[ffn - FFNTBASE];

  goto ffnewstate;

fferrlab:   /* here on detecting error */

  if (! fferrstatus)
    /* If not already recovering from an error, report this error.  */
    {
      ++ffnerrs;

#ifdef FFERROR_VERBOSE
      ffn = ffpact[ffstate];

      if (ffn > FFFLAG && ffn < FFLAST)
	{
	  int size = 0;
	  char *msg;
	  int x, count;

	  count = 0;
	  /* Start X at -ffn if nec to avoid negative indexes in ffcheck.  */
	  for (x = (ffn < 0 ? -ffn : 0);
	       x < (sizeof(fftname) / sizeof(char *)); x++)
	    if (ffcheck[x + ffn] == x)
	      size += strlen(fftname[x]) + 15, count++;
	  msg = (char *) malloc(size + 15);
	  if (msg != 0)
	    {
	      strcpy(msg, "parse error");

	      if (count < 5)
		{
		  count = 0;
		  for (x = (ffn < 0 ? -ffn : 0);
		       x < (sizeof(fftname) / sizeof(char *)); x++)
		    if (ffcheck[x + ffn] == x)
		      {
			strcat(msg, count == 0 ? ", expecting `" : " or `");
			strcat(msg, fftname[x]);
			strcat(msg, "'");
			count++;
		      }
		}
	      fferror(msg);
	      free(msg);
	    }
	  else
	    fferror ("parse error; also virtual memory exceeded");
	}
      else
#endif /* FFERROR_VERBOSE */
	fferror("parse error");
    }

  goto fferrlab1;
fferrlab1:   /* here on error raised explicitly by an action */

  if (fferrstatus == 3)
    {
      /* if just tried and failed to reuse lookahead token after an error, discard it.  */

      /* return failure if at end of input */
      if (ffchar == FFEOF)
	FFABORT;

#if FFDEBUG != 0
      if (ffdebug)
	fprintf(stderr, "Discarding token %d (%s).\n", ffchar, fftname[ffchar1]);
#endif

      ffchar = FFEMPTY;
    }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  fferrstatus = 3;		/* Each real token shifted decrements this */

  goto fferrhandle;

fferrdefault:  /* current state does not do anything special for the error token. */

#if 0
  /* This is wrong; only states that explicitly want error tokens
     should shift them.  */
  ffn = ffdefact[ffstate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
  if (ffn) goto ffdefault;
#endif

fferrpop:   /* pop the current state because it cannot handle the error token */

  if (ffssp == ffss) FFABORT;
  ffvsp--;
  ffstate = *--ffssp;
#ifdef FFLSP_NEEDED
  fflsp--;
#endif

#if FFDEBUG != 0
  if (ffdebug)
    {
      short *ssp1 = ffss - 1;
      fprintf (stderr, "Error: state stack now");
      while (ssp1 != ffssp)
	fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
#endif

fferrhandle:

  ffn = ffpact[ffstate];
  if (ffn == FFFLAG)
    goto fferrdefault;

  ffn += FFTERROR;
  if (ffn < 0 || ffn > FFLAST || ffcheck[ffn] != FFTERROR)
    goto fferrdefault;

  ffn = fftable[ffn];
  if (ffn < 0)
    {
      if (ffn == FFFLAG)
	goto fferrpop;
      ffn = -ffn;
      goto ffreduce;
    }
  else if (ffn == 0)
    goto fferrpop;

  if (ffn == FFFINAL)
    FFACCEPT;

#if FFDEBUG != 0
  if (ffdebug)
    fprintf(stderr, "Shifting error token, ");
#endif

  *++ffvsp = fflval;
#ifdef FFLSP_NEEDED
  *++fflsp = fflloc;
#endif

  ffstate = ffn;
  goto ffnewstate;
}
#line 1190 "eval.y"


#define myPI  3.1415926535897932385

static ivec CastBvecToIvec(bvec vector)
{
   int idx;
   ivec newvec;

   newvec.nelem = vector.nelem; 
   newvec.naxis = vector.naxis;
   for(idx=0;idx<newvec.naxis;idx++) newvec.naxes[idx] = vector.naxes[idx];
   newvec.undef = vector.undef;
   newvec.iptr  = (long*)malloc(newvec.nelem*sizeof(long));
   for(idx=0;idx<newvec.nelem;idx++) {
      newvec.iptr[idx] = ( vector.bptr[idx] ? 1 : 0 );
   }
   free(vector.bptr);
   return newvec;
}

static rvec CastBvecToRvec(bvec vector)
{
   int idx;
   rvec newvec;

   newvec.nelem = vector.nelem; 
   newvec.naxis = vector.naxis;
   for(idx=0;idx<newvec.naxis;idx++) newvec.naxes[idx] = vector.naxes[idx];
   newvec.undef = vector.undef;
   newvec.rptr  = (double*)malloc(newvec.nelem*sizeof(double));
   for(idx=0;idx<newvec.nelem;idx++) {
      newvec.rptr[idx] = ( vector.bptr[idx] ? 1.0 : 0.0 );
   }
   free(vector.bptr);
   return newvec;
}

static rvec CastIvecToRvec(ivec vector)
{
   int idx;
   rvec newvec;

   newvec.nelem = vector.nelem; 
   newvec.naxis = vector.naxis;
   for(idx=0;idx<newvec.naxis;idx++) newvec.naxes[idx] = vector.naxes[idx];
   newvec.undef = vector.undef;
   newvec.rptr  = (double*)malloc(newvec.nelem*sizeof(double));
   for(idx=0;idx<newvec.nelem;idx++) {
      newvec.rptr[idx]  = (double)vector.iptr[idx];
   }
   free(vector.iptr);
   return newvec;
}

static int scalarOPivec(void *result, int scalar, int op, ivec vector)
{
   int idx;
   ivec *intvec;
   bvec *boolvec;

   intvec  = (ivec*)result;
   boolvec = (bvec*)result;
   *intvec = vector;
   for( idx=0; idx<vector.nelem; idx++ ) {
      switch (op) {
      case '+':
	 vector.iptr[idx] += scalar;
	 break;
      case '*':
         vector.iptr[idx] *= scalar;
         break;
      case '-':
         vector.iptr[idx] = scalar - vector.iptr[idx];
         break;
      case '%':
         vector.iptr[idx] = scalar % vector.iptr[idx];
         break;
      case '/':
         if( vector.iptr[idx] )
             vector.iptr[idx] = scalar / vector.iptr[idx];
	 else {
	     fferror("divide by zero");
	     return(1);
         }
         break;
      case EQ:
         boolvec->bptr[idx] = (scalar == vector.iptr[idx]);
         break;						  
      case NE:						  
         boolvec->bptr[idx] = (scalar != vector.iptr[idx]);
         break;						  
      case GT:						  
         boolvec->bptr[idx] = (scalar >  vector.iptr[idx]);
         break;						  
      case LT:						  
         boolvec->bptr[idx] = (scalar <  vector.iptr[idx]);
         break;						  
      case GTE:						  
         boolvec->bptr[idx] = (scalar >= vector.iptr[idx]);
         break;						  
      case LTE:						  
         boolvec->bptr[idx] = (scalar <= vector.iptr[idx]);
         break;
      }
   }
   return(0);
}

static int ivecOPivec(void *result, ivec vec1, int op, ivec vec2)
{
   int idx,samedim;
   ivec *intvec;
   bvec *boolvec;

   intvec  = (ivec*)result;
   boolvec = (bvec*)result;
   *intvec = vec1;

   samedim = 0;
   if( vec1.nelem==vec2.nelem && vec1.naxis==vec2.naxis ) {
      for( idx=0; idx<vec1.naxis; idx++ )
         if( vec1.naxes[idx]!=vec2.naxes[idx] ) break;
      samedim = ( idx==vec1.naxis );
   }

   if( samedim ) {
      for( idx=0; idx<vec1.nelem; idx++ ) {
	 vec1.undef[idx] |= vec2.undef[idx];
	 switch (op) {
	 case '+':
	    vec1.iptr[idx] += vec2.iptr[idx];
	    break;
	 case '*':
	    vec1.iptr[idx] *= vec2.iptr[idx];
	    break;
	 case '-':
	    vec1.iptr[idx] -= vec2.iptr[idx];
	    break;
	 case '%':
	    vec1.iptr[idx] %= vec2.iptr[idx];
	    break;
	 case '/':
	    if( vec2.iptr[idx] )
	       vec1.iptr[idx] /= vec2.iptr[idx];
	    else {
	       fferror("divide by zero");
	       return(1);
	    }
	    break;
      case EQ:
         boolvec->bptr[idx] = (vec1.iptr[idx] == vec2.iptr[idx]);
         break;							
      case NE:							
         boolvec->bptr[idx] = (vec1.iptr[idx] != vec2.iptr[idx]);
         break;							
      case GT:							
         boolvec->bptr[idx] = (vec1.iptr[idx] >  vec2.iptr[idx]);
         break;							
      case LT:							
         boolvec->bptr[idx] = (vec1.iptr[idx] <  vec2.iptr[idx]);
         break;							
      case GTE:							
         boolvec->bptr[idx] = (vec1.iptr[idx] >= vec2.iptr[idx]);
         break;							
      case LTE:							
         boolvec->bptr[idx] = (vec1.iptr[idx] <= vec2.iptr[idx]);
         break;
	 }
      }
      free(vec2.iptr); free(vec2.undef); 
   } else {
      free(vec1.iptr); free(vec1.undef);
      free(vec2.iptr); free(vec2.undef);
      fferror("vector sizes do not match");
      return(1);
   }
   return(0);
}

static int scalarOPrvec(void *result, double scalar, int op, rvec vector)
{
   int idx;
   rvec *realvec;
   bvec *boolvec;

   realvec = (rvec*)result;
   boolvec = (bvec*)result;
   *realvec= vector;
   for( idx=0; idx<vector.nelem; idx++ ) {
      switch (op) {
      case '+':
	 vector.rptr[idx] += scalar;
	 break;
      case '*':
         vector.rptr[idx] *= scalar;
         break;
      case '-':
         vector.rptr[idx] = scalar - vector.rptr[idx];
         break;
      case '/':
         if( vector.rptr[idx] )
             vector.rptr[idx] = scalar / vector.rptr[idx];
	 else {
	     fferror("divide by zero");
	     return(1);
         }
         break;
      case EQ:
         boolvec->bptr[idx] = (scalar == vector.rptr[idx]);
         break;						  
      case NE:						  
         boolvec->bptr[idx] = (scalar != vector.rptr[idx]);
         break;						  
      case GT:						  
         boolvec->bptr[idx] = (scalar >  vector.rptr[idx]);
         break;						  
      case LT:						  
         boolvec->bptr[idx] = (scalar <  vector.rptr[idx]);
         break;						  
      case GTE:						  
         boolvec->bptr[idx] = (scalar >= vector.rptr[idx]);
         break;						  
      case LTE:						  
         boolvec->bptr[idx] = (scalar <= vector.rptr[idx]);
         break;
      }
   }
   return(0);
}

static int rvecOPrvec(void *result, rvec vec1, int op, rvec vec2)
{
   int idx,samedim;
   rvec *realvec;
   bvec *boolvec;

   realvec = (rvec*)result;
   boolvec = (bvec*)result;
   *realvec= vec1;

   samedim = 0;
   if( vec1.nelem==vec2.nelem && vec1.naxis==vec2.naxis ) {
      for( idx=0; idx<vec1.naxis; idx++ )
         if( vec1.naxes[idx]!=vec2.naxes[idx] ) break;
      samedim = ( idx==vec1.naxis );
   }

   if( samedim ) {
      for( idx=0; idx<vec1.nelem; idx++ ) {
	 vec1.undef[idx] |= vec2.undef[idx];
	 switch (op) {
	 case '+':
	    vec1.rptr[idx] += vec2.rptr[idx];
	    break;
	 case '*':
	    vec1.rptr[idx] *= vec2.rptr[idx];
	    break;
	 case '-':
	    vec1.rptr[idx] -= vec2.rptr[idx];
	    break;
	 case '/':
	    if( vec2.rptr[idx] )
	       vec1.rptr[idx] /= vec2.rptr[idx];
	    else {
	       fferror("divide by zero");
	       return(1);
	    }
	    break;
      case EQ:
         boolvec->bptr[idx] = (vec1.rptr[idx] == vec2.rptr[idx]);
         break;							
      case NE:							
         boolvec->bptr[idx] = (vec1.rptr[idx] != vec2.rptr[idx]);
         break;							
      case GT:							
         boolvec->bptr[idx] = (vec1.rptr[idx] >  vec2.rptr[idx]);
         break;							
      case LT:							
         boolvec->bptr[idx] = (vec1.rptr[idx] <  vec2.rptr[idx]);
         break;							
      case GTE:							
         boolvec->bptr[idx] = (vec1.rptr[idx] >= vec2.rptr[idx]);
         break;							
      case LTE:							
         boolvec->bptr[idx] = (vec1.rptr[idx] <= vec2.rptr[idx]);
         break;
	 }
      }
      free(vec2.rptr); free(vec2.undef); 
   } else {
      free(vec1.rptr); free(vec1.undef);
      free(vec2.rptr); free(vec2.undef);
      fferror("vector sizes do not match");
      return(1);
   }
   return(0);
}

static char bitlgte(char *bits1, int oper, char *bits2)
{
 int val1, val2, nextbit;
 char result;
 int i, l1, l2, length, ldiff;
 char stream1[256], stream2[256], zero[256];
 char chr1, chr2;

 result = 0;
 val1 = val2 = 0;
 nextbit = 1;
 stream1[0] = '\0';
 stream2[0] = '\0';
 l1 = strlen(bits1);
 l2 = strlen(bits2);
 if (l1 < l2)
   {
    length = l2;
    ldiff = l2 - l1;
    for (i=0;i<(ldiff);i++) zero[i] = '0';
    zero[ldiff] = '\0';
    strcat(stream1, zero);
    strcat(stream1, bits1);
    strcpy(stream2, bits2);
   }
 else if (l2 < l1)
   {
    length = l1;
    ldiff = l1 - l2;
    for (i=0;i<(ldiff);i++) zero[i] = '0';
    zero[ldiff] = '\0';
    strcat(stream2, zero);
    strcat(stream2, bits2);
    strcpy(stream1, bits1);
   }
 else
   {
    length = l1;
    strcpy(stream1, bits1);
    strcpy(stream2, bits2);
   }
 i = 0;
 for (i=length-1;i>=0;i--)
    {
     chr1 = stream1[i];
     chr2 = stream2[i];
     if ((chr1 != 'x')&&(chr1 != 'X')&&(chr2 != 'x')&&(chr2 != 'X'))
       {
        if (chr1 == '1') val1 += nextbit;
        if (chr2 == '1') val2 += nextbit;
        nextbit *= 2;
       }
    }
 switch (oper)
       {
        case LESSTHAN:
             if (val1 < val2) result = 1;
             break;
        case LESSTHANEQ:
             if (val1 <= val2) result = 1;
             break;
        case GREATERTHAN:
             if (val1 > val2) result = 1;
             break;
        case GREATERTHANEQ:
             if (val1 >= val2) result = 1;
             break;
       }
 return (result);
}

static void bitand(char *result,char *bitstrm1,char *bitstrm2)
{
 int i, l1, l2, length, ldiff;
 char stream1[256], stream2[256], zero[256];
 char chr1, chr2;

 stream1[0] = '\0';
 stream2[0] = '\0';
 l1 = strlen(bitstrm1);
 l2 = strlen(bitstrm2);
 if (l1 < l2)
   {
    length = l2;
    ldiff = l2 - l1;
    for (i=0;i<(ldiff);i++) zero[i] = '0';
    zero[ldiff] = '\0';
    strcat(stream1, zero);
    strcat(stream1, bitstrm1);
    strcpy(stream2, bitstrm2);
   }
 if (l2 < l1)
   {
    length = l1;
    ldiff = l1 - l2;
    for (i=0;i<(ldiff);i++) zero[i] = '0';
    zero[ldiff] = '\0';
    strcat(stream2, zero);
    strcat(stream2, bitstrm2);
    strcpy(stream1, bitstrm1);
   }
 if (l1 == l2)
   {
    length = l1;
    strcpy(stream1, bitstrm1);
    strcpy(stream2, bitstrm2);
   }
 i = 0;
 chr1 = stream1[i];
 chr2 = stream2[i];
 while (chr1 != '\0')
      {
       if ((chr1 == 'x') || (chr2 == 'x'))
          result[i] = 'x';
       else if ((chr1 == '1') && (chr2 == '1'))
          result[i] = '1';
       else
          result[i] = '0';
       i++;
       chr1 = stream1[i];
       chr2 = stream2[i];
      }
 result[i] = '\0';
}

static void bitor(char *result,char *bitstrm1,char *bitstrm2)
{
 int i, l1, l2, length, ldiff;
 char stream1[256], stream2[256], zero[256];
 char chr1, chr2;

 stream1[0] = '\0';
 stream2[0] = '\0';
 l1 = strlen(bitstrm1);
 l2 = strlen(bitstrm2);
 if (l1 < l2)
   {
    length = l2;
    ldiff = l2 - l1;
    for (i=0;i<(ldiff);i++) zero[i] = '0';
    zero[ldiff] = '\0';
    strcat(stream1, zero);
    strcat(stream1, bitstrm1);
    strcpy(stream2, bitstrm2);
   }
 if (l2 < l1)
   {
    length = l1;
    ldiff = l1 - l2;
    for (i=0;i<(ldiff);i++) zero[i] = '0';
    zero[ldiff] = '\0';
    strcat(stream2, zero);
    strcat(stream2, bitstrm2);
    strcpy(stream1, bitstrm1);
   }
 if (l1 == l2)
   {
    length = l1;
    strcpy(stream1, bitstrm1);
    strcpy(stream2, bitstrm2);
   }
 i = 0;
 chr1 = stream1[i];
 chr2 = stream2[i];
 while (chr1 != '\0')
      {
       if ((chr1 == '0') && (chr2 == '0'))
          result[i] = '0';
       else if ((chr1 == '1') || (chr2 == '1'))
          result[i] = '1';
       else if ((chr1 == 'x') && (chr2 == 'x'))
          result[i] = 'x';
       else
          result[i] = '0';
       i++;
       chr1 = stream1[i];
       chr2 = stream2[i];
      }
 result[i] = '\0';
}

static void bitnot(char *result,char *bits)
{
 int i, length;
 char chr;

 length = strlen(bits);
 for (i=0;i<length;i++)
    {
     chr = bits[i];
     if ( chr == '1' )
       result[i] = '0';
     else if ( chr == '0' )
       result[i] = '1';
     else
       result[i] = chr;
    }
 result[length] = '\0';
}

static char bitcmp(char *bitstrm1, char *bitstrm2)
{
 int i, l1, l2, length, ldiff;
 char stream1[256], stream2[256], zero[256], result;
 char chr1, chr2;

 result = 1;
 stream1[0] = '\0';
 stream2[0] = '\0';
 l1 = strlen(bitstrm1);
 l2 = strlen(bitstrm2);
 if (l1 < l2)
   {
    length = l2;
    ldiff = l2 - l1;
    for (i=0;i<(ldiff);i++) zero[i] = '0';
    zero[ldiff] = '\0';
    strcat(stream1, zero);
    strcat(stream1, bitstrm1);
    strcpy(stream2, bitstrm2);
   }
 if (l2 < l1)
   {
    length = l1;
    ldiff = l1 - l2;
    for (i=0;i<(ldiff);i++) zero[i] = '0';
    zero[ldiff] = '\0';
    strcat(stream2, zero);
    strcat(stream2, bitstrm2);
    strcpy(stream1, bitstrm1);
   }
 if (l1 == l2)
   {
    length = l1;
    strcpy(stream1, bitstrm1);
    strcpy(stream2, bitstrm2);
   }
 i = 0;
 chr1 = 'x';
 while ((result == 1) && (chr1 != '\0'))
      {
       chr1 = stream1[i];
       chr2 = stream2[i];
       if ( ((chr1 == '0') && (chr2 == '1')) || ((chr1 == '1') && (chr2 == '0')) )
         {
          result = 0;
         }
       i++;
      }
 return (result);
}

static char near(double x, double y, double tolerance)
{
 if (fabs(x - y) < tolerance)
   return ( 1 );
 else
   return ( 0 );
}

static char saobox(double xcen, double ycen, double xrad, double yrad,
		   double rot, double xcol, double ycol)
{
 double x0,y0,xprime,yprime,xmin,xmax,ymin,ymax,theta;

 theta = (rot / 180.0) * myPI;
 xprime = xcol - xcen;
 yprime = ycol - ycen;
 x0 =  xprime * cos(theta) + yprime * sin(theta);
 y0 = -xprime * sin(theta) + yprime * cos(theta);
 xmin = - xrad/2.0; xmax = xrad/2.0;
 ymin = - yrad/2.0; ymax = yrad/2.0;
 if ((x0 >= xmin) && (x0 <= xmax) && (y0 >= ymin) && (y0 <= ymax))
   return ( 1 );
 else
   return ( 0 );
}

static char circle(double xcen, double ycen, double rad,
		   double xcol, double ycol)
{
 double r2,dx,dy,dlen;

 dx = xcol - xcen;
 dy = ycol - ycen;
 dx *= dx; dy *= dy;
 dlen = dx + dy;
 r2 = rad * rad;
 if (dlen <= r2)
   return ( 1 );
 else
   return ( 0 );
}

static char ellipse(double xcen, double ycen, double xrad, double yrad,
		    double rot, double xcol, double ycol)
{
 double x0,y0,xprime,yprime,dx,dy,dlen,theta;

 theta = (rot / 180.0) * myPI;
 xprime = xcol - xcen;
 yprime = ycol - ycen;
 x0 =  xprime * cos(theta) + yprime * sin(theta);
 y0 = -xprime * sin(theta) + yprime * cos(theta);
 dx = x0 / xrad; dy = y0 / yrad;
 dx *= dx; dy *= dy;
 dlen = sqrt(dx + dy);
 if (dlen <= 1.0)
   return ( 1 );
 else
   return ( 0 );
}

void fferror(char *s)
{
    char msg[80];

    gParse.status = PARSE_SYNTAX_ERR;

    strncpy(msg, s, 80);
    msg[79] = '\0';
    ffpmsg(msg);
}

