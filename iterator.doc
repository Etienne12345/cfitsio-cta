    Instructions for using the fits_iterate_data routine in CFITSIO
       (see also the example programs iter_a.c through iter_e.c)

                      January 16, 1998

The fits_iterate_data function in CFITSIO provides a simple method of
applying an arbitrary 'work' function to the rows of a FITS table or
the pixels of an image.  Instead of having to explicitly read and write
FITS images or columns of data in FITS tables, the programmer simply
calls a single CFITSIO 'iterator' routine, passing to it the name of
the work function that is to be executed along with a list of all the
table columns (or image arrays) that are to be passed to it.  The
iterator function then does all the work of allocating memory for the
arrays, reading the input data from the FITS file, calling the work
function, and writing the output data back to the FITS file after the
work function exits.  Since it is often more efficient to process just
a subset of the total table rows or image pixels at one time, the
iterator function can determine the optimum amount of data to pass in
each iteration and repeatly call the work function until all the data
have been processed.

This single CFITSIO iterator routine effectively replaces dozens of
other CFITSIO routines for reading or writing FITS images or tables.
Using the iterator routine can thus greatly simplify application
programs by eliminating all code needed to explicitly read and write
the data as well as having to allocate and manage the memory required
to store the data arrays.  It also makes the application code more
efficient because it can process the data in optimum-sized chunks.

The iterator function is very general and supports reading and writing
image data as well as table columns.  This is possible because a FITS
image can be regarded as a FITS binary table with a single row and a
single column which contains the entire image array as a vector table
element.  The tables columns or image arrays that are passed to the
work function do not all have to come from the same FITS extension or
file and instead may come from any combination sources as long as they
have the same length.  The programmer can also specify the desired
datatype for all the arrays and CFITSIO will do the conversion if
needed.  The iterator also provides full support for reading and
writing null or undefined pixels in the arrays.  The programmer can
also override the default behaviour of the iterator and force it to
process only a selected range of table rows (or image pixels) and force
it to pass a certain number of rows (or all the rows) to the work
function on each iteration.

There are basically 2 steps in using the CFITSIO iterator function, as
described in more detail below.  The first step is to design the work
function itself which must have the prescribed set of input
parameters.  One of the input parameter to the work function is a
structure containing pointers to the arrays of column data; the work
function can perform any desired operations on these arrays and does
not need to worry about how the input data were read from the file or
how the output data get written back to the file.

The second step is to design the main routine that opens or creates all
the necessary FITS files and defines all the input parameters to the
iterator function.  The program then calls the iterator function which
in turn calls the work function.

There are 5 example programs included with this distribution
of CFITSIO that illustrate uses of the iterator function:

  iter_a.c -  reads an integer and a float column from a table and
              writes the quotient back to another float table column.

  iter_b.c - same as iter_a.c, but all the arrays are converted to
             double before being passed to the work function

  iter_c.c - same as iter_b.c but it also checks for null values in
             the input arrays and writes nulls to the output array.

  iter_d.c - reads a string and a logical datatype column and modifies
             the values each time the program is executed.

  iter_e.c - computes a 2D histogram image from the X and Y 
             columns in an event list.  This also illustrates
             how the iterator function can be called recursively.

Designing the Work Function
---------------------------

The first step in using fits_iterate_data is to write the work
function, which must have the following set of input arguments:

 long totalvalues - the total number of table rows or image pixels
                    that will be passed to the work function.  

 long offset      - the offset to the first row number or image
                    pixel that is passed to the work function.  If 
                    offset = 0, then all the rows or pixels will be
                    passed to the work function.

 long firstvalue  - the first table row or image pixel number that
                    is being passed in this particular call to the
                    work function.  The value is relative to the
                    input offset value, so the actual table row
                    or image pixel number = (offset + firstvalue).

 long nvalues     - number of table rows or image pixels that are
                    being passed in this particular call to the work
                    function.  nvalues will always be less than or
                    equal to totalvalues.

 int narrays      - the number of arrays of data that are being passed
                    to the work function.  Each array represents 
                    one image or table column.
                   
 iteratorCol *cols - array of structures, one for each input
                    column or image.  The contents of this structure
                    are described below.

 void *userPointer - this is a user supplied pointer that can be used
                    to pass ancillary information into the work function.
                    It may point to a single number, an array, or to
                    a structure containing an arbitrary set of parameters.
                    The work function must cast this pointer to the
                    appropriate data type.


The iteratorCol structure is currently defined as follows:

typedef struct  /* structure for the iterator function column information */
{  
     /* elements required as input to fits_iterate_data: */

    fitsfile *fptr;     /* pointer to the HDU containing the column */
    int      colnum;    /* column number in the table (use name if < 1) */
    char     colname[70]; /* name (= TTYPEn value) of the column (optional) */
    int      datatype;  /* output datatype (converted if necessary  */
    int      iotype;    /* = InputCol, InputOutputCol, or OutputCol */

    /* output elements that may be useful for the work function: */

    void     *array;    /* pointer to the array (and the null value) */
    long     repeat;    /* binary table vector repeat value */
    long     tlmin;     /* legal minimum data value */
    long     tlmax;     /* legal maximum data value */
    char     tunit[70]; /* physical unit string */
    char     tdisp[70]; /* suggested display format */

} iteratorCol;


Not all of these arguments will be useful in every work function.  The
totalvalues, offset, firstvalue, and nvalues arguments are mainly
useful for determining how much of the data has been processed, and how
much remains left to do.  If firstvalue = 1, then this is the first
time the work function has been called, which often requires certain
initialization steps to be performed.  Similarly, if (firstvalue +
nvalues - 1) = totalvalues, then this indicates the end of the data and
that this is the last time that the work function will be called.  If
necessary, certain clean up operations can then be performed before
exiting the work function.  The narrays and iteratorCol.datatype
arguments allow the work function to double check that the number of
input arrays and their datatypes have the expected values.  The
iteratorCol.fptr and iteratorCol.colnum arguments are needed if the
work function has to read or write the values of other keywords in the
FITS file associated with each array.  This should generally only be
done during the initialization step, or during the clean up step after
the last set of data has been processed.

The iteratorCol.array argument supplies a pointer to the data array.
This pointer must be cast to a pointer of the correct data type before
the array can be used.  The work function can perform any desired
operations on this array.  One important feature to keep in mind is
that the first element of the array gives the value that is used to
represent null or undefined values in the array.  The real data then
begins with the second element of the array (i.e., array[1], not
array[0]).  If the first array element is equal to zero, then this
indicates that all the array elements have defined values and there are
no undefined values.  If array[0] is not equal to zero, then this 
indicates that some of the data values are undefined and this value
(array[0]) is used as a flag for the undefined pixels.  In the case
of output arrays (i.e., those arrays that will be written back to the
FITS file by the iterator function after the work function exits) the
work function must set the first array element to the desired null
value if necessary, otherwise the first element should be set to zero
to indicate that there are no null values.

Upon completion the work routine must return an integer status value.
0 indicates success, and any other value indicates an error condition
which will cause fits_iterate_data to exit at that point.  Return
status values in the range 1 - 1000 should be avoided since these are
reserved for use by CFITSIO.

In some cases it will be necessary to recursively call the iterator
function.  An example of this is given by the iter_e.c program: it
first calls the iterator function with a work function that gets an
image array.  That work function then calls the iterator function again
with a different work function which uses the data in a set of columns
to calculate the values in the image array.  Graphically, the program
stucture can be described as:

 main --> iterator_fn --> work1_fn --> iterator_fn --> work2_fn

This represents a major paradigm shift from the way most application
software has been written in the past.  One significant difference is
the way that other information gets passed to the work functions.
Since the main program does not directly call the work functions, and
the first work function does not directly call the second work function,
additional information cannot be passed directly as subroutine
arguments.  Instead, one must use globally declared variables or
function calls within the work functions to access the additional
information.  The use of globally defined variables in particular can
make the code more difficult to understand and mantain, so the the work
functions should be extensively documented to make it clear where all
the information is coming from.

Executing the Work Function
---------------------------

The work function is executed by passing the name of the function
(actually it's address), along with an additional set of parameters (as
defined below) to the fits_iterate_data routine in CFITSIO.   The
following parameter descriptions refer to table columns, but they can
also be applied to FITS images (primary arrays or image extensions)
since an image can be treated like a table that has one row and one
column containing a vector element. 

  int n_cols     - the number of input columns that are to be passed
                      to the work function.  The values for these columns
                      will only be read from the FITS table, and will not
                      be written back to the table.
 
  iteratorCol *cols - structure containing information about each column.
                      The definition of this structure is defined above.

  long offset       - if positive, then this number of rows at the
                      beginning of the table (or pixels in the image) 
                      will be skipped and will not be passed to the work
                      function.

  long n_per_loop   - specifies the number of table rows (or number of
                      image pixels) that are to be passed to the work
                      function on each iteration.  If n_per_loop = 0
                      then CFITSIO will calculate the optimum number.
                      If n_per_loop is negative, then all the rows
                      or pixels will be passed at once, and the work
                      function will only be called once.

  int work_func     - the name (actually the address) of the work function
                      that is to be called by fits_iterate_data.

  void *userPointer - this is a user supplied pointer that can be used
                      to pass ancillary information into the work function.
                      It may point to a single number, an array, or to
                      a structure containing an arbitrary set of parameters.
                      The work function must cast this pointer to the
                      appropriate data type.

  int *status       - The CFITSIO error status.  Should = 0 on input;
                      a non-zero output value indicates an error.

When fits_iterate_data is called it first allocates memory to hold all
the requested columns of data.  It then reads the input data from the
FITS tables into the arrays then passes a structure with pointers to
these data arrays to the work function.

After the work function returns, the iterator function writes any
output columns of data back to the FITS files.  It then repeats this
whole process for any remaining sets of rows until it has processed the
entire table or until the work function returns a non-zero status
value.  The iterator then frees the memory that it initially allocated
and returns control to the routine that called it.
